"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1998],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(a),m=r,c=u["".concat(s,".").concat(m)]||u[m]||h[m]||i;return a?n.createElement(c,l(l({ref:t},p),{},{components:a})):n.createElement(c,l({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=a[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},95171:function(e,t,a){a.r(t),a.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return h}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),l=["components"],o={sidebar_position:4},s="Porting Tfrag",d={unversionedId:"porting-info/porting_tfrag",id:"porting-info/porting_tfrag",title:"Porting Tfrag",description:"Tfrag is the renderer for non-instanced background geometry. It's typically used for the floor and unique walls/level geometry. It has a level of detail system, and time of day lighting, optionaly transparancy and that's it. No other features.",source:"@site/documentation/porting-info/porting_tfrag.md",sourceDirName:"porting-info",slug:"/porting-info/porting_tfrag",permalink:"/docs/porting-info/porting_tfrag",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/porting-info/porting_tfrag.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Basic Process for Drawing",permalink:"/docs/porting-info/tfrag"}},p={},h=[{value:"DMA",id:"dma",level:2},{value:"The VIF",id:"the-vif",level:2},{value:"VU programs",id:"vu-programs",level:2},{value:"VU buffer hell",id:"vu-buffer-hell",level:2},{value:"GIF",id:"gif",level:2},{value:"Drawables for Tfrag",id:"drawables-for-tfrag",level:2},{value:"Login",id:"login",level:2},{value:"Calling the <code>draw</code> method",id:"calling-the-draw-method",level:2},{value:"Real &quot;drawing&quot;",id:"real-drawing",level:2},{value:"Time of Day Interp Colors Scratch",id:"time-of-day-interp-colors-scratch",level:3},{value:"The Call to Draw",id:"the-call-to-draw",level:3},{value:"Draw node culling",id:"draw-node-culling",level:3},{value:"DMA List Generation",id:"dma-list-generation",level:3}],u={toc:h};function m(e){var t=e.components,a=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"porting-tfrag"},"Porting Tfrag"),(0,i.kt)("p",null,"Tfrag is the renderer for non-instanced background geometry. It's typically used for the floor and unique walls/level geometry. It has a level of detail system, and time of day lighting, optionaly transparancy and that's it. No other features."),(0,i.kt)("p",null,'The approach I took was to go slowly and understand the rendering code. I made two different "test" renderers that were slow but did things exactly the same way as in the PS2 version.  After this, I made a custom PC version called tfrag3. The key difference with tfrag3 is that there is an offline preprocessing step that reads the level data and outputs data in a good format for PC.'),(0,i.kt)("p",null,"Trying to understand the rendering code is annoying, but I think it was worth it in the end."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"you can often leave out huge chunks of code. I never touched ",(0,i.kt)("inlineCode",{parentName:"li"},"tfrag-near")," or most of the ",(0,i.kt)("inlineCode",{parentName:"li"},"tfrag")," VU program."),(0,i.kt)("li",{parentName:"ul"},"you can eventually figure out how move more to the GPU. For example, all clipping/scissoring and transformation is done on the GPU. This is faster (GPUs are good) and easier (OpenGL does it automatically if you set it up right, you don't have to do the math)."),(0,i.kt)("li",{parentName:"ul"},"you can rearrange things for better performance. Keeping the number of OpenGL draw calls down is probably the best thing we can do for performance.")),(0,i.kt)("p",null,'But in order to understand the renderer, I had to start with a slow "emulation-like" port.'),(0,i.kt)("p",null,"This document is divided into three parts:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"PS2 rendering (in Jak)."),(0,i.kt)("li",{parentName:"ol"},"Jak's ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable")," system"),(0,i.kt)("li",{parentName:"ol"},"Tfrag-specific details")),(0,i.kt)("h1",{id:"basics-of-ps2-rendering"},"Basics of PS2 Rendering"),(0,i.kt)("p",null,'The main idea of the Jak rendering system is that there are always two frames in progress at a time.  One frame is being "rendered" meaning triangles are being transformed and rasterized and the VRAM is being written to.  The other frame is being "calculated", meaning the game is building the list of instructions to draw the frame.  The "calculation" happens from GOAL code, mostly on the EE, and builds a single giant "DMA chain".  At the end of a frame, the engine takes the full DMA chain that was built, and sends it to the rendering hardware. The rendering process is all "automatic" - once it gets the list of data it will run for an entire frame and do all of the drawing.'),(0,i.kt)("p",null,"The EE user manual sections for DMAC, VPU (VU), and GIF are worth reading before trying to understand new rendering code."),(0,i.kt)("p",null,"Because the calculation and rendering happen simultaneously, the calculation cannot use the same hardware and memory as the rendering.  The following resources are used only by rendering:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"VU1"),(0,i.kt)("li",{parentName:"ul"},"VIF1"),(0,i.kt)("li",{parentName:"ul"},"GIF"),(0,i.kt)("li",{parentName:"ul"},"GS")),(0,i.kt)("p",null,"The following resources are used only by calculation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"VU0-macro mode (",(0,i.kt)("inlineCode",{parentName:"li"},"vf")," register on EE and ",(0,i.kt)("inlineCode",{parentName:"li"},"vadd")," like instructions)"),(0,i.kt)("li",{parentName:"ul"},"VU0-micro mode"),(0,i.kt)("li",{parentName:"ul"},"VIF0"),(0,i.kt)("li",{parentName:"ul"},"The scratchpad")),(0,i.kt)("p",null,"The following resources are shared:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DMA controller. It can handle multiple transfers to different places at the same time, and there are no shared destinations, so there's no issue here.  Rendering uses only to VIF1. Calculation uses to VIF0, to scratchpad, and from scratchpad."),(0,i.kt)("li",{parentName:"ul"},'The "global" DMA buffer. The calculation process fills this buffer and the rendering reads from it. There are two copies of this buffer and the engine will swap them automatically at the end of the frame. So one copy is always being filled while the other is being read and the graphics code mostly doesn\'t worry about this.'),(0,i.kt)("li",{parentName:"ul"},"DMA data inside of level data. The DMA list may include chunks of data that's part of the level data. In practice there's not much to be aware of here - the rendering process just reads this data. ")),(0,i.kt)("h2",{id:"dma"},"DMA"),(0,i.kt)("p",null,'The whole rendering system is driven by DMA. The DMA controller can copy data from main memory to different peripherals. If the destination is "busy", it will wait. So it doesn\'t just blindly dump data into things as fast as it can - it only sends data if the destination is ready to accept it. The DMA controller is controlled by "DMA tags". These contain a command like "transfer X bytes of data from address Y, then move on to the DMA tag at address Z". This allows the game to build up really complicated linked-lists of data to send.'),(0,i.kt)("p",null,"The DMA list built for rendering is divided into buckets. See ",(0,i.kt)("inlineCode",{parentName:"p"},"dma-h.gc")," for the bucket names. Individual renderers add data to buckets, and then the buckets are linked together in the order they are listed in that enum. Code like ",(0,i.kt)("inlineCode",{parentName:"p"},"tfrag")," won't start DMA to VIF1 or deal with linking buckets - that is handled by the game engine."),(0,i.kt)("p",null,"However, code like ",(0,i.kt)("inlineCode",{parentName:"p"},"tfrag"),' may just set up its own transfers to/from SPR and VIF0 - these are free-to-use during the "calculation" step.'),(0,i.kt)("h2",{id:"the-vif"},"The VIF"),(0,i.kt)("p",null,'The VIF is "vector unit interface". There\'s one for VU0 and VU1 and they are (as far as I know) identical. The rendering DMA list is sent directly to VIF1. There are also "tags" that control the VIF. The general types of tags are:'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'"take the following N bytes of data and copy it to VU data memory" (possibly with some fancy "unpacking" operation to move stuff around)'),(0,i.kt)("li",{parentName:"ul"},'"take the following N bytes of data and copy it to VU program memory" - to upload a new VU program'),(0,i.kt)("li",{parentName:"ul"},'"run a VU program starting at this address in VU program memory"'),(0,i.kt)("li",{parentName:"ul"},'"send this data ',(0,i.kt)("strong",{parentName:"li"},"direct"),'ly to the GIF" This is called a "direct" transfer. It\'s typically used to set things up on the GS that will be constant for one specific renderer.')),(0,i.kt)("p",null,"I haven't seen VIF0 really used much. The pattern for VIF1 is usually:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"upload program"),(0,i.kt)("li",{parentName:"ol"},"upload some constants"),(0,i.kt)("li",{parentName:"ol"},"upload some model data"),(0,i.kt)("li",{parentName:"ol"},"run program"),(0,i.kt)("li",{parentName:"ol"},"repeat steps 3 and 4 many times")),(0,i.kt)("h2",{id:"vu-programs"},"VU programs"),(0,i.kt)("p",null,"The VU programs are usually responsible for transforming vertices with the camera matrix, clipping, lighting calculations, etc. The output of a VU program is GIF packets containing the actual drawing information (transformed vertices, drawing settings, etc)."),(0,i.kt)("p",null,"The usual pattern is that the VU program will build up a GIF packet, then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"XGKICK")," instruction with the address of the start of the packet. This will start transferring the packet directly to the GIF. The transfer happens in the background. The transfer will only be completed once all triangles are drawn - there's no buffer on the GIF/GS. A single packet can be pretty big and have many triangles."),(0,i.kt)("p",null,"For the tfrag1/tfrag2 renderers, I ported up to this part. Then, I sent the ",(0,i.kt)("inlineCode",{parentName:"p"},"xgkick")," data to the ",(0,i.kt)("inlineCode",{parentName:"p"},"DirectRenderer")," which can handle this format of data. It is not super fast, but it's nice for debugging. Being able to inspect this was helpful to understand how it works."),(0,i.kt)("h2",{id:"vu-buffer-hell"},"VU buffer hell"),(0,i.kt)("p",null,"Typically the VU programs have 4 buffers. There is a buffer for input and output data, and both are double buffered. This allows you to be uploading new data with DMA, transforming vertices, and sending data to the GIF all at the same time. "),(0,i.kt)("p",null,"All 4 buffers are in use at the same time."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Untransformed Data being uploaded from the DMA list to VU data. This happens automatically by DMA."),(0,i.kt)("li",{parentName:"ol"},"Untransformed Data being transformed by the VU1 program."),(0,i.kt)("li",{parentName:"ol"},"A GIF packet being built from the output of the transformation. This is written by the VU1 program."),(0,i.kt)("li",{parentName:"ol"},"A GIF packet currently being ",(0,i.kt)("inlineCode",{parentName:"li"},"XGKICK"),"ed.")),(0,i.kt)("p",null,"Once 1 is full and 2 is totally used, these buffers are swapped. The same thing happens for 3 and 4.\nIn some renderers, these swaps are always done at the same time. For example ",(0,i.kt)("inlineCode",{parentName:"p"},"sprite"),". This tends to use the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"xitop")," instructions for managing double buffering."),(0,i.kt)("p",null,"In other renderers, the buffer swaps can happen at different times. This leads to awful code where you have 4 different versions of the same renderer for all possible combinations of which buffers are input/output. Storing the address of the input/output buffer in a variable can lead to extra instructions inside the transformation loops, which will significantly slow down."),(0,i.kt)("h2",{id:"gif"},"GIF"),(0,i.kt)("p",null,"The GIF can receive commands like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'"set the alpha blending mode to X"'),(0,i.kt)("li",{parentName:"ul"},'"use texture located at VRAM address Y"'),(0,i.kt)("li",{parentName:"ul"},'"draw a triangle"')),(0,i.kt)("p",null,"It can't do any transformation or lighting calculations."),(0,i.kt)("h1",{id:"jak-drawable-system"},"Jak ",(0,i.kt)("inlineCode",{parentName:"h1"},"drawable")," system"),(0,i.kt)("p",null,"There is a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable"),' system that\'s used to store things that can be "drawn". It uses a tree structure. So you can do something like'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(draw some-level)\n")),(0,i.kt)("p",null,"and it will recursively go through the entire level's tree of drawables and draw everything.  Note that there are a lot of tricks/hacks so not every ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable")," supports ",(0,i.kt)("inlineCode",{parentName:"p"},"draw")," and some code may defer some ",(0,i.kt)("inlineCode",{parentName:"p"},"draw"),"s until later."),(0,i.kt)("p",null,"The lowest-level drawable for tfrag is ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),". It makes sense to split up the level into \"fragments\" because the entire level is way too big to fit in the VU memory. Most of the time, you can't see every triangle in the level, so it makes sense to skip uploading the fragments that you know can't be seen.\nThere are thousands of these fragments. They tend to be ~ a few kB and each contains a chunk of data to upload to the VUs.  Note that ",(0,i.kt)("inlineCode",{parentName:"p"},"draw")," is not called directly on ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),", despite the fact that they are ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable"),"s (more details later).  The ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment")," is just a reference to some DMA data."),(0,i.kt)("h2",{id:"drawables-for-tfrag"},"Drawables for Tfrag"),(0,i.kt)("p",null,"The top-level drawable type for an entire level is ",(0,i.kt)("inlineCode",{parentName:"p"},"bsp-header"),". This is the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"-vis")," file of the level's DGO, and has all the graphics data (not including textures). It is also a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable"),"."),(0,i.kt)("p",null,"Within ",(0,i.kt)("inlineCode",{parentName:"p"},"bsp-header")," is a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree-array"),". As the name implies, this contains an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree"),". Usually there are 5-10 of these in a level. There will be a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree")," for each renderer. Or possibly a few per renderer, if that renderer supports different modes.  For example there's one for tfrag, one for transparent tfrag, one for tie, etc."),(0,i.kt)("p",null,"You can just check the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree")," to see if it's for tfrag/tie etc. The tfrag types are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-tfrag")," (parent of the rest)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-trans-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-dirt-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-ice-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-lowres-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-lowres-trans-tfrag"))),(0,i.kt)("p",null,'Each "tree" contains a bunch of ',(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s and a time of day color palette.  But they are stored in a really weird way. There is a bounding volume hierarchy of ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s. This is just a tree-like structure where each node stores a sphere, and all the node's children fit inside of that sphere. The nodes at each depth are stored in an array. The layout of this tree is designed to let them use some crazy assembly SIMD 8-at-a-time traversal of the tree, with minimal pointer-chasing and good memory access patterns."),(0,i.kt)("p",null,"Each tree has an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array"),"s, storing all the nodes at a given depth. The last ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array")," is actually a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array-frag"),", which is a wrapper around an inline array of ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s."),(0,i.kt)("p",null,"The other arrays are used to store tree nodes to organize these ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s.  Each node in the tree contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"bsphere"),". All tfrags below the node fit into this sphere."),(0,i.kt)("p",null,"The second to last array (if it exists) is a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array-node"),". This contains an inline array of ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node"),". Each ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node")," is the parent of between 1 and 8 ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s. They store a reference to the first child ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment")," and a child count, and the children are just the ones that come after the first ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment")," in memory."),(0,i.kt)("p",null,"The third to last array (if it exists) is also a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array-node"),", containing an inline array of ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node"),". Each ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node")," is the parent of between 1 and 8 ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node"),"s from the array mentioned above.  They store a reference to the first child ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node")," and a child count, and the children are stored consecutively."),(0,i.kt)("p",null,"This pattern continues until you get a ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-inline-array-node")," with 8 or fewer nodes at the top."),(0,i.kt)("p",null,"All the ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s have ID numbers. These are used for the occlusion culling system. The visibility numbering is shared with all the other ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree"),"s in the ",(0,i.kt)("inlineCode",{parentName:"p"},"bsp-header"),". The indices are given out consecutively, starting from the roots. Between depths, they are aligned to 32 elements, so there are some unused ids.  These IDs are the index of the bit in the visibility string."),(0,i.kt)("p",null,"With that out of the way, we can now go through the tfrag renderer"),(0,i.kt)("h1",{id:"tfrag"},"Tfrag"),(0,i.kt)("p",null,"The rough process for rendering is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'"login" the data'),(0,i.kt)("li",{parentName:"ul"},'do "drawing" as part of the ',(0,i.kt)("inlineCode",{parentName:"li"},"drawable")," system (on EE)"),(0,i.kt)("li",{parentName:"ul"},'do the real "draw"'),(0,i.kt)("li",{parentName:"ul"},"do culling"),(0,i.kt)("li",{parentName:"ul"},"compute time of day colors (or other precomputation)"),(0,i.kt)("li",{parentName:"ul"},"generate DMA lists"),(0,i.kt)("li",{parentName:"ul"},"unpack data to VU memory"),(0,i.kt)("li",{parentName:"ul"},"transform vertices"),(0,i.kt)("li",{parentName:"ul"},"clip"),(0,i.kt)("li",{parentName:"ul"},"build gs packets"),(0,i.kt)("li",{parentName:"ul"},"XGKICK")),(0,i.kt)("p",null,"I expect that most other renderers will be pretty similar."),(0,i.kt)("h2",{id:"login"},"Login"),(0,i.kt)("p",null,"The tfrag data needs to be initialized before it can be used. You only have to do this once. This is called ",(0,i.kt)("inlineCode",{parentName:"p"},"login"),", and it's a method of all ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable"),"s. The level loader will call the ",(0,i.kt)("inlineCode",{parentName:"p"},"login")," method of many things as part of the level load.  For ",(0,i.kt)("inlineCode",{parentName:"p"},"tfrag"),", all I had to do was decompile the ",(0,i.kt)("inlineCode",{parentName:"p"},"login")," methods, and it worked and I could completely ignore this until tfrag3."),(0,i.kt)("p",null,"It's possible to just call ",(0,i.kt)("inlineCode",{parentName:"p"},"login")," on an entire level, but this probably takes too long, so the level loader will cleverly split it up over multiple frames."),(0,i.kt)("p",null,"It is from:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"level-update")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"load-continue")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"level-update-after-load")),(0,i.kt)("li",{parentName:"ul"},"various calls to ",(0,i.kt)("inlineCode",{parentName:"li"},"login"),".")),(0,i.kt)("p",null,"In the end, the only thing the ",(0,i.kt)("inlineCode",{parentName:"p"},"login")," does for tfrag is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(adgif-shader-login-no-remap (-> obj shader i))\n")),(0,i.kt)("p",null,'for all the "shaders" in all the tfrags.  A "shader" is an ',(0,i.kt)("inlineCode",{parentName:"p"},"adgif-shader"),", which is just some settings for the GS that tells it drawing modes, like which texture to use, blending modes, etc. The ",(0,i.kt)("inlineCode",{parentName:"p"},"tfrag")," VU1 code will send these to the GIF as needed when drawing. A ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment")," can have multiple shaders. There is a different shader per texture."),(0,i.kt)("p",null,'The actual "shader" object is just 5x quadwords that contain "adress + data" format data. The address tells the GIF which parameter to change and the "data" has the value of the parameter. Some of them are not set properly in the level data, and the ',(0,i.kt)("inlineCode",{parentName:"p"},"adgif-shader-login-no-remap")," function updates them. For tfrag, the 5 addresses are always the same:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TEST_1"),": this sets the alpha and z test settings. This is set properly in the level data and ",(0,i.kt)("inlineCode",{parentName:"li"},"login")," doesn't touch it."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TEX0_1"),": this has some texture parameters. This is 0 in the level data and is modified by ",(0,i.kt)("inlineCode",{parentName:"li"},"login"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TEX1_1"),": this has more texture parameters. In the level data this is has ",(0,i.kt)("inlineCode",{parentName:"li"},"0x120")," as the value and the address is set to the texture ID of the texture. During ",(0,i.kt)("inlineCode",{parentName:"li"},"login"),", the texture ID is looked up in the texture pool and ",(0,i.kt)("inlineCode",{parentName:"li"},"TEX0_1"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"TEX1_1")," are set to point to the right VRAM address and have the right settings to use the texture."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MIPTBP1_1"),": is mipmap settings. I ignore these because we do our own mipmapping."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"CLAMP_1"),": this has texture clamp settings. This is set properly in the level data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ALPHA_1"),": this has alpha blend settings. This is set properly in the level data.")),(0,i.kt)("h2",{id:"calling-the-draw-method"},"Calling the ",(0,i.kt)("inlineCode",{parentName:"h2"},"draw")," method"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment")," at least pretends to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable")," system, and the drawing is initiated by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"draw")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"drawable-tree-tfrag"),". Getting this to actually be called took some digging - it uses some functions in later files that we haven't completed yet."),(0,i.kt)("p",null,"When the level is loaded, the ",(0,i.kt)("inlineCode",{parentName:"p"},"bsp-header")," is added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"*background-draw-engine*")," by the level loader. The path to calling draw is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In ",(0,i.kt)("inlineCode",{parentName:"li"},"main.gc"),", there is a ",(0,i.kt)("inlineCode",{parentName:"li"},"display-loop"),". This has a while loop that runs once per frame and runs many systems."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"display-loop")," calls ",(0,i.kt)("inlineCode",{parentName:"li"},"*draw-hook*")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"*draw-hook*")," variable is set to ",(0,i.kt)("inlineCode",{parentName:"li"},"main-draw-hook")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"main-draw-hook")," calls ",(0,i.kt)("inlineCode",{parentName:"li"},"real-main-draw-hook")),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"real-main-draw-hook")," calls ",(0,i.kt)("inlineCode",{parentName:"li"},"(execute-connections *background-draw-engine*")),(0,i.kt)("li",{parentName:"ul"},'This "engine" calls the ',(0,i.kt)("inlineCode",{parentName:"li"},"add-bsp-drawable")," function on the ",(0,i.kt)("inlineCode",{parentName:"li"},"bsp-header")," for each loaded level."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," method of ",(0,i.kt)("inlineCode",{parentName:"li"},"bsp-header")," sets up some stuff on the scratchpad and some ",(0,i.kt)("inlineCode",{parentName:"li"},"vf")," registers."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," method of ",(0,i.kt)("inlineCode",{parentName:"li"},"bsp-header")," calls ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," on the ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-array")," (defined in parent class ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-group"),")"),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," method of ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-group")," checks if the level is visible, and if so calls ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," on each tree."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"draw")," method of ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-tfrag")," simply adds the tree to a list of trees in ",(0,i.kt)("inlineCode",{parentName:"li"},"*background-work*"),".")),(0,i.kt)("h2",{id:"real-drawing"},'Real "drawing"'),(0,i.kt)("p",null,"Later on, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"real-main-draw-hook"),", there is a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"finish-background"),"."),(0,i.kt)("p",null,"There's some stuff at the top of this function that's only used for the separate shrubbery renderer. It sets up some VU0 programs. I noticed that the stuff before tfrag drawing would overwrite this VU0 stuff so I ignored it for now."),(0,i.kt)("p",null,"The first thing that happens before any tfrag drawing is setting the ",(0,i.kt)("inlineCode",{parentName:"p"},"vf")," registers to store the ",(0,i.kt)("inlineCode",{parentName:"p"},"math-camera")," values. In OpenGOAL, the ",(0,i.kt)("inlineCode",{parentName:"p"},"vf")," registers aren't saved between functions, so I had to manually use the ",(0,i.kt)("inlineCode",{parentName:"p"},"with-vf")," macro with the ",(0,i.kt)("inlineCode",{parentName:"p"},":rw 'write")," flag to save these:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"}," (let ((v1-48 *math-camera*))\n        (with-vf (vf16 vf17 vf18 vf19 vf20 vf21 vf22 vf23 vf24 vf25 vf26 vf27 vf28 vf29 vf30 vf31)\n                 :rw 'write\n                 (.lvf vf16 (&-> v1-48 plane 0 quad))\n                 (.lvf vf17 (&-> v1-48 plane 1 quad))\n                 ;; ...\n")),(0,i.kt)("p",null,"these will later be used in part of the drawing function. The ",(0,i.kt)("inlineCode",{parentName:"p"},":rw 'write")," flag will save these to a structure where we can read them later."),(0,i.kt)("p",null,"Then, for each tree:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"(upload-vis-bits s1-0 gp-1 a2-4)\n")),(0,i.kt)("p",null,"this uploads the visibility data to the scratchpad. The visibility data is stored at the end of the 16 kB scratchpad. The drawable with ID of ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," can look at the ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"-th bit of this data to determine if it is visible.  The visibility IDs are per level, and the drawing order of the ",(0,i.kt)("inlineCode",{parentName:"p"},"tfrag")," will alternate between levels, so they upload this for each tree to draw.  It seems like you could skip this after the first upload if you detect that you're drawing multiple trees in the same level.  They do it for TIE and not TFRAG and don't know why. The visibility data is based on the position of the camera. Currently this doesn't work so I modified it to upload all 1's."),(0,i.kt)("p",null,"The modification to the code to use the scratchpad in OpenGOAL is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"  ;;(spad-vis (the-as (pointer uint128) (+ #x38b0 #x70000000)))\n  (spad-vis (scratchpad-ptr uint128 :offset VISIBLE_LIST_SCRATCHPAD))\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"0x38b0")," offset is just something we've noticed over time as being the location of the visible list, so there's a constant I made for it. (TODO: I think it's also ",(0,i.kt)("inlineCode",{parentName:"p"},"terrain-context work background vis-list"),")"),(0,i.kt)("p",null,"The hack for visibility is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},";; TODO this is a hack.\n(quad-copy! (-> arg0 vis-bits) (-> arg2 all-visible-list) (/ (+ (-> arg2 visible-list-length) 15) 16))\n")),(0,i.kt)("p",null,"which actually modifies the level to say that everything is visbile. The ",(0,i.kt)("inlineCode",{parentName:"p"},"all-visible-list")," is just a list which has ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," for every drawable that actually exists (I think, need to configm). There are some skipped ID's."),(0,i.kt)("p",null,"The next part of drawing is:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"                  (when (not (or (zero? s0-0) (= s4-1 s0-0)))\n                    (flush-cache 0)\n                    (time-of-day-interp-colors-scratch (scratchpad-ptr rgba :offset 6160) s0-0 (-> s1-0 mood))\n                    ;; remember the previous colors\n                    (set! s4-1 s0-0)\n")),(0,i.kt)("p",null,"where ",(0,i.kt)("inlineCode",{parentName:"p"},"s0-0")," is the ",(0,i.kt)("inlineCode",{parentName:"p"},"time-of-day-pal")," for the tfrag tree. It will skip interpolation if it is the same color palette that was just interpolated."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"time-of-day-interp-colors-scratch")," function uploads the colors from ",(0,i.kt)("inlineCode",{parentName:"p"},"s0-0")," to the scratchpad at offset ",(0,i.kt)("inlineCode",{parentName:"p"},"6160"),". It computes the correct colors for the time-of-day/lighting settings in the the level ",(0,i.kt)("inlineCode",{parentName:"p"},"s1-0"),"'s mood.  This function is pretty complicated, so I used MIPS2C."),(0,i.kt)("h3",{id:"time-of-day-interp-colors-scratch"},"Time of Day Interp Colors Scratch"),(0,i.kt)("p",null,"The very first attempts for TFRAG just skipped this function because it wasn't needed to debug the basic drawing functions. I manually set the lighting to ",(0,i.kt)("inlineCode",{parentName:"p"},"0.5")," for all colors and ",(0,i.kt)("inlineCode",{parentName:"p"},"1.0")," for alpha. I suspected that this stored the colors in the scratchpad. I assumed it would be fine if these garbage for a first test."),(0,i.kt)("p",null,"I noticed that this function does a few tricky things. It uses the scratchpad and it uses DMA.  I know it uses DMA because I saw:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"  c->lui(t0, 4096);                                 // lui t0, 4096\n  // some stuff in between...\n  c->ori(a1, t0, 54272);                            // ori a1, t0, 54272 = (0x1000D400) SPR TO\n")),(0,i.kt)("p",null,"and this ",(0,i.kt)("inlineCode",{parentName:"p"},"0x1000D4000")," is the address of the DMA control register for transferring to the scratchpad.  The scratchpad here is just used as a faster memory. And eventually the draw code will read the result from the scratchpad."),(0,i.kt)("p",null,'They really like this pattern of doing work on the scratchpad while DMA is running in the background, copying things to/from the scratchpad. In this case, they upload the palette to the scratchpad in chunks. As those uploads are running, they do math on the previous upload to blend together the colors for the chosen time of day.  To get optimal performance, they often count how many times they finish before the DMA is ready. When this happens, they increment a "wait" variable.'),(0,i.kt)("p",null,"I modified scratchpad access like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"  c->lui(v1, 28672);                                // lui v1, 28672      0x7000\n  // stuff in between skipped...\n  //c->ori(v1, v1, 2064);                           // ori v1, v1, 2064 SPAD mods\n  get_fake_spad_addr(v1, cache.fake_scratchpad_data, 2064, c);\n")),(0,i.kt)("p",null,"the original code would set the address to an offset of 2064 in the scratchpad."),(0,i.kt)("p",null,"The first thing they do is wait for any in-progress DMA transfers to finish:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"  block_1:\n  c->lw(t5, 0, a1);                                 // lw t5, 0(a1)\n  // nop                                            // sll r0, r0, 0\n  // nop                                            // sll r0, r0, 0\n  // nop                                            // sll r0, r0, 0\n  c->andi(t5, t5, 256);                             // andi t5, t5, 256\n  // nop                                            // sll r0, r0, 0\n  bc = c->sgpr64(t5) != 0;                          // bne t5, r0, L62\n  // nop                                            // sll r0, r0, 0\n  if (bc) {goto block_1;}                           // branch non-likely\n")),(0,i.kt)("p",null,"which is reading and checking the DMA register in a loop. We can just get rid of this - we make all DMA instant."),(0,i.kt)("p",null,"I also modified the code that starts the transfer to just do a memcpy from the fake scratchpad. See the EE manual for details on what these registers mean. The ",(0,i.kt)("inlineCode",{parentName:"p"},"a1")," register points to the control register for SPR TO DMA."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"  {\n    // c->sw(t4, 16, a1);                                // sw t4, 16(a1)\n    u32 madr = c->sgpr64(t4);\n    c->daddiu(t3, t3, -32);                           // daddiu t3, t3, -32\n    // c->sw(v1, 128, a1);                               // sw v1, 128(a1)\n    u32 sadr = c->sgpr64(v1);\n    c->addiu(t5, r0, 64);                             // addiu t5, r0, 64\n    //c->sw(t5, 32, a1);                                // sw t5, 32(a1)\n    u32 qwc = c->sgpr64(t5);\n    c->addiu(t5, r0, 256);                            // addiu t5, r0, 256\n    // c->sw(t5, 0, a1);                                 // sw t5, 0(a1)\n    spad_to_dma(cache.fake_scratchpad_data, madr, sadr, qwc);\n    c->daddiu(t4, t4, 1024);                          // daddiu t4, t4, 1024\n  }\n")),(0,i.kt)("p",null,"This data is double buffered. One buffer is being filled from DMA while another is being processed. To swap buffers, they often use ",(0,i.kt)("inlineCode",{parentName:"p"},"xor")," to toggle a bit. But this trick only works if our buffer has the same alignment as theirs up to the bit being toggled (otherwise their first ",(0,i.kt)("inlineCode",{parentName:"p"},"xor")," might toggle a 0 to a 1, advancing the address, where ours does the opposite)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"c->xori(v1, v1, 1024);                            // xori v1, v1, 1024\n")),(0,i.kt)("p",null,"The actual processing is an annoying pipelined loop. The palette stores groups of 8 colors. The time of day system computes 8 weights, passed to this function. Each of the 8 colors is multiplied by the weight and added. This process is repeated for each group. There are usually 1024 or 2048 groups.  The tfragments are lit by indexing into these groups.  One important detail is that the r/g/b/a values are saturated so they don't overflow."),(0,i.kt)("p",null,"This part works using the MIPS2C function in the first tfrag renderers. In the third one, it was annoying to get this data to the C++ renderer, so I just recomputed it in C++. This also lets us manually override the time of day values for fun. The code is much simpler:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"void Tfrag3::interp_time_of_day_slow(const float weights[8],\n                                     const std::vector<tfrag3::TimeOfDayColor>& in,\n                                     math::Vector<u8, 4>* out) {\n  for (size_t color = 0; color < in.size(); color++) {\n    math::Vector4f result = math::Vector4f::zero();\n    for (int component = 0; component < 8; component++) {\n      result += in[color].rgba[component].cast<float>() * weights[component];\n    }\n    result[0] = std::min(result[0], 255.f);\n    result[1] = std::min(result[1], 255.f);\n    result[2] = std::min(result[2], 255.f);\n    result[3] = std::min(result[3], 128.f);  // note: different for alpha!\n    out[color] = result.cast<u8>();\n  }\n}\n")),(0,i.kt)("h3",{id:"the-call-to-draw"},"The Call to Draw"),(0,i.kt)("p",null,"There was another scratchpad use to patch up here. They often treat the scratchpad as a ",(0,i.kt)("inlineCode",{parentName:"p"},"terrain-context"),". There are quite a few overlays here so sometimes you have to do some manual searching to figure it out."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},"      (set! (-> (scratchpad-object terrain-context) bsp lev-index) (-> s1-0 index))\n        \n      (set! (-> *tfrag-work* min-dist z) 4095996000.0)\n      ;; draw!\n      (draw-drawable-tree-tfrag s2-0 s1-0)\n      )\n      ;; remember closest.\n      (set! (-> *level* level (-> (scratchpad-object terrain-context) bsp lev-index) closest-object 0)\n            (-> *tfrag-work* min-dist z)\n            )\n      )\n")),(0,i.kt)("p",null,"the remembering closest is used for figuring out which mip levels of texture need uploading."),(0,i.kt)("h3",{id:"draw-node-culling"},"Draw node culling"),(0,i.kt)("p",null,"This is a part that I left out. I still haven't done it. But I suspect it looks at the position of the camera (stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"vf"),' regs from earlier) and modifies the visibility data. I think it uses a "sphere in view frustum" check and traverses the tree of ',(0,i.kt)("inlineCode",{parentName:"p"},"draw-node"),"s. I think it only culls the ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-node"),"s and not actually the ",(0,i.kt)("inlineCode",{parentName:"p"},"tfragment"),"s, and it modifies the visibility data in place.  It only culls the range of nodes that correspond to the tree we're drawing."),(0,i.kt)("p",null,"Later, on tfrag3, I did the culling in C++. (More on this later - it's done in a tricky way so that you can efficiently build a list of only the visible things to send to the GPU)."),(0,i.kt)("h3",{id:"dma-list-generation"},"DMA List Generation"),(0,i.kt)("p",null,"The objective of the draw function is to generate a DMA list. This gets added to the entire DMA list for the frame and gets sent to the VIF. The DMA data is a list of instructions like:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"upload this data to the VU memory"),(0,i.kt)("li",{parentName:"ul"},"run this VU program"),(0,i.kt)("li",{parentName:"ul"},"change various settings related to the VU data upload.")),(0,i.kt)("p",null,"The pattern used by tfrag is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Call ",(0,i.kt)("inlineCode",{parentName:"li"},"tfrag-init-buffer")," once. This is unoptimized code that just sets things up."),(0,i.kt)("li",{parentName:"ul"},"Call ",(0,i.kt)("inlineCode",{parentName:"li"},"draw-inline-array-tfrag"),". This adds DMA per tfragment. It is super optimized."),(0,i.kt)("li",{parentName:"ul"},"Call ",(0,i.kt)("inlineCode",{parentName:"li"},"tfrag-end-buffer"),". This is unoptimized code that ends the DMA list for tfrag")))}m.isMDXComponent=!0}}]);