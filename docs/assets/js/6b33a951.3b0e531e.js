"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[528],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=l(n),h=o,m=u["".concat(p,".").concat(h)]||u[h]||d[h]||r;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6345:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return d}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],i={sidebar_position:8},p="Process and State",l={unversionedId:"reference/process_and_state",id:"reference/process_and_state",title:"Process and State",description:"What is a process?",source:"@site/documentation/reference/process_and_state.md",sourceDirName:"reference",slug:"/reference/process_and_state",permalink:"/docs/reference/process_and_state",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/reference/process_and_state.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"docsSidebar",previous:{title:"Object File Formats",permalink:"/docs/reference/object_file_formats"},next:{title:"States in the Decompiler",permalink:"/docs/reference/decompiler_states"}},c={},d=[{value:"What is a <code>process</code>?",id:"what-is-a-process",level:2},{value:"What does a process store?",id:"what-does-a-process-store",level:2},{value:"How is a process run?",id:"how-is-a-process-run",level:2},{value:"How do I create a process?",id:"how-do-i-create-a-process",level:2},{value:"How do I make a process do something?",id:"how-do-i-make-a-process-do-something",level:2},{value:"Some notes on &quot;the current process&quot;",id:"some-notes-on-the-current-process",level:2},{value:"Some notes on <code>process-deactivate</code>",id:"some-notes-on-process-deactivate",level:2},{value:"Some notes on <code>go</code>.",id:"some-notes-on-go",level:2}],u={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"process-and-state"},"Process and State"),(0,r.kt)("h2",{id:"what-is-a-process"},"What is a ",(0,r.kt)("inlineCode",{parentName:"h2"},"process"),"?"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," object stores the state of some in-game object and tells the GOAL kernel how to update this object on each frame."),(0,r.kt)("p",null,"For example, there is a process for Jak, a process for each orb, and a process for each enemy. There is also a process for the time-of-day system and the pause menu."),(0,r.kt)("p",null,"In most cases, ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," is used as a parent type for a specific game object.  For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"money")," (orb) is a child of ",(0,r.kt)("inlineCode",{parentName:"p"},"process-drawable"),", which is a child of ",(0,r.kt)("inlineCode",{parentName:"p"},"process"),".  A ",(0,r.kt)("inlineCode",{parentName:"p"},"process-drawable")," is a process that can be drawn as part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"drawable")," system."),(0,r.kt)("h2",{id:"what-does-a-process-store"},"What does a process store?"),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"process"),' stores a small amount (112 bytes) of metadata, fields from child classes, some unknown stuff, and a process heap.  The process heap will automatically contain the "main thread" of the process, which contains space to back up the stack and registers when the thread suspends.  You may also allocate objects on the process heap yourself (not supported in OpenGOAL yet).'),(0,r.kt)("h2",{id:"how-is-a-process-run"},"How is a process run?"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," class is a child of ",(0,r.kt)("inlineCode",{parentName:"p"},"process-tree"),", which is a left-child right-sibling binary tree.  On each frame, the kernel iterates through the ",(0,r.kt)("inlineCode",{parentName:"p"},"*active-pool*")," and runs each process.  Each run consists of three steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Run the ",(0,r.kt)("inlineCode",{parentName:"li"},"trans-hook")," of the process in a temporary stack."),(0,r.kt)("li",{parentName:"ul"},"Resume the main thread of the process."),(0,r.kt)("li",{parentName:"ul"},"After the main thread suspends, run the ",(0,r.kt)("inlineCode",{parentName:"li"},"post-hook"),".")),(0,r.kt)("h2",{id:"how-do-i-create-a-process"},"How do I create a process?"),(0,r.kt)("p",null,"Setting up a process requires three steps:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Getting an actual process object"),(0,r.kt)("li",{parentName:"ul"},'"Activating" a process so it will be run by the kernel'),(0,r.kt)("li",{parentName:"ul"},"Setting up the code for the process to run")),(0,r.kt)("p",null,'There are a few "dead pools" which contain process objects that are not in use.  The ',(0,r.kt)("inlineCode",{parentName:"p"},"*4k-dead-pool*")," contains processes that are 4kb each.  There is also a dynamic pool called the ",(0,r.kt)("inlineCode",{parentName:"p"},"*nk-dead-pool*"),' that allows you to create dynamically sized processes. You must do all allocations during initialization with these processes because they automatically "shrink" their heap as small as possible.  Also, ',(0,r.kt)("inlineCode",{parentName:"p"},"*nk-dead-pool*")," processes will be relocated in memory as part of the process GC system, so you must make sure that all objects on the process heap support relocation, and you must use a ",(0,r.kt)("inlineCode",{parentName:"p"},"handle")," to safely refer to the process, not just a normal ",(0,r.kt)("inlineCode",{parentName:"p"},"process")," reference."),(0,r.kt)("p",null,"For example, to get a process:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"gc> (define *test-proc* (get-process *nk-dead-pool* process 1024))\n#<process process dead :state #f :stack -1904/1441188 :heap 0/1024 @ #x193454>\n")),(0,r.kt)("p",null,"This shows that:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The process name is ",(0,r.kt)("inlineCode",{parentName:"li"},"process")," (just a temporary name, until we activate)"),(0,r.kt)("li",{parentName:"ul"},"The status is ",(0,r.kt)("inlineCode",{parentName:"li"},"dead")),(0,r.kt)("li",{parentName:"ul"},"The process is not in a ",(0,r.kt)("inlineCode",{parentName:"li"},"state"),"."),(0,r.kt)("li",{parentName:"ul"},"The stack is bogus because we don't have a main thread yet."),(0,r.kt)("li",{parentName:"ul"},"We have used 0 out of 1024 bytes of our process heap.")),(0,r.kt)("p",null,"Next, we need to activate it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(activate *test-proc* *active-pool* 'hello *kernel-dram-stack*)\n")),(0,r.kt)("p",null,"This means:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We put it in the ",(0,r.kt)("inlineCode",{parentName:"li"},"*active-pool*"),". We could specify another process in the ",(0,r.kt)("inlineCode",{parentName:"li"},"*active-pool*")," if we wanted this to be a child process of an existing process."),(0,r.kt)("li",{parentName:"ul"},"Our name is ",(0,r.kt)("inlineCode",{parentName:"li"},"'hello"),"."),(0,r.kt)("li",{parentName:"ul"},"When we run code, it will run on the ",(0,r.kt)("inlineCode",{parentName:"li"},"*kernel-dram-stack*"),".")),(0,r.kt)("p",null,"Now, if we ",(0,r.kt)("inlineCode",{parentName:"p"},"(print *test-proc*)")," we will see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#<process hello ready :state #f :stack 0/256 :heap 384/1024 @ #x193454>\n")),(0,r.kt)("p",null,'Indicating that we are "ready" to be initialized, and that we now have a correctly set up main thread/stack.'),(0,r.kt)("p",null,"If we run ",(0,r.kt)("inlineCode",{parentName:"p"},"inspect"),", it will print out all objects on the process heap, including our main thread:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"        ----\n        [001934c4] cpu-thread\n            name: code\n            process: #<process hello ready :state #f :stack 0/256 :heap 384/1024 @ #x193454>\n            previous: #f\n            suspend-hook: #<compiled function @ #x1679c4>\n            resume-hook: #<compiled function @ #x167b24>\n            pc: #x0\n            sp: #x170b30\n            stack-top: #x170b30\n            stack-size: 256\n            rreg[7] @ #x1934e8\n            freg[8] @ #x193520\n            stack[0] @ #x193540\n        ----\n")),(0,r.kt)("p",null,"If we want a reference to this process, we must create a handle.  For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"gc> (process->handle *test-proc*)\n#<handle :process #<process hello ready :state #f :stack 0/256 :heap 384/1024 @ #x192fe4> :pid 2>\n")),(0,r.kt)("p",null,"this is now a safe reference to this process, even if it is relocated or deactivated."),(0,r.kt)("h2",{id:"how-do-i-make-a-process-do-something"},"How do I make a process do something?"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," system is used to control a process.  Each process can be in a ",(0,r.kt)("inlineCode",{parentName:"p"},"state"),", which specifies what functions should run.  To switch states in the current process, use ",(0,r.kt)("inlineCode",{parentName:"p"},"go"),"."),(0,r.kt)("p",null,"For example, we can create a simple test state like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'(defstate test-state (process)\n    :enter (lambda () (format #t "enter!~%"))\n    :exit (lambda () (format #t "exit!~%"))\n    :trans (lambda () (format #t "trans!~%"))\n    :post (lambda () (format #t "post!~%"))\n    :code (lambda ()\n            (dotimes (i 5)\n              (format #t "Code ~D~%" i)\n              (suspend)\n              )\n            (process-deactivate)\n            )\n    )\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," is the function to run in the main thread.  This code should ",(0,r.kt)("inlineCode",{parentName:"p"},"suspend")," itself, and the kernel will resume it after the suspend on each frame. Once the process is done, it can call ",(0,r.kt)("inlineCode",{parentName:"p"},"process-deactivate"),". This will cause it to exit the current state, immediately exit the ",(0,r.kt)("inlineCode",{parentName:"p"},"code"),", and clean up the process, returning it to the dead pool."),(0,r.kt)("p",null,"To switch the process to this state, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"run-now-in-process")," to switch to the test process and run the given code."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"(run-now-in-process *test-proc* (lambda () (go test-state)))\n")),(0,r.kt)("p",null,"And you will see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"enter!\ntrans!\nCode 0\npost!\n\ntrans!\nCode 1\npost!\n\ntrans!\nCode 2\npost!\n\ntrans!\nexit!\n")),(0,r.kt)("p",null,"Note 1: After deactivation, the handle is no longer valid as the process is dead and it will print like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#<handle :process #f :pid 2>\n")),(0,r.kt)("p",null,"Note 2: There is also a ",(0,r.kt)("inlineCode",{parentName:"p"},"run-next-time-in-process")," that sets up the process to run your initialization stub function as the ",(0,r.kt)("inlineCode",{parentName:"p"},"code")," on the next time the kernel iterates through the process tree."),(0,r.kt)("h2",{id:"some-notes-on-the-current-process"},'Some notes on "the current process"'),(0,r.kt)("p",null,"When the kernel runs a process, it sets ",(0,r.kt)("inlineCode",{parentName:"p"},"(-> *kernel-context* current-process)")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"pp"),' register to that process.  This process is called the "current kernel process".'),(0,r.kt)("p",null,'This process may then "run code in another process".  This can be done with ',(0,r.kt)("inlineCode",{parentName:"p"},"run-now-in-process"),", by deactivating another process, or using ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," on another process.  This changes ",(0,r.kt)("inlineCode",{parentName:"p"},"pp"),", but not the kernel context.  The process in ",(0,r.kt)("inlineCode",{parentName:"p"},"pp"),' is called the "current pp process".'),(0,r.kt)("p",null,"The value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"pp")," register determines the current process."),(0,r.kt)("h2",{id:"some-notes-on-process-deactivate"},"Some notes on ",(0,r.kt)("inlineCode",{parentName:"h2"},"process-deactivate")),(0,r.kt)("p",null,"To stop a process, you can do call the ",(0,r.kt)("inlineCode",{parentName:"p"},"deactivate")," method of that process.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"process-deactivate")," macro just does this for the current process."),(0,r.kt)("p",null,"This does the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set state to ",(0,r.kt)("inlineCode",{parentName:"li"},"dead-state"),"."),(0,r.kt)("li",{parentName:"ul"},"Calls ",(0,r.kt)("inlineCode",{parentName:"li"},"entity-deactivate-handler"),", if you have an entity"),(0,r.kt)("li",{parentName:"ul"},"Calls ",(0,r.kt)("inlineCode",{parentName:"li"},"exit")," of states"),(0,r.kt)("li",{parentName:"ul"},"Cleans up any pending ",(0,r.kt)("inlineCode",{parentName:"li"},"protect-frame")," (calling them with pp set for the process)"),(0,r.kt)("li",{parentName:"ul"},"Disconnects it from the ",(0,r.kt)("inlineCode",{parentName:"li"},"connection")," system"),(0,r.kt)("li",{parentName:"ul"},"Deactivates all children process"),(0,r.kt)("li",{parentName:"ul"},"Returns itself to the pool"),(0,r.kt)("li",{parentName:"ul"},"If you deactivated the process that the kernel-dispatcher started running, immediately bail out of the thread"),(0,r.kt)("li",{parentName:"ul"},"If you deactivated during a ",(0,r.kt)("inlineCode",{parentName:"li"},"run-now-in-process"),", immediately bail out of the initialization and return to caller of ",(0,r.kt)("inlineCode",{parentName:"li"},"run-now-in-process"),".")),(0,r.kt)("h2",{id:"some-notes-on-go"},"Some notes on ",(0,r.kt)("inlineCode",{parentName:"h2"},"go"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," macro is used to change the state of the current process."),(0,r.kt)("p",null,"If you use ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," when in ",(0,r.kt)("inlineCode",{parentName:"p"},"run-now-in-process"),", it will immediately return to the caller of ",(0,r.kt)("inlineCode",{parentName:"p"},"run-now-in-process"),", and the actual state change will happen on the next execution of the main thread of that process."),(0,r.kt)("p",null,"If you use ",(0,r.kt)("inlineCode",{parentName:"p"},"go-process")," on another process, the ",(0,r.kt)("inlineCode",{parentName:"p"},"go-process")," will return immediately and the state transition will happen on the next run of that process."),(0,r.kt)("p",null,"If you use ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," in the main thread, it will immediately transition states, run exits, enter, trans, and begin running the new state ",(0,r.kt)("inlineCode",{parentName:"p"},"code"),"."),(0,r.kt)("p",null,"If you use ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"trans")," it will set up the next run of the main thread, then abandon the current ",(0,r.kt)("inlineCode",{parentName:"p"},"trans"),".\nIf you use ",(0,r.kt)("inlineCode",{parentName:"p"},"go")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"post"),", it will set up the next run of the main thread to transition, but not abandon the current ",(0,r.kt)("inlineCode",{parentName:"p"},"post"),"."))}h.isMDXComponent=!0}}]);