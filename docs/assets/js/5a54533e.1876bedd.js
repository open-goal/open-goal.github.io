"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[59],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=i,c=m["".concat(s,".").concat(u)]||m[u]||h[u]||o;return n?a.createElement(c,r(r({ref:t},d),{},{components:n})):a.createElement(c,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},242:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return h}});var a=n(7462),i=n(3366),o=(n(7294),n(3905)),r=["components"],l={sidebar_position:2},s="OpenGOAL's Method System",p={unversionedId:"reference/method_system",id:"reference/method_system",title:"OpenGOAL's Method System",description:"OpenGOAL has a virtual method system. This means that child types can override parent methods.  The first argument to a method is always the object the method is being called on, except for new.",source:"@site/documentation/reference/method_system.md",sourceDirName:"reference",slug:"/reference/method_system",permalink:"/docs/reference/method_system",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/reference/method_system.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"OpenGOAL's Type System",permalink:"/docs/reference/type_system"},next:{title:"OpenGOAL Syntax & Examples",permalink:"/docs/reference/syntax"}},d={},h=[{value:"Special <code>_type_</code> Type",id:"special-_type_-type",level:2},{value:"Details on the Order of Overrides",id:"details-on-the-order-of-overrides",level:2},{value:"Built in Methods",id:"built-in-methods",level:2},{value:"<code>new</code>",id:"new",level:3},{value:"<code>delete</code>",id:"delete",level:3},{value:"<code>print</code>",id:"print",level:3},{value:"<code>inspect</code>",id:"inspect",level:3},{value:"<code>length</code>",id:"length",level:3},{value:"<code>asize-of</code>",id:"asize-of",level:3},{value:"<code>copy</code>",id:"copy",level:3},{value:"<code>relocate</code>",id:"relocate",level:3},{value:"<code>mem-usage</code>",id:"mem-usage",level:3}],m={toc:h};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"opengoals-method-system"},"OpenGOAL's Method System"),(0,o.kt)("p",null,"OpenGOAL has a virtual method system. This means that child types can override parent methods.  The first argument to a method is always the object the method is being called on, except for ",(0,o.kt)("inlineCode",{parentName:"p"},"new"),"."),(0,o.kt)("p",null,"All types have methods. Objects have access to all of their parents methods, and may override parent methods.  All types have these 9 methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"new")," - like a constructor, returns a new object.  It's not used in all cases, and on all types, and needs more documentation on when specifically it is used."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"delete")," - basically unused, but like a destructor.  Often calls ",(0,o.kt)("inlineCode",{parentName:"li"},"kfree"),", which does nothing."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"print")," - prints a short, one line representation of the object to the ",(0,o.kt)("inlineCode",{parentName:"li"},"PrintBuffer")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"inspect")," - prints a multi-line description of the object to the ",(0,o.kt)("inlineCode",{parentName:"li"},"PrintBuffer"),". Usually auto-generated by the compiler and prints out the name and value of each field."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"length")," - Returns a length if the type has something like a length (number of characters in string, etc). Otherwise returns 0. Usually returns the number of filled slots, instead of the total number of allocated slots, when there is possibly a difference."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"asize-of")," - Gets the size in memory of the entire object.  Usually this just looks this up from the appropriate ",(0,o.kt)("inlineCode",{parentName:"li"},"type"),", unless it's dynamically sized."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"copy")," - Create a copy of this object on the given heap. Not used very much?"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"relocate")," - Some GOAL objects will be moved in memory by the kernel as part of the compacting actor heap system. After being moved, the ",(0,o.kt)("inlineCode",{parentName:"li"},"relocate")," method will be called with the offset of the move, and the object should fix up any internal pointers which may point to the old location. It's also called on v2 objects loaded by the linker when they are first loaded into memory."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"memusage")," - Not understood yet, but probably returns how much memory in bytes the object uses. Not supported by all objects.")),(0,o.kt)("p",null,"Usually a method which overrides a parent method must have the same argument and return types.  The only exception is ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," methods, which can have different argument/return types from the parent.  (Dee the later section on ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_")," for another exception)"),(0,o.kt)("p",null,"The compiler's implementation for calling a method is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Is the type a basic?",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"If so, look up the type using runtime type information"),(0,o.kt)("li",{parentName:"ul"},"Get the method from the vtable"))),(0,o.kt)("li",{parentName:"ul"},"Is the type not a basic?",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Get the method from the vtable of the compile-time type"),(0,o.kt)("li",{parentName:"ul"},"Note that this process isn't very efficient - instead of directly linking to the slot in the vtable (one deref) it first looks up the ",(0,o.kt)("inlineCode",{parentName:"li"},"type")," by symbol, then the slot (two derefs). I have no idea why it's done this way.")))),(0,o.kt)("p",null,"In general, I suspect that the method system was modified after GOAL was first created. There is some evidence that types were once stored in the symbol table, but were removed because the symbol table became full.  This could explain some of the weirdness around method calls/definition rules, and the disaster ",(0,o.kt)("inlineCode",{parentName:"p"},"method-set!")," function."),(0,o.kt)("p",null,"All type definitions should also define all the methods, in the order they appear in the vtable.  I suspect GOAL had this as well because the method ordering otherwise seems random, and in some cases impossible to get right unless (at least) the number of methods was specified in the type declaration."),(0,o.kt)("h2",{id:"special-_type_-type"},"Special ",(0,o.kt)("inlineCode",{parentName:"h2"},"_type_")," Type"),(0,o.kt)("p",null,"The first argument of a method always contains the object that the method is being called on.  It also must have the type ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_"),", which will be substituted by the type system (at compile time) using the following rules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"At method definition: replace with the type that the method is being defined for."),(0,o.kt)("li",{parentName:"ul"},"At method call: replace with the compile-time type of the object the method is being called on.")),(0,o.kt)("p",null,"The type system is flexible with allowing you to use ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_")," in the method declaration in ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype"),", but not using ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_")," in the actual ",(0,o.kt)("inlineCode",{parentName:"p"},"defmethod"),"."),(0,o.kt)("p",null,"A method can have other arguments or a return value that's of type ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_"),'. This special "type" will be replaced ',(0,o.kt)("strong",{parentName:"p"},"at compile time")," with the type which is defining or calling the method.  No part of this exists at runtime.  It may seem weird, but there are two uses for this."),(0,o.kt)("p",null,"The first is to allow children to specialize methods and have their own child type as an argument type. For example, say you have a method ",(0,o.kt)("inlineCode",{parentName:"p"},"is-same-shape"),", which compares two objects and sees if they are the same shape. Suppose you first defined this for type ",(0,o.kt)("inlineCode",{parentName:"p"},"square")," with"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"(defmethod square is-same-shape ((obj1 square) (obj2 square))\n  (= (-> obj1 side-length) (-> obj2 side-length))\n )\n")),(0,o.kt)("p",null,"Then, if you created a child class of ",(0,o.kt)("inlineCode",{parentName:"p"},"square")," called ",(0,o.kt)("inlineCode",{parentName:"p"},"rectangle")," (this is a terrible way to use inheritance, but it's just an example), and overrode the ",(0,o.kt)("inlineCode",{parentName:"p"},"is-same-shape")," method, you would have to have arguments that are ",(0,o.kt)("inlineCode",{parentName:"p"},"square"),"s, which blocks you from accessing ",(0,o.kt)("inlineCode",{parentName:"p"},"rectangle"),"-specific fields.  The solution is to define the original method with type ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_")," for the first two arguments.  Then, the method defined for ",(0,o.kt)("inlineCode",{parentName:"p"},"rectangle")," also will have arguments of type ",(0,o.kt)("inlineCode",{parentName:"p"},"_type_"),", which will expand to ",(0,o.kt)("inlineCode",{parentName:"p"},"rectangle"),"."),(0,o.kt)("p",null,"The second use is for a return value.  For example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"inspect")," methods both return the object that is passed to them, which will always be the same type as the argument passed in.  If ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," was define as ",(0,o.kt)("inlineCode",{parentName:"p"},"(function object object)"),", then ",(0,o.kt)("inlineCode",{parentName:"p"},"(print my-square)")," would lose the information that the return object is a ",(0,o.kt)("inlineCode",{parentName:"p"},"square"),".  If ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," is a ",(0,o.kt)("inlineCode",{parentName:"p"},"(function _type_ _type_)"),", the type system will know that ",(0,o.kt)("inlineCode",{parentName:"p"},"(print my-square)")," will return a ",(0,o.kt)("inlineCode",{parentName:"p"},"square"),"."),(0,o.kt)("h2",{id:"details-on-the-order-of-overrides"},"Details on the Order of Overrides"),(0,o.kt)("p",null,"The order in which you ",(0,o.kt)("inlineCode",{parentName:"p"},"defmethod")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype")," matters."),(0,o.kt)("p",null,"When you ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype"),", you copy all methods from the parent. When you ",(0,o.kt)("inlineCode",{parentName:"p"},"defmethod"),", you always set a method in that type. You may also override methods in a child if: the child hasn't modified that method already, and if you are in a certain mode. This is a somewhat slow process that involves iterating over the entire symbol table and every type in the runtime, so I believe it was disabled when loading level code, and you just had to make sure to ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"defmethod")," in order."),(0,o.kt)("p",null,"Assume you have the type hierarchy where ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," is the parent of ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),", which is the parent of ",(0,o.kt)("inlineCode",{parentName:"p"},"c"),"."),(0,o.kt)("p",null,"If you first define the three types using ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype"),", then override a method from ",(0,o.kt)("inlineCode",{parentName:"p"},"a")," on ",(0,o.kt)("inlineCode",{parentName:"p"},"c"),", then override that same method on ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),", then ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," won't use the override from ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,o.kt)("p",null,"If you first define the three types using ",(0,o.kt)("inlineCode",{parentName:"p"},"deftype"),", then override a method on ",(0,o.kt)("inlineCode",{parentName:"p"},"b"),", it will ",(0,o.kt)("em",{parentName:"p"},"sometimes")," do the override on ",(0,o.kt)("inlineCode",{parentName:"p"},"c"),". This depends on the value of the global variable ",(0,o.kt)("inlineCode",{parentName:"p"},"*enable-method-set*"),", and some other confusing options. It may also print a warning but still do the override in certain cases."),(0,o.kt)("h2",{id:"built-in-methods"},"Built in Methods"),(0,o.kt)("p",null,"All types have these 9 methods. They have reasonable defaults if you don't provide anything."),(0,o.kt)("h3",{id:"new"},(0,o.kt)("inlineCode",{parentName:"h3"},"new")),(0,o.kt)("p",null,"The new method is a very special method used to construct a new object, like a constructor. Note that some usages of the ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," keyword ",(0,o.kt)("strong",{parentName:"p"},"do not")," end up calling the new method. See the ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," section for more details. Unlike C++, fields of a type and elements in an array are not constructed either."),(0,o.kt)("p",null,'The first argument is an "allocation", indicating where the object should be constructed. It can be'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The symbol ",(0,o.kt)("inlineCode",{parentName:"li"},"'global")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"'debug"),", indicating the global or debug heaps"),(0,o.kt)("li",{parentName:"ul"},"The symbols ",(0,o.kt)("inlineCode",{parentName:"li"},"'process-level-heap")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"'loading-level"),", indicating whatever heaps are stored in those symbols."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"'process"),", indicating the allocation should occur on the current process heap."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"'scratch"),", for allocating on the scratchpad. This is unused."),(0,o.kt)("li",{parentName:"ul"},"Otherwise it's treated as a 16-byte aligned address and used for in place construction (it zeros the memory first)")),(0,o.kt)("p",null,'The second argument is the "type to make".  It might seem stupid at first, but it allows child classes to use the same ',(0,o.kt)("inlineCode",{parentName:"p"},"new")," method as the parent class."),(0,o.kt)("p",null,"The remaining arguments can be used for whatever you want."),(0,o.kt)("p",null,"When writing your own ",(0,o.kt)("inlineCode",{parentName:"p"},"new")," methods, you should ignore the ",(0,o.kt)("inlineCode",{parentName:"p"},"allocation")," argument and use the ",(0,o.kt)("inlineCode",{parentName:"p"},"object-new")," macro to actually do the allocation.  This takes care of all the details for getting the memory (and setting up runtime type information if its a basic).  See the section on ",(0,o.kt)("inlineCode",{parentName:"p"},"object-new")," for more details."),(0,o.kt)("h3",{id:"delete"},(0,o.kt)("inlineCode",{parentName:"h3"},"delete")),(0,o.kt)("p",null,"This method isn't really used very much. Unlike a C++ destructor it's never called automatically. In some cases, it's repurposed as a \"clean up\" type function but it doesn't actually free any memory.  It takes no arguments.  The default implementations call ",(0,o.kt)("inlineCode",{parentName:"p"},"kfree")," on what the allocation, but there are two issues:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The implementation is sometimes wrong, likely confusing doing pointer math (steps by array stride) with address math (steps by one byte)."),(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"kfree")," function does nothing.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"kheap")," system doesn't really support freeing objects unless you free in the opposite order you allocate, so it makes sense that ",(0,o.kt)("inlineCode",{parentName:"p"},"delete")," doesn't really work."),(0,o.kt)("h3",{id:"print"},(0,o.kt)("inlineCode",{parentName:"h3"},"print")),(0,o.kt)("p",null,"This method should print out a short description of the object (with no newlines) and return the object.  The printing should be done with ",(0,o.kt)("inlineCode",{parentName:"p"},"(format #t ...)")," (see the section on ",(0,o.kt)("inlineCode",{parentName:"p"},"format"),") for more information.  If you call ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," by itself, it'll make this description show up in the REPL. (Note that there is some magic involved to add a newline here... there's actually a function named ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," that calls the ",(0,o.kt)("inlineCode",{parentName:"p"},"print")," method and adds a newline)"),(0,o.kt)("p",null,"The default short description looks like this: ",(0,o.kt)("inlineCode",{parentName:"p"},"#<test-type @ #x173e54>")," for printing an object of type ",(0,o.kt)("inlineCode",{parentName:"p"},"test-type"),". Of course, you can override it with a better version.  Built-in types like string, type, boxed integer, pair, have reasonable overrides."),(0,o.kt)("p",null,"This method is also used to print out the object with ",(0,o.kt)("inlineCode",{parentName:"p"},"format"),"'s ",(0,o.kt)("inlineCode",{parentName:"p"},"~A")," format option."),(0,o.kt)("h3",{id:"inspect"},(0,o.kt)("inlineCode",{parentName:"h3"},"inspect")),(0,o.kt)("p",null,"This method should print out a detailed, multi-line description. By default, ",(0,o.kt)("inlineCode",{parentName:"p"},"structure"),"s and ",(0,o.kt)("inlineCode",{parentName:"p"},"basic"),"s will have an auto-generated method that prints out the name and value of all fields.  For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"gc > (inspect *kernel-context*)\n[00164b44] kernel-context\n  prevent-from-run: 65\n  require-for-run: 0\n  allow-to-run: 0\n  next-pid: 2\n  fast-stack-top: 1879064576\n  current-process: #f\n  relocating-process: #f\n  relocating-min: 0\n  relocating-max: 0\n  relocating-offset: 0\n  low-memory-message: #t\n")),(0,o.kt)("p",null,"In some cases this method is overridden to provide nicer formatting."),(0,o.kt)("h3",{id:"length"},(0,o.kt)("inlineCode",{parentName:"h3"},"length")),(0,o.kt)("p",null,'This method should return a "length".  The default method for this just returns 0, but for things like strings or buffers, it could be used to return the number of characters or elements in use.  It\'s usually used to refer to how many are used, rather than the capacity.'),(0,o.kt)("h3",{id:"asize-of"},(0,o.kt)("inlineCode",{parentName:"h3"},"asize-of")),(0,o.kt)("p",null,"This method should return the size of the object. Including the 4 bytes of type info for a ",(0,o.kt)("inlineCode",{parentName:"p"},"basic"),"."),(0,o.kt)("p",null,"By default this grabs the value from the object's ",(0,o.kt)("inlineCode",{parentName:"p"},"type"),", which is only correct for non-dynamic types. For types like ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," or other dynamic types, this method should be overridden. If you intend to store dynamically sized objects of a given type on a process heap, you ",(0,o.kt)("strong",{parentName:"p"},"must")," implement this method accurately."),(0,o.kt)("h3",{id:"copy"},(0,o.kt)("inlineCode",{parentName:"h3"},"copy")),(0,o.kt)("p",null,"Creates a copy of the object. I don't think this used very much.  Just does a ",(0,o.kt)("inlineCode",{parentName:"p"},"memcpy")," to duplicate by default."),(0,o.kt)("h3",{id:"relocate"},(0,o.kt)("inlineCode",{parentName:"h3"},"relocate")),(0,o.kt)("p",null,"The exact details are still unknown, but is used to update internal data structures after an object is moved in memory. This must be support for objects allocated in process heaps of processes allocated on the actor heap or debug actor heap."),(0,o.kt)("p",null,"It's also called on objects loaded from a GOAL data object file."),(0,o.kt)("h3",{id:"mem-usage"},(0,o.kt)("inlineCode",{parentName:"h3"},"mem-usage")),(0,o.kt)("p",null,"Not much is known yet, but used for computing memory usage statistics."))}u.isMDXComponent=!0}}]);