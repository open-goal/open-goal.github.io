"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3006],{3905:function(e,n,t){t.d(n,{Zo:function(){return l},kt:function(){return b}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function f(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),d=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):f(f({},n),e)),t},l=function(e){var n=d(e.components);return r.createElement(s.Provider,{value:n},e.children)},x={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),c=d(t),b=a,m=c["".concat(s,".").concat(b)]||c[b]||x[b]||o;return t?r.createElement(m,f(f({ref:n},l),{},{components:t})):r.createElement(m,f({ref:n},l))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,f=new Array(o);f[0]=c;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:a,f[1]=i;for(var d=2;d<o;d++)f[d]=t[d];return r.createElement.apply(null,f)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},63555:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return b},frontMatter:function(){return i},metadata:function(){return d},toc:function(){return x}});var r=t(87462),a=t(63366),o=(t(67294),t(3905)),f=["components"],i={sidebar_position:3},s="OpenGOAL Debugger",d={unversionedId:"usage/debugging",id:"usage/debugging",title:"OpenGOAL Debugger",description:"The debugger works on Windows and Linux. All the platform specific code is in xdbg.cpp. When attached to a target, things like exceptions from invalid memory access or divides by zero break into the debugger for inspection on the code or values that caused the break. The technical implementation of the debugger across multiple platforms means there will be a few differences in how it handles or displays certain things. For example, the debugger on Linux will break if the GOAL (EE) thread runs into a breakpoint, but on Windows this can be caused by any thread on the target as the thread that (:break) breaks is unspecified.",source:"@site/documentation/usage/debugging.md",sourceDirName:"usage",slug:"/usage/debugging",permalink:"/docs/usage/debugging",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/usage/debugging.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Compiler REPL",permalink:"/docs/usage/repl"},next:{title:"Editor Configuration",permalink:"/docs/usage/editor_setup"}},l={},x=[{value:"Commands",id:"commands",level:2},{value:"<code>(dbs)</code>",id:"dbs",level:3},{value:"<code>(dbg)</code>",id:"dbg",level:3},{value:"<code>(:cont)</code>",id:"cont",level:3},{value:"<code>(:stop)</code>",id:"stop",level:3},{value:"<code>(:break)</code>",id:"break",level:3},{value:"<code>(:dump-all-mem &lt;path&gt;)</code>",id:"dump-all-mem-path",level:3},{value:"Address Spec",id:"address-spec",level:2},{value:"<code>(:pm)</code>",id:"pm",level:3},{value:"<code>(:disasm)</code>",id:"disasm",level:3},{value:"<code>(:sym-name)</code>",id:"sym-name",level:3},{value:"Breakpoints",id:"breakpoints",level:2}],c={toc:x};function b(e){var n=e.components,t=(0,a.Z)(e,f);return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"opengoal-debugger"},"OpenGOAL Debugger"),(0,o.kt)("p",null,"The debugger works on Windows and Linux. All the platform specific code is in ",(0,o.kt)("inlineCode",{parentName:"p"},"xdbg.cpp"),". When attached to a target, things like exceptions from invalid memory access or divides by zero break into the debugger for inspection on the code or values that caused the break. The technical implementation of the debugger across multiple platforms means there will be a few differences in how it handles or displays certain things. For example, the debugger on Linux will break if the GOAL (EE) thread runs into a breakpoint, but on Windows this can be caused by any thread on the target as the thread that ",(0,o.kt)("inlineCode",{parentName:"p"},"(:break)")," breaks is unspecified."),(0,o.kt)("h2",{id:"commands"},"Commands"),(0,o.kt)("h3",{id:"dbs"},(0,o.kt)("inlineCode",{parentName:"h3"},"(dbs)")),(0,o.kt)("p",null,'Print the status of the debugger and listener.  The listener status is whether or not there is a socket connection open between the compiler and the target. The "debug context" is information that the runtime sends to the compiler so it can find the correct thread to debug. In order to debug, you need both.'),(0,o.kt)("h3",{id:"dbg"},(0,o.kt)("inlineCode",{parentName:"h3"},"(dbg)")),(0,o.kt)("p",null,"Attach the debugger. This will stop the target."),(0,o.kt)("p",null,"Example of connecting to the target for debugging:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},'OpenGOAL Compiler 0.1\n\n;; attach the listener over the network\ng> (lt)\n[Listener] Socket connected established! (took 0 tries). Waiting for version...\nGot version 0.1 OK!\n\n;; this message is sent from the target from kprint.cpp and contains the "debug context"\n[OUTPUT] reset #x147d24 #x2000000000 1062568\n\n;; the debugger gets the message and remembers it so it can connect in the future.\n[Debugger] Context: valid = true, s7 = 0x147d24, base = 0x2000000000, tid = 1062568\n\n;; attach the debugger and halt\ngc> (dbg)\n[Debugger] PTRACE_ATTACHED! Waiting for process to stop...\nDebugger connected.\n\n;; print the debugger status\ngc> (dbs)\n Listener connected? true\n Debugger context? true\n Attached? true\n Halted? true\n Context: valid = true, s7 = 0x147d24, base = 0x2000000000, tid = 1062568\n')),(0,o.kt)("h3",{id:"cont"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:cont)")),(0,o.kt)("p",null,"Continue the target if it has been stopped."),(0,o.kt)("h3",{id:"stop"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:stop)")),(0,o.kt)("p",null,"Detach from target."),(0,o.kt)("h3",{id:"break"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:break)")),(0,o.kt)("p",null,"Immediately stop the target if it is running. Will print some registers."),(0,o.kt)("h3",{id:"dump-all-mem-path"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:dump-all-mem <path>)")),(0,o.kt)("p",null,"Dump all GOAL memory to a file. Must be stopped."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},'(:dump-all-mem "mem.bin")\n')),(0,o.kt)("p",null,"The path is relative to the Jak project folder."),(0,o.kt)("p",null,"The file will be the exact size of ",(0,o.kt)("inlineCode",{parentName:"p"},"EE_MAIN_MEM_SIZE"),", but the first ",(0,o.kt)("inlineCode",{parentName:"p"},"EE_LOW_MEM_PROTECT")," bytes are zero, as these cannot be written or read."),(0,o.kt)("h2",{id:"address-spec"},"Address Spec"),(0,o.kt)("p",null,'Anywhere an address can be used, you can also use an "address spec", which gives you easier ways to input addresses. For now, the address spec is pretty simple, but there will be more features in the future.'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(sym-val <sym-name>)"),". Get the address stored in the symbol with the given name. Currently there's no check to see if the symbol actually stores an address or not. This is like \"evaluate ",(0,o.kt)("inlineCode",{parentName:"li"},"<sym-name>"),', then treat the value as an address"'),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"(sym <sym-name>)"),". Get the address of the symbol object itself, including the basic offset.")),(0,o.kt)("p",null,"Example to show the difference:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"\n;; the symbol is at 0x142d1c\ngc> (inspect '*kernel-context*)\n[  142d1c] symbol\n    name: *kernel-context*\n    hash: #x8f9a35ff\n    value: #<kernel-context @ #x164a84>\n1322268\n\n;; the object is at 0x164a84\ngc> (inspect *kernel-context*)\n[00164a84] kernel-context\n    prevent-from-run: 65\n    require-for-run: 0\n    allow-to-run: 0\n    next-pid: 2\n    fast-stack-top: 1879064576\n    current-process: #f\n    relocating-process: #f\n    relocating-min: 0\n    relocating-max: 0\n    relocating-offset: 0\n    low-memory-message: #t\n1460868\n\n;; break, so we can debug\ngc> (:break)\nRead symbol table (159872 bytes, 226 reads, 225 symbols, 1.96 ms)\nrax: 0xfffffffffffffdfc rcx: 0x00007f745b508361 rdx: 0x00007f745b3ffca0 rbx: 0x0000000000147d24\nrsp: 0x00007f745b3ffc40 rbp: 0x00007f745b3ffcc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000000000  r9: 0x0000000000000008 r10: 0x00007f745b3ffca0 r11: 0x0000000000000293\nr12: 0x0000000000147d24 r13: 0x00007ffdff32cfaf r14: 0x00007ffdff32cfb0 r15: 0x00007f745b3fffc0\nrip: 0x00007f745b508361\n\n;; reads the symbol's memory:\n;; at 0x142d1c there is the value 0x164a84\ngc> (dw (sym *kernel-context*) 1)\n 0x00142d1c: 0x00164a84\n\n;; treat the symbol's value as an address and read the memory there.\n;; notice that the 0x41 in the first word is decimal 65, the first field of the kernel-context.\ngc> (dw (sym-val *kernel-context*) 10)\n 0x00164a84: 0x00000041 0x00000000 0x00000000 0x00000002\n 0x00164a94: 0x70004000 0x00147d24 0x00147d24 0x00000000\n 0x00164aa4: 0x00000000 0x00000000\n")),(0,o.kt)("h3",{id:"pm"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:pm)")),(0,o.kt)("p",null,"Print memory"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"(:pm elt-size addr elt-count [:print-mode mode])\n")),(0,o.kt)("p",null,"The element size is the size of each word to print. It can be 1, 2, 4, 8 currently.  The address is the GOAL Address to print at. The elt-count is the number of words to print.  The print mode is option and defaults to ",(0,o.kt)("inlineCode",{parentName:"p"},"hex"),". There is also an ",(0,o.kt)("inlineCode",{parentName:"p"},"unsigned-decimal"),", a ",(0,o.kt)("inlineCode",{parentName:"p"},"signed-decimal"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"float"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"float")," mode only works when ",(0,o.kt)("inlineCode",{parentName:"p"},"elt-size")," is 4."),(0,o.kt)("p",null,"There are some useful macros inspired by the original PS2 TOOL debugger (",(0,o.kt)("inlineCode",{parentName:"p"},"dsedb"),") for the different sizes. They are ",(0,o.kt)("inlineCode",{parentName:"p"},"db"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"dh"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"dw"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"dd")," for 1, 2, 4, and 8 byte hex prints which follows the naming convention of MIPS load/stores. There is also a ",(0,o.kt)("inlineCode",{parentName:"p"},"df")," for printing floats. See the example below."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"OpenGOAL Compiler 0.1\n\n;; first connect the listener\ng> (lt)\n[Listener] Socket connected established! (took 0 tries). Waiting for version...\nGot version 0.1 OK!\n[OUTPUT] reset #x147d24 #x2000000000 53371\n\n[Debugger] Context: valid = true, s7 = 0x147d24, base = 0x2000000000, tid = 53371\n\n;; define a new array of floats, and set a few values\ngc> (define x (new 'global 'array 'float 12))\n1452224\n\ngc> (set! (-> x 0) 1.0)\n1065353216\n\ngc> (set! (-> x 2) 2.0)\n1073741824\n\n;; attach the debugger (halts the target)\ngc> (dbg)\n[Debugger] PTRACE_ATTACHED! Waiting for process to stop...\nrax: 0xfffffffffffffdfc rcx: 0x00007f6b94964361 rdx: 0x00007f6b8fffeca0 rbx: 0x0000000000147d24\nrsp: 0x00007f6b8fffec40 rbp: 0x00007f6b8fffecc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000000000  r9: 0x000000000000000b r10: 0x00007f6b8fffeca0 r11: 0x0000000000000293\nr12: 0x0000000000147d24 r13: 0x00007ffd16fb117f r14: 0x00007ffd16fb1180 r15: 0x00007f6b8fffefc0\nrip: 0x00007f6b94964361\nDebugger connected.\n\n;; print memory as 10 bytes\ngc> (db 1452224 10)\n 0x001628c0: 0x00 0x00 0x80 0x3f 0x00 0x00 0x00 0x00 0x00 0x00\n\n;; print memory as 10 words (32-bit words)\ngc> (dw 1452224 10)\n 0x001628c0: 0x3f800000 0x00000000 0x40000000 0x00000000\n 0x001628d0: 0x00000000 0x00000000 0x00000000 0x00000000\n 0x001628e0: 0x00000000 0x00000000\n\n;; print memory as 10 floats\ngc> (df 1452224 10)\n 0x001628c0:   1.0000   0.0000   2.0000   0.0000\n 0x001628d0:   0.0000   0.0000   0.0000   0.0000\n 0x001628e0:   0.0000   0.0000\n\n;; set some more values, must unbreak first\ngc> (:cont)\ngc> (set! (-> x 1) (the-as float -12))\n-12\n\n;; break and print as decimal\ngc> (:break)\nrax: 0xfffffffffffffdfc rcx: 0x00007f6b94964361 rdx: 0x00007f6b8fffeca0 rbx: 0x0000000000147d24\nrsp: 0x00007f6b8fffec40 rbp: 0x00007f6b8fffecc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000000000  r9: 0x0000000000000004 r10: 0x00007f6b8fffeca0 r11: 0x0000000000000293\nr12: 0x0000000000147d24 r13: 0x00007ffd16fb117f r14: 0x00007ffd16fb1180 r15: 0x00007f6b8fffefc0\nrip: 0x00007f6b94964361\ngc> (:pm 4 1452224 10 :print-mode unsigned-dec)\n 0x001628c0:   1065353216   4294967284   1073741824            0\n 0x001628d0:            0            0            0            0\n 0x001628e0:            0            0\ngc> (:pm 4 1452224 10 :print-mode signed-dec)\n 0x001628c0:   1065353216          -12   1073741824            0\n 0x001628d0:            0            0            0            0\n 0x001628e0:            0            0\n")),(0,o.kt)("h3",{id:"disasm"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:disasm)")),(0,o.kt)("p",null,"Disassembly instructions in memory"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"(:disasm addr len)\n")),(0,o.kt)("p",null,"Example (after doing a ",(0,o.kt)("inlineCode",{parentName:"p"},"(lt)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(blg)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(dbg)"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nasm"},"gs> (:disasm (sym-val basic-type?) 59)\nObject: gcommon\n\n[0x28eb4c631c4] mov r9d, [r15+rdi*1-0x04]\n[0x28eb4c631c9] mov r8d, [object]\n[0x28eb4c631d1] cmp r9, rsi\n[0x28eb4c631d4] jnz 0x0000028EB4C631E9\n[0x28eb4c631da] lea rax, '#t\n[0x28eb4c631df] jmp 0x0000028EB4C631FD\n[0x28eb4c631e4] jmp 0x0000028EB4C631EC\n[0x28eb4c631e9] mov rcx, '#f\n[0x28eb4c631ec] mov r9d, [r15+r9*1+0x04]\n[0x28eb4c631f1] cmp r9, r8\n[0x28eb4c631f4] jnz 0x0000028EB4C631D1\n[0x28eb4c631fa] mov rax, '#f\n[0x28eb4c631fd] ret\n")),(0,o.kt)("p",null,"For now, the disassembly is pretty basic, but it should eventually support GOAL symbols."),(0,o.kt)("h3",{id:"sym-name"},(0,o.kt)("inlineCode",{parentName:"h3"},"(:sym-name)")),(0,o.kt)("p",null,"Print the name of a symbol from its offset. The name is fetched from memory."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"(:sym-name offset)\n")),(0,o.kt)("p",null,"Example (after doing a ",(0,o.kt)("inlineCode",{parentName:"p"},"(lt)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(blg)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"(dbg)"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-nasm"},"gs> (:sym-name 0)\nsymbol name for symbol 0h is #f\ngs> (:sym-name 8)\nsymbol name for symbol 8h is #t\ngs> (:sym-name 16)\nsymbol name for symbol 10h is function\ngs> (:sym-name #x18)\nsymbol name for symbol 18h is basic\ngs> (:sym-name #x20)\nsymbol name for symbol 20h is string\ngs> (:sym-name #x30)\nsymbol name for symbol 30h is type\ngs> (:sym-name #x80)\nsymbol name for symbol 80h is int64\ngs> (:sym-name #x800)\nsymbol 800h is not loaded or is invalid\n")),(0,o.kt)("p",null,"Keep in mind ",(0,o.kt)("inlineCode",{parentName:"p"},"-#xa8")," is not valid syntax for a negative number in hexadecimal."),(0,o.kt)("h2",{id:"breakpoints"},"Breakpoints"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-lisp"},"OpenGOAL Compiler 0.1\n\n;; first, connect to the target\ng  > (lt)\n[Listener] Socket connected established! (took 0 tries). Waiting for version...\nGot version 0.1 OK!\n[OUTPUT] reset #x147d24 #x2000000000 322300\n\n[Debugger] Context: valid = true, s7 = 0x147d24, base = 0x2000000000, tid = 322300\n\n\n;; run an infinite loop. This will time out because we don't see a response from the GOAL kernel that our function\n;; has returned.\ngc > (while #t (+ 1 2 3 4 5 6 7))\n  Error - target has timed out. If it is stuck in a loop, it must be manually killed.\nRuntime is not responding. Did it crash?\n\n\n;; so we can attach the debugger!\ngc > (dbg)\n[Debugger] PTRACE_ATTACHED! Waiting for process to stop...\nTarget has stopped. Run (:di) to get more information.\nRead symbol table (146816 bytes, 124 reads, 123 symbols, 2.02 ms)\nrax: 0x000000000000000a rcx: 0x0000000000000005 rdx: 0x0000000000000000 rbx: 0x0000002000000000\nrsp: 0x00007fddcde75c58 rbp: 0x00007fddcde75cc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000147d24  r9: 0x0000002000000000 r10: 0x00007fddcde75ca0 r11: 0x0000000000000000\nr12: 0x0000000000147d24 r13: 0x0000002007ffbf14 r14: 0x0000000000147d24 r15: 0x0000002000000000\nrip: 0x0000002007ffbf3b\n  [0x2007ffbf1b] add [rax], al\n  [0x2007ffbf1d] add [rcx+0x02], bh\n  [0x2007ffbf23] add rax, rcx\n  [0x2007ffbf26] mov ecx, 0x03\n  [0x2007ffbf2b] add rax, rcx\n  [0x2007ffbf2e] mov ecx, 0x04\n  [0x2007ffbf33] add rax, rcx\n  [0x2007ffbf36] mov ecx, 0x05\n- [0x2007ffbf3b] add rax, rcx\n  [0x2007ffbf3e] mov ecx, 0x06\n  [0x2007ffbf43] add rax, rcx\n  [0x2007ffbf46] mov ecx, 0x07\n  [0x2007ffbf4b] add rax, rcx\n  [0x2007ffbf4e] mov eax, [r15+r14*1+0x08]\n  [0x2007ffbf56] mov rcx, r14\n  [0x2007ffbf59] add rcx, 0x00\n  [0x2007ffbf60] cmp rax, rcx\n  [0x2007ffbf63] jnz 0x0000002007FFBF19\n  [0x2007ffbf69] mov eax, [r15+r14*1]\n  [0x2007ffbf71] ret\n  [0x2007ffbf72] add [rax], al\n  [0x2007ffbf74] add [rax], al\n  [0x2007ffbf76] add [rax], al\n  [0x2007ffbf78] add [rax], al\n  [0x2007ffbf7a] INVALID (0x00)\n\nDebugger connected.\n\n;; currently rcx = 5. let's set a breakpoint where it should be 7\ngcs> (:bp #x2007ffbf4b)\n\n;; and continue...\ngcs> (:cont)\n\n;; it hits the breakpoint. (this message should have more information...)\nTarget has stopped. Run (:di) to get more information.\n\n;; get some info:\ngcs> (:di)\nRead symbol table (146816 bytes, 124 reads, 123 symbols, 1.46 ms)\nrax: 0x0000000000000015 rcx: 0x0000000000000007 rdx: 0x0000000000000000 rbx: 0x0000002000000000\nrsp: 0x00007fddcde75c58 rbp: 0x00007fddcde75cc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000147d24  r9: 0x0000002000000000 r10: 0x00007fddcde75ca0 r11: 0x0000000000000000\nr12: 0x0000000000147d24 r13: 0x0000002007ffbf14 r14: 0x0000000000147d24 r15: 0x0000002000000000\nrip: 0x0000002007ffbf4c\n  [0x2007ffbf2c] add eax, ecx\n  [0x2007ffbf2e] mov ecx, 0x04\n  [0x2007ffbf33] add rax, rcx\n  [0x2007ffbf36] mov ecx, 0x05\n  [0x2007ffbf3b] add rax, rcx\n  [0x2007ffbf3e] mov ecx, 0x06\n  [0x2007ffbf43] add rax, rcx\n  [0x2007ffbf46] mov ecx, 0x07\n  [0x2007ffbf4b] int3            ;; oops! should probably patch this in the disassembly!\n- [0x2007ffbf4c] add eax, ecx\n  [0x2007ffbf4e] mov eax, [r15+r14*1+0x08]\n  [0x2007ffbf56] mov rcx, r14\n  [0x2007ffbf59] add rcx, 0x00\n  [0x2007ffbf60] cmp rax, rcx\n  [0x2007ffbf63] jnz 0x0000002007FFBF19\n  [0x2007ffbf69] mov eax, [r15+r14*1]\n  [0x2007ffbf71] ret\n  [0x2007ffbf72] add [rax], al\n  [0x2007ffbf74] add [rax], al\n  [0x2007ffbf76] add [rax], al\n  [0x2007ffbf78] add [rax], al\n  [0x2007ffbf7a] add [rax], al\n  [0x2007ffbf7c] add [rax], al\n  [0x2007ffbf7e] add [rax], al\n  [0x2007ffbf80] in al, 0x08\n  [0x2007ffbf82] INVALID (0x16)\n  [0x2007ffbf82] add [rax], al\n  [0x2007ffbf84] add [rcx], al\n  [0x2007ffbf86] add [rbx], al\n  [0x2007ffbf88] add [rax], al\n  [0x2007ffbf8a] INVALID (0x00)\n\n;; remove the breakpoint\ngcs> (:ubp #x2007ffbf4b)\n\n;; continue, it stays running\ngcs> (:cont)\ngcr>\n\n;; break and check, the code is back to normal!\ngcr> (:break)\nTarget has stopped. Run (:di) to get more information.\nRead symbol table (146816 bytes, 124 reads, 123 symbols, 1.28 ms)\nrax: 0x0000000000000015 rcx: 0x0000000000000007 rdx: 0x0000000000000000 rbx: 0x0000002000000000\nrsp: 0x00007fddcde75c58 rbp: 0x00007fddcde75cc0 rsi: 0x0000000000000000 rdi: 0x0000000000000000\n r8: 0x0000000000147d24  r9: 0x0000002000000000 r10: 0x00007fddcde75ca0 r11: 0x0000000000000000\nr12: 0x0000000000147d24 r13: 0x0000002007ffbf14 r14: 0x0000000000147d24 r15: 0x0000002000000000\nrip: 0x0000002007ffbf4b\n  [0x2007ffbf2b] add rax, rcx\n  [0x2007ffbf2e] mov ecx, 0x04\n  [0x2007ffbf33] add rax, rcx\n  [0x2007ffbf36] mov ecx, 0x05\n  [0x2007ffbf3b] add rax, rcx\n  [0x2007ffbf3e] mov ecx, 0x06\n  [0x2007ffbf43] add rax, rcx\n  [0x2007ffbf46] mov ecx, 0x07\n- [0x2007ffbf4b] add rax, rcx\n  [0x2007ffbf4e] mov eax, [r15+r14*1+0x08]\n  [0x2007ffbf56] mov rcx, r14\n  [0x2007ffbf59] add rcx, 0x00\n  [0x2007ffbf60] cmp rax, rcx\n  [0x2007ffbf63] jnz 0x0000002007FFBF19\n  [0x2007ffbf69] mov eax, [r15+r14*1]\n  [0x2007ffbf71] ret\n  [0x2007ffbf72] add [rax], al\n  [0x2007ffbf74] add [rax], al\n  [0x2007ffbf76] add [rax], al\n  [0x2007ffbf78] add [rax], al\n  [0x2007ffbf7a] add [rax], al\n  [0x2007ffbf7c] add [rax], al\n  [0x2007ffbf7e] add [rax], al\n  [0x2007ffbf80] in al, 0x08\n  [0x2007ffbf82] INVALID (0x16)\n  [0x2007ffbf82] add [rax], al\n  [0x2007ffbf84] add [rcx], al\n  [0x2007ffbf86] add [rbx], al\n  [0x2007ffbf88] add [rax], al\n\ngcs>\n\n;; we can still properly exit from the target, even in this state!\ngcs> (e)\nTried to reset a halted target, detaching...\n  Error - target has timed out. If it is stuck in a loop, it must be manually killed.\n[Listener] Closed connection to target\n")))}b.isMDXComponent=!0}}]);