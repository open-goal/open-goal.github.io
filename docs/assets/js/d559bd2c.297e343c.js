"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[251],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return m}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),d=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=d(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),u=d(n),m=a,c=u["".concat(s,".").concat(m)]||u[m]||p[m]||o;return n?i.createElement(c,r(r({ref:t},h),{},{components:n})):i.createElement(c,r({ref:t},h))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var d=2;d<o;d++)r[d]=n[d];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3986:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return p}});var i=n(7462),a=n(3366),o=(n(7294),n(3905)),r=["components"],l={sidebar_position:3},s="Porting to x86",d={unversionedId:"developing/porting_to_x86",id:"developing/porting_to_x86",title:"Porting to x86",description:"This document will keep track of stuff that needs to be ported or modified significantly for x86. Anything that uses PS2-specific hardware or relies on stuff in the C Kernel will need to be ported.",source:"@site/documentation/developing/porting_to_x86.md",sourceDirName:"developing",slug:"/developing/porting_to_x86",permalink:"/docs/developing/porting_to_x86",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/developing/porting_to_x86.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Assembly Emitter",permalink:"/docs/developing/asm_emitter"},next:{title:"Registers",permalink:"/docs/developing/registers"}},h={},p=[{value:"Basic Info",id:"basic-info",level:2},{value:"Math Libraries",id:"math-libraries",level:2},{value:"The IOP (I/O Processor) Framework",id:"the-iop-io-processor-framework",level:2},{value:"OVERLORD Framework",id:"overlord-framework",level:2},{value:"OVERLORD ISO Thread",id:"overlord-iso-thread",level:2},{value:"IOP PLAY (6)",id:"iop-play-6",level:2},{value:"IOP STR (5)",id:"iop-str-5",level:2},{value:"IOP DGO (4)",id:"iop-dgo-4",level:2},{value:"IOP Server/Ramdisk (3)",id:"iop-serverramdisk-3",level:2},{value:"IOP Loader (2)",id:"iop-loader-2",level:2},{value:"IOP Player (1)",id:"iop-player-1",level:2},{value:"IOP VBlank Handler",id:"iop-vblank-handler",level:2},{value:"Sound Library",id:"sound-library",level:2},{value:"GOAL Kernel",id:"goal-kernel",level:2},{value:"Jak Graphics Basics",id:"jak-graphics-basics",level:2},{value:"DMA",id:"dma",level:2},{value:"Display",id:"display",level:2},{value:"Texture",id:"texture",level:2},{value:"Collision System",id:"collision-system",level:2},{value:"Joint",id:"joint",level:2},{value:"BSP",id:"bsp",level:2},{value:"Merc Blend Shape",id:"merc-blend-shape",level:2},{value:"Ripple",id:"ripple",level:2},{value:"Bones",id:"bones",level:2},{value:"Generic Merc",id:"generic-merc",level:2},{value:"Generic TIE",id:"generic-tie",level:2},{value:"Shadow",id:"shadow",level:2},{value:"Font",id:"font",level:2},{value:"Decompression",id:"decompression",level:2},{value:"Background",id:"background",level:2},{value:"Draw Node Culling",id:"draw-node-culling",level:2},{value:"Shrubbery",id:"shrubbery",level:2},{value:"TFRAG",id:"tfrag",level:2},{value:"TIE",id:"tie",level:2},{value:"Particle",id:"particle",level:2},{value:"Time of Day",id:"time-of-day",level:2},{value:"Sky",id:"sky",level:2},{value:"Load boundary",id:"load-boundary",level:2},{value:"Sound",id:"sound",level:2},{value:"Controllers",id:"controllers",level:2},{value:"IOP Streaming",id:"iop-streaming",level:2},{value:"Ocean",id:"ocean",level:2},{value:"Navigate",id:"navigate",level:2}],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,r);return(0,o.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"porting-to-x86"},"Porting to x86"),(0,o.kt)("p",null,"This document will keep track of stuff that needs to be ported or modified significantly for x86. Anything that uses PS2-specific hardware or relies on stuff in the C Kernel will need to be ported."),(0,o.kt)("h2",{id:"basic-info"},"Basic Info"),(0,o.kt)("p",null,"Most of the game is written in GOAL. All this source lives in ",(0,o.kt)("inlineCode",{parentName:"p"},"goal_src"),"."),(0,o.kt)("p",null,'The "runtime" is all the support code written in C++. It\'s located in ',(0,o.kt)("inlineCode",{parentName:"p"},"game/"),'. Sometimes the "runtime" + GOAL code together is called the "target".'),(0,o.kt)("p",null,'Most of the code in "runtime" is reverse engineered code from the real game, with small tweaks to make it work on x86 and with OpenGOAL.'),(0,o.kt)("p",null,"The code in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/system")," is ",(0,o.kt)("strong",{parentName:"p"},"not")," from the game and is an implementation of system functions that are implemented by Sony in the PS2 game. It's stuff like threading, I/O, etc."),(0,o.kt)("p",null,"The code in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/sce")," is my implementation of the Sony libraries. When possible, I tried to keep exactly the same names/functions as the real Sony libraries. This way our reverse engineered game code can look very similar to the original, which is satisfying and fun."),(0,o.kt)("p",null,"The PS2's main CPU is called the EE. It runs GOAL code and the C Kernel, which is Naughty Dog's C++ code.  The C Kernel is responsible for bootstrapping GOAL's kernel and exposing Sony library functions to GOAL code.  The C Kernel is in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/kernel"),'.  In OpenGOAL the "EE Thread" runs code than ran on the EE on the PS2. This includes the C Kernel and all GOAL code. There is a single EE thread - GOAL implements its own threading, but this all runs in the same Linux/Windows thread.'),(0,o.kt)("p",null,"The PS2 has a separate I/O Processor called the IOP. It runs the OVERLORD driver written by Naughty Dog in C. OpenGOAL uses C++ for its implementation of OVERLORD. Like with the EE, there are Sony libraries for the IOP. These are in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/sce/iop")," to distinguish them from EE code. The IOP can run independently from the EE. Unlike the EE, the IOP itself has multiple threads (7 threads) that each have their own OS thread. But only one IOP thread runs at a time, as the IOP was a single-core CPU."),(0,o.kt)("p",null,"To give an idea of the size of these (counted by ",(0,o.kt)("inlineCode",{parentName:"p"},"wc -l"),"):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"OVERLORD is 3700 lines, but still has a lot to implement,"),(0,o.kt)("li",{parentName:"ul"},"C Kernel is 7432 lines, and is mostly done"),(0,o.kt)("li",{parentName:"ul"},"SCE is 973 lines, and still has some to implement"),(0,o.kt)("li",{parentName:"ul"},"System is 1294 lines, and still has some to implement")),(0,o.kt)("h2",{id:"math-libraries"},"Math Libraries"),(0,o.kt)("p",null,"I think most of the math libraries can be decompiled, but there are a few that will need manual work. These are also a great place to do tests as the math functions have very few dependencies and we know what the right answer should be for many of them."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"bounding-box")," (only some stuff)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"math")," (only ",(0,o.kt)("inlineCode",{parentName:"li"},"rand-uint31-gen"),")"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"matrix")," (only some stuff)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"geometry")," (only some stuff)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"trigonometry")," (only some stuff)")),(0,o.kt)("p",null,"At some point we may want to re-implement some of these to be more efficient."),(0,o.kt)("h2",{id:"the-iop-io-processor-framework"},"The IOP (I/O Processor) Framework"),(0,o.kt)("p",null,"This is already implemented."),(0,o.kt)("p",null,"The IOP was a separate I/O Processor on the PS2. It runs a cooperative multi-tasking kernel developed by Sony. In OpenGOAL it is implemented in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/system/IOP_Kernel.h"),".  The IOP Kernel is managed by the IOP runtime thread (",(0,o.kt)("inlineCode",{parentName:"p"},"game/system/iop_thread.h"),")."),(0,o.kt)("p",null,"The library in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/sce/iop.h")," wraps the ",(0,o.kt)("inlineCode",{parentName:"p"},"IOP_Kernel")," in an interface that looks like the Sony libraries used by the game so the IOP code can be ported directly."),(0,o.kt)("p",null,"There are a few stub functions that are hardcoded to return the correct values for stuff like CD drive initialization.  The main features currently supported are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Threads (create, wakeup, start, sleep, delay, get ID)"),(0,o.kt)("li",{parentName:"ul"},"Messageboxes to pass data between threads (send, poll)"),(0,o.kt)("li",{parentName:"ul"},"SIF RPC, a library to receive remote procedure calls from the EE. See ",(0,o.kt)("inlineCode",{parentName:"li"},"game/sce/sif_ee.h")," for the wrapper of the EE side library, and ",(0,o.kt)("inlineCode",{parentName:"li"},"game/kernel/kdgo.cpp")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"ksound.cpp")," for the wrapper around the EE library that's exposed to GOAL."),(0,o.kt)("li",{parentName:"ul"},"DMA to the EE for sending data from the IOP to GOAL.")),(0,o.kt)("p",null,"All this stuff is currently used for loading DGOs, which is tested and working."),(0,o.kt)("h2",{id:"overlord-framework"},"OVERLORD Framework"),(0,o.kt)("p",null,"This is already implemented."),(0,o.kt)("p",null,"The OVERLORD is the code written by Naughty Dog that runs on the IOP. It is responsible for sound and loading data.  It's surprisingly complicated and some parts of it are extremely poorly written, especially the thread synchronization stuff.  My implementation of OVERLORD is in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/overlord"),". It's not complete yet, but the basics are there and it does enough to load DGOs."),(0,o.kt)("p",null,"The framework for OVERLORD is already implemented. The C Kernel calls a Sony library function to load OVERLORD. This library function is ",(0,o.kt)("inlineCode",{parentName:"p"},"sceSifLoadModule"),", implemented in ",(0,o.kt)("inlineCode",{parentName:"p"},"sif_ee.cpp"),", which tells the IOP Kernel code to start.  This starts up the OVERLORD thread which eventually calls ",(0,o.kt)("inlineCode",{parentName:"p"},"start_overlord")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"game/overlord/overlord.cpp"),".  This ",(0,o.kt)("inlineCode",{parentName:"p"},"start_overlord")," function is the entry point to Naughty Dog's OVERLORD library and starts a bunch more threads (see ",(0,o.kt)("inlineCode",{parentName:"p"},"InitISOFS"),"), using the Sony IOP library.  In total there are 7 threads."),(0,o.kt)("p",null,"Once ",(0,o.kt)("inlineCode",{parentName:"p"},"start_overlord")," returns, the initial call to ",(0,o.kt)("inlineCode",{parentName:"p"},"sceSifLoadModule")," returns and the runtime keeps initializing."),(0,o.kt)("h2",{id:"overlord-iso-thread"},"OVERLORD ISO Thread"),(0,o.kt)("p",null,"This is partially implemented."),(0,o.kt)("p",null,"This thread is responsible for controlling the DVD drive and the small DVD data buffers used in the IOP. It has a big loop in ",(0,o.kt)("inlineCode",{parentName:"p"},"ISOThread()")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"iso.cpp")," that looks for pending reads, executes them, waits for data to be read, then calls a callback.  This code is unbelievably confusing."),(0,o.kt)("p",null,"It receives commands from other OVERLORD threads (using a MessageBox) and uses the priority queue implemented in ",(0,o.kt)("inlineCode",{parentName:"p"},"iso_queue.cpp")," to decide which read gets to go first."),(0,o.kt)("p",null,"To interact with the DVD drive, it uses an ",(0,o.kt)("inlineCode",{parentName:"p"},"IsoFS")," abstraction, which is a struct containing function pointers to control the drive. The version of OVERLORD in the retail game has only one implemented, called ",(0,o.kt)("inlineCode",{parentName:"p"},"iso_cd")," which uses the actual drive in the PS2. There's also a reference to ",(0,o.kt)("inlineCode",{parentName:"p"},"fakeiso"),', but this is empty in the game. Instead of "emulating" the CD drive functions, I implemented my own version of ',(0,o.kt)("inlineCode",{parentName:"p"},"fakeiso")," mode in ",(0,o.kt)("inlineCode",{parentName:"p"},"fake_iso.cpp"),".  This just reads files from your hard drive and uses the ",(0,o.kt)("inlineCode",{parentName:"p"},"fakeiso.txt")," file to map files in the ",(0,o.kt)("inlineCode",{parentName:"p"},"jak-project")," folder to OVERLORD file names (it has it's own system for naming files)."),(0,o.kt)("p",null,"It also has some sound stuff in it for managing VAG audio streams, but this isn't implemented yet."),(0,o.kt)("p",null,'The other threads in OVERLORD are "RPC" threads. They sit in a loop waiting for the main runtime thread (EE thread) to send a remote procedure call (RPC). Then they do something (like maybe sending a message to the ISO thread), maybe wait for something to happen, and then return.'),(0,o.kt)("p",null,"From the GOAL/EE side of things, RPC calls can be blocking or non-blocking. They can be issued from GOAL (with ",(0,o.kt)("inlineCode",{parentName:"p"},"rpc-call"),") or from the C Kernel (",(0,o.kt)("inlineCode",{parentName:"p"},"RpcCall"),'). Per "channel" (corresponds to an IOP thread), there can only be one RPC call happening at a time. The ',(0,o.kt)("inlineCode",{parentName:"p"},"rpc-busy?")," command can be used to check if an RPC is complete."),(0,o.kt)("h2",{id:"iop-play-6"},"IOP PLAY (6)"),(0,o.kt)("p",null,"This is unimplemented."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PLAY"),' RPC appears to be relatively simple and plays/stops/pauses/queues a VAG audio stream. It can either use the "AnimationName" system or another system to get the name of the audio stream.  I don\'t know what sound effects in the game are streamed, but I believe there are some.'),(0,o.kt)("p",null,"I suspect the GOAL side code for this is in ",(0,o.kt)("inlineCode",{parentName:"p"},"gsound")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"gsound-h"),"."),(0,o.kt)("h2",{id:"iop-str-5"},"IOP STR (5)"),(0,o.kt)("p",null,"This is unimplemented."),(0,o.kt)("p",null,"This is an RPC for streaming data back to the EE. I think this is used to control animation streaming."),(0,o.kt)("h2",{id:"iop-dgo-4"},"IOP DGO (4)"),(0,o.kt)("p",null,"This is implemented."),(0,o.kt)("p",null,'This is the RPC for loading DGO files.  The DGO loading is super complicated, but the basic idea is that loading / linking are double buffered. In order to allow linking files to allocate memory, the currently loading file goes in a temporary buffer on the top of the heap. (There are actually two temp buffers that rotate, one for loading out of and one for linking, as the "copy to heap" step is done as part of linking, not loading)'),(0,o.kt)("p",null,"The final chunk is not double buffered. This is so it can be loaded directly into its final location in the heap. This has three advantages: you don't need to copy it out of a temporary buffer, you can have a file larger than the temp buffer and you can also entirely fill the heap this way (the temp buffers are freed so you don't have to worry about that)."),(0,o.kt)("p",null,"The IOP side state machine for this is in ",(0,o.kt)("inlineCode",{parentName:"p"},"iso.cpp"),", implemented inside of the DGO load buffer complete callback and is somewhat complicated because DGO info may be split between multiple buffers, and you have to deal with getting partial info.  The EE side is in ",(0,o.kt)("inlineCode",{parentName:"p"},"kdgo.cpp"),"."),(0,o.kt)("p",null,"The DGO synchronization is pretty confusing but I believe I have it working. It may be worth documenting it more (I thought I did already, but where did I put it?)."),(0,o.kt)("h2",{id:"iop-serverramdisk-3"},"IOP Server/Ramdisk (3)"),(0,o.kt)("p",null,"This is implemented, but so far unused and untested."),(0,o.kt)("p",null,"This RPC is used to store files in RAM on the IOP. There's a buffer of around 800 kB. I believe it's used for a few different things, in particular the level visibility data. The EE requests data to be loaded from a file on DVD into the \"ramdisk\" (just a buffer on the IOP), then can request chunks of this file. Of course it is not as fast as storing the file in the EE RAM, but it is much faster than reading from the DVD again."),(0,o.kt)("p",null,'This is what Andy Gavin refers to when they said they did "things they weren\'t supposed to" with the "one megabyte of memory that wasn\'t being used".'),(0,o.kt)("h2",{id:"iop-loader-2"},"IOP Loader (2)"),(0,o.kt)("p",null,"This is unimplemented."),(0,o.kt)("p",null,"This is used to control the loading of music and soundbanks. I haven't touched it yet.  Music and soundbanks are loaded into IOP memory when you switch levels."),(0,o.kt)("h2",{id:"iop-player-1"},"IOP Player (1)"),(0,o.kt)("p",null,"This is unimplemented."),(0,o.kt)("p",null,"This is used to control the playing of sound, and goes with Loader. Like PLAY it can play VAG audio streams. I'm not sure which one is actually used for streaming audio, maybe both?"),(0,o.kt)("h2",{id:"iop-vblank-handler"},"IOP VBlank Handler"),(0,o.kt)("p",null,"This is unimplemented."),(0,o.kt)("p",null,"The IOP's kernel will call ",(0,o.kt)("inlineCode",{parentName:"p"},"VBlank_Handler")," on each vblank. This is once per frame, and I don't know where it is, or if its tied to the actual HW vblank or framebuffer swap, if it happens at 30/60 fps (or even/odd frames if 30 fps). I suspect it's the real vblank at 60 fps but I don't know."),(0,o.kt)("p",null,"This does some music fade calculations and sends some data to the EE.  In GOAL this is called the ",(0,o.kt)("inlineCode",{parentName:"p"},"sound-iop-info"),"."),(0,o.kt)("p",null,"The EE first has to do some set up to tell the IOP where to copy the data, which I believe is done in another sound RPC from GOAL."),(0,o.kt)("p",null,"We'll also need to add some stuff to ",(0,o.kt)("inlineCode",{parentName:"p"},"system")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sce/iop")," to set this up, which will have to work with frame timing stuff so it happens at the right part of the frame."),(0,o.kt)("h2",{id:"sound-library"},"Sound Library"),(0,o.kt)("p",null,'This is a pretty big one. To actually make sounds, OVERLORD code uses a third-party sound library called 989SND. Internally 989SND uses the SPU2 (Sound Processor) to actually do the "sound math" to decode ADPCM, do ADSR for the sampled sounds, and do reverb/mixing.'),(0,o.kt)("p",null,"I think the lowest effort sound implementation is to try to reimplement 989SND + the SPU as a single library.  This could be tested and developed in isolation from everything else."),(0,o.kt)("p",null,"We'll also need to pick a library for doing audio on PC and a design for how to keep the audio in sync. My gut feeling is to let the IOP side audio stuff just run totally independent from everything else, like the real game does. Let the audio sampling be driven by the sound device so you never have any crackling/interpolation artifacts. This is why the audio keeps going even after the game crashes on PS2."),(0,o.kt)("h2",{id:"goal-kernel"},"GOAL Kernel"),(0,o.kt)("p",null,"The GOAL kernel needs some modification to work on x86. It implements userspace threading and needs to know the details of how to back up the current CPU state and restore it.  It also needs to work with the compiler to make sure that the kernel and compiler agree on what registers may not be preserved across a thread suspend  There are also some CPU specific details on how to do dynamic throw/catches, unwinding stack frames, and passing initial arguments to a thread."),(0,o.kt)("p",null,"In OpenGOAL, the ",(0,o.kt)("inlineCode",{parentName:"p"},"rsp"),' is a "real" pointer and all other pointers are "GOAL pointer"s (offset from base of GOAL memory), so there are some details needed to correctly save/restore stacks.'),(0,o.kt)("p",null,"A final detail is we will probably want/need the ability to increase the default size of stack that can be backed up on suspend. The default is 256 bytes so if our compiler does worse than the original and we use more stack space, we could run out. There's a check for this so it shouldn't be hard to detect."),(0,o.kt)("h2",{id:"jak-graphics-basics"},"Jak Graphics Basics"),(0,o.kt)("p",null,"The PS2 has some special hardware that's used for graphics. These are the DMAC, the VU1, and the GS."),(0,o.kt)("p",null,'The DMAC is a sophisticated DMA controller. It runs separately from the EE and can copy data from one place to another at pretty high speed. If it is not stalled for any reason it can reach 2.4 GB/sec.  The main RAM is only good for around 1.2 GB/sec so in practice "big" things don\'t move around any faster than 1.2 GB/sec on average. It\'s used to send graphics data from main memory to the other components.  It can be configured, but it\'s not programmable. It can do simple transfers, like "copy this block of data from here to there", and more complicated things, like following linked lists.'),(0,o.kt)("p",null,"The VU1 takes the role of vertex shaders. It can be programmed, but only in assembly, and it is extremely challenging and confusing. It has an extremely small memory (16 kB), but this memory is extremely fast. It's role is usually to do vertex transformations and lighting, then generate a list of commands to send to the GS.  The ",(0,o.kt)("inlineCode",{parentName:"p"},"XGKICK")," instruction on VU1 is used to send data from the VU1 memory to the GS."),(0,o.kt)("p",null,"The GS is the actual GPU. It has VRAM and receives commands from a few different places, including:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"VU1 ",(0,o.kt)("inlineCode",{parentName:"li"},"XGKICK"),"s stuff to it directly, bypassing the main bus used by DMAC/CPU memory access. This is called PATH 1 and is most commonly used in Jak 1."),(0,o.kt)("li",{parentName:"ul"},'When DMAing stuff to VU1, it first goes through a thing called VIF1 which can "unpack" data.  There is a special command that you can give to VIF1 which tells it to "send data directly to the GS".'),(0,o.kt)("li",{parentName:"ul"},"DMA sends data directly from EE main memory to GS (Path 3), unused by Jak 1")),(0,o.kt)("p",null,"The GS is like pixel shaders but it's very simple - it's not programmable and only can do a few fixed things. The GS also has the VRAM, which can contain frame buffers, z buffers, textures, and scratch area for effects."),(0,o.kt)("p",null,'My understanding is that during a frame, the EE generates a long list of things to draw. These are a DMA "chain" - basically a complicated linked-list like data structure that the PS2\'s DMA knows how to handle.  I believe some graphics calculations are done on the EE - particularly the environment mapping.'),(0,o.kt)("h2",{id:"dma"},"DMA"),(0,o.kt)("h2",{id:"display"},"Display"),(0,o.kt)("h2",{id:"texture"},"Texture"),(0,o.kt)("h2",{id:"collision-system"},"Collision System"),(0,o.kt)("h2",{id:"joint"},"Joint"),(0,o.kt)("h2",{id:"bsp"},"BSP"),(0,o.kt)("h2",{id:"merc-blend-shape"},"Merc Blend Shape"),(0,o.kt)("h2",{id:"ripple"},"Ripple"),(0,o.kt)("h2",{id:"bones"},"Bones"),(0,o.kt)("h2",{id:"generic-merc"},"Generic Merc"),(0,o.kt)("h2",{id:"generic-tie"},"Generic TIE"),(0,o.kt)("h2",{id:"shadow"},"Shadow"),(0,o.kt)("h2",{id:"font"},"Font"),(0,o.kt)("h2",{id:"decompression"},"Decompression"),(0,o.kt)("h2",{id:"background"},"Background"),(0,o.kt)("h2",{id:"draw-node-culling"},"Draw Node Culling"),(0,o.kt)("h2",{id:"shrubbery"},"Shrubbery"),(0,o.kt)("h2",{id:"tfrag"},"TFRAG"),(0,o.kt)("h2",{id:"tie"},"TIE"),(0,o.kt)("h2",{id:"particle"},"Particle"),(0,o.kt)("h2",{id:"time-of-day"},"Time of Day"),(0,o.kt)("h2",{id:"sky"},"Sky"),(0,o.kt)("h2",{id:"load-boundary"},"Load boundary"),(0,o.kt)("h2",{id:"sound"},"Sound"),(0,o.kt)("h2",{id:"controllers"},"Controllers"),(0,o.kt)("h2",{id:"iop-streaming"},"IOP Streaming"),(0,o.kt)("h2",{id:"ocean"},"Ocean"),(0,o.kt)("h2",{id:"navigate"},"Navigate"))}m.isMDXComponent=!0}}]);