"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[272],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=a,f=p["".concat(l,".").concat(h)]||p[h]||c[h]||i;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6020:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return c}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],s={sidebar_position:1},l="Graphics",d={unversionedId:"port-info/graphics",id:"port-info/graphics",title:"Graphics",description:"There are three frames in flight at a time:",source:"@site/documentation/port-info/graphics.md",sourceDirName:"port-info",slug:"/port-info/graphics",permalink:"/docs/port-info/graphics",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/port-info/graphics.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"PC Port Info",permalink:"/docs/category/pc-port-info"},next:{title:"drawable_and_tfrag",permalink:"/docs/port-info/drawable_and_tfrag"}},u={},c=[{value:"Synchronization",id:"synchronization",level:2},{value:"DMA Copy",id:"dma-copy",level:2},{value:"DMA Chain Iteration",id:"dma-chain-iteration",level:2},{value:"Buckets",id:"buckets",level:2},{value:"Textures",id:"textures",level:2},{value:"Shaders",id:"shaders",level:2},{value:"Direct Renderer",id:"direct-renderer",level:2},{value:"Mysteries",id:"mysteries",level:2}],p={toc:c};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"graphics"},"Graphics"),(0,i.kt)("p",null,"There are three frames in flight at a time:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'One frame being processed by the CPU, building DMA lists. This is called the "calc frame"'),(0,i.kt)("li",{parentName:"ul"},'One frame being processed by the GPU, going through the DMA lists and drawing triangles to one frame buffer. I will call this the "draw" frame.'),(0,i.kt)("li",{parentName:"ul"},'One frame being displayed on the screen, stored in the other frame buffer.  This is called the "on-screen" frame.')),(0,i.kt)("h2",{id:"synchronization"},"Synchronization"),(0,i.kt)("p",null,"The PC Port synchronizes on ",(0,i.kt)("inlineCode",{parentName:"p"},"syncv")," and on ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"syncv")," waits for an actual buffer swap and ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," waits for the renderer to finish."),(0,i.kt)("p",null,"The game's code for this is kind of messy and confusing, and calls ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," twice. On the PS2, you make sure rendering is done with ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path"),", which waits for the DMA chain to finish.  But they call this earlier than I think they need to, and I don't really understand why.  I don't see any place where they read back from the finished frame or depth buffer.  Or where they would overwrite the memory. There's a second call to ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," right where you would expect, imeediately before the ",(0,i.kt)("inlineCode",{parentName:"p"},"syncv"),".  After ",(0,i.kt)("inlineCode",{parentName:"p"},"syncv"),", they call some Sony library function to actually display the correct framebuffer, then immediately start sending the next DMA chain."),(0,i.kt)("p",null,"The stuff between ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"syncv")," is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'depth cue "calc" (seems fast)'),(0,i.kt)("li",{parentName:"ul"},'screen filter "calc" (very fast, just DMA for a single quad)'),(0,i.kt)("li",{parentName:"ul"},"calc for letterbox bars and blackout"),(0,i.kt)("li",{parentName:"ul"},"debug draw"),(0,i.kt)("li",{parentName:"ul"},"draw profiler (look at all the stuff that happens after!)"),(0,i.kt)("li",{parentName:"ul"},"deci count draw"),(0,i.kt)("li",{parentName:"ul"},"file info draw"),(0,i.kt)("li",{parentName:"ul"},"stdcon text draw"),(0,i.kt)("li",{parentName:"ul"},"iop/memcard info"),(0,i.kt)("li",{parentName:"ul"},"tie buffer init"),(0,i.kt)("li",{parentName:"ul"},"merc buffer init"),(0,i.kt)("li",{parentName:"ul"},"post draw hook (does nothing)"),(0,i.kt)("li",{parentName:"ul"},"bucket patching"),(0,i.kt)("li",{parentName:"ul"},"cache flush"),(0,i.kt)("li",{parentName:"ul"},"a second ",(0,i.kt)("inlineCode",{parentName:"li"},"sync-path"))),(0,i.kt)("p",null,"According to the Performance Analyzer, this takes about 1% to 2% of a frame.  They subtract off 4% of a frame from the profile bar so that 100% there is really around 96% of a frame, I guess to account for this extra time."),(0,i.kt)("p",null,"I'm really not sure why they have the first ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," there.  It makes some sense in debug mode so that you can draw the profile bar for the GPU after it has finished.  Another theory is that they didn't want debug code and non-debug rendering running at the same time - the debug code will compete with the rendering to use the main bus, and will make the rendering slower.  But it seems like you don't want this in the release version."),(0,i.kt)("p",null,"For now, the PC Port does sync on ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path"),", but it probably doesn't need to."),(0,i.kt)("h2",{id:"dma-copy"},"DMA Copy"),(0,i.kt)("p",null,"Starting the main graphics DMA chain is intercepted by the PC Port code.  In the GOAL thread, it iterates through the entire DMA chain and creates a copy. Then, it sends this copy to the graphics thread."),(0,i.kt)("p",null,"There are two reasons for copying:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If there is a memory bug in the game that corrupts the DMA buffer, it will not cause the renderer to crash. This is nice for debugging."),(0,i.kt)("li",{parentName:"ul"},"It will be easy to save this copied DMA chain to a file for debugging later.")),(0,i.kt)("p",null,"The DMA copier attempts to reduce the amount of memory used. It divides the 128MB of RAM into 128 kB chunks, marks which ones contain DMA data, then only copies those chunks. The chunks are compacted and the DMA pointers are updated to point to the relocated chunks."),(0,i.kt)("p",null,"This operation might be expensive and we might need to get rid of it later. But it would be easy to get rid of - the renderers themselves just read from a DMA chain and don't care if it is a copy or not."),(0,i.kt)("h2",{id:"dma-chain-iteration"},"DMA Chain Iteration"),(0,i.kt)("p",null,"On the C++ side, you can iterate through DMA with the ",(0,i.kt)("inlineCode",{parentName:"p"},"DmaFollower")," class.  Here is an example of flattening a DMA chain to a sequence of bytes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<u8> flatten_dma() {\n  DmaFollower state(memory, start_tag_addr);\n  std::vector<u8> result;\n  while (!state.ended()) {\n    // tag value:\n    state.current_tag();\n    // tag address\n    state.current_tag_offset();\n\n    // DMA data\n    auto read_result = state.read_and_advance();\n    // this is the transferred tag (u64 after dma tag, usually 2x vif tags)\n    u64 tag = read_result.transferred_tag;\n\n    // the actual bytes (pointer to data in the input chain)\n    result.insert(result.end(), read_result.data, read_result.data + read_result.size_bytes);\n  }\n  return result;\n}\n")),(0,i.kt)("p",null,"This will take care of following ",(0,i.kt)("inlineCode",{parentName:"p"},"call")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ret")," and those details."),(0,i.kt)("h2",{id:"buckets"},"Buckets"),(0,i.kt)("p",null,"The game builds the DMA chain in 69 buckets. Each bucket corresponds to a rendering pass.  In the OpenGLRenderer, you can designate a specific renderer for each bucket."),(0,i.kt)("p",null,"This can be set up in ",(0,i.kt)("inlineCode",{parentName:"p"},"init_bucket_renderers"),", and you can pass arguments to the renderers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'/*!\n * Construct bucket renderers.  We can specify different renderers for different buckets\n */\nvoid OpenGLRenderer::init_bucket_renderers() {\n\n  // create a DirectRenderer for each of these two buckets\n  init_bucket_renderer<DirectRenderer>("debug-draw-0", BucketId::DEBUG_DRAW_0, 1024 * 8);\n  init_bucket_renderer<DirectRenderer>("debug-draw-1", BucketId::DEBUG_DRAW_1, 1024 * 8);\n\n}\n')),(0,i.kt)("p",null,"Each bucket renderer will have access to shared data. For now, this is textures and shaders."),(0,i.kt)("h2",{id:"textures"},"Textures"),(0,i.kt)("p",null,"Currently, the only textures supported are those uploaded with ",(0,i.kt)("inlineCode",{parentName:"p"},"upload-now!"),", which does an immediate upload of the texture. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TexturePool")," receives the actual GOAL ",(0,i.kt)("inlineCode",{parentName:"p"},"texture-page")," object, and uses the metadata there to figure out how to convert the texture to RGBA8888."),(0,i.kt)("p",null,"It maintains a lookup table of converted textures by TBP which is used for fast lookup in the renderers."),(0,i.kt)("p",null,"This system isn't great yet, I think we will need to improve it for time-of-day textures and textures that are swapped in and out of VRAM."),(0,i.kt)("h2",{id:"shaders"},"Shaders"),(0,i.kt)("p",null,"The shaders themselves are stored in ",(0,i.kt)("inlineCode",{parentName:"p"},"opengl_renderer/shaders"),". They should be named with ",(0,i.kt)("inlineCode",{parentName:"p"},".frag")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".vert")," extensions."),(0,i.kt)("p",null,"To add a new shader, add it to ",(0,i.kt)("inlineCode",{parentName:"p"},"ShaderId")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"Shader.h")," and give it a name in ",(0,i.kt)("inlineCode",{parentName:"p"},"Shader.cpp"),". It will be compiled when the graphics system is loaded."),(0,i.kt)("h2",{id:"direct-renderer"},"Direct Renderer"),(0,i.kt)("p",null,"The direct renderer interprets GIF data directly. It is for rendering stuff that was set up entirely on the CPU, with no VU1 use."),(0,i.kt)("p",null,"Currently, the only known things that use this are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"debug stuff"),(0,i.kt)("li",{parentName:"ul"},"font"),(0,i.kt)("li",{parentName:"ul"},"screen filter/blackout/depth-cue"),(0,i.kt)("li",{parentName:"ul"},"the progress menu")),(0,i.kt)("p",null,"All of these cases are pretty simple, and this is nowhere near a full GS emulation. "),(0,i.kt)("p",null,"It does a single pass through the DMA chain and creates arrays of triangles. It is designed to reduce the number of OpenGL draw calls when consecutive primitives are drawn in the same mode."),(0,i.kt)("h2",{id:"mysteries"},"Mysteries"),(0,i.kt)("p",null,"Why did they put the first call to ",(0,i.kt)("inlineCode",{parentName:"p"},"sync-path")," in?"),(0,i.kt)("p",null,"How does the ",(0,i.kt)("inlineCode",{parentName:"p"},"upload-now!")," during texture login for near textures work? It seems like it writes too much and might write over the other level's texture."))}h.isMDXComponent=!0}}]);