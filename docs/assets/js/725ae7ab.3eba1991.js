"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[93],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return c}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,p=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),u=s(n),c=i,k=u["".concat(p,".").concat(c)]||u[c]||m[c]||l;return n?a.createElement(k,o(o({ref:t},d),{},{components:n})):a.createElement(k,o({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=u;var r={};for(var p in t)hasOwnProperty.call(t,p)&&(r[p]=t[p]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},417:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return c},frontMatter:function(){return r},metadata:function(){return s},toc:function(){return m}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),o=["components"],r={sidebar_position:4},p="Standard Library",s={unversionedId:"reference/lib",id:"reference/lib",title:"Standard Library",description:"Runtime Functions",source:"@site/documentation/reference/lib.md",sourceDirName:"reference",slug:"/reference/lib",permalink:"/docs/reference/lib",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/reference/lib.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"OpenGOAL Syntax & Examples",permalink:"/docs/reference/syntax"},next:{title:"Reader",permalink:"/docs/reference/reader"}},d={},m=[{value:"Runtime Functions",id:"runtime-functions",level:2},{value:"<code>string-&gt;symbol</code>",id:"string-symbol",level:3},{value:"<code>symbol-&gt;string</code>",id:"symbol-string",level:3},{value:"<code>format</code>",id:"format",level:3},{value:"<code>~%</code>",id:"",level:4},{value:"<code>~~</code>",id:"-1",level:4},{value:"<code>~G</code> or <code>~g</code>",id:"g-or-g",level:4},{value:"<code>~A</code> or <code>~a</code>",id:"a-or-a",level:4},{value:"<code>~S</code> or <code>~s</code>",id:"s-or-s",level:4},{value:"<code>~C</code> or <code>~c</code>",id:"c-or-c",level:4},{value:"<code>~P</code> or <code>~p</code>",id:"p-or-p",level:4},{value:"<code>~I</code> or <code>~i</code>",id:"i-or-i",level:4},{value:"<code>~Q</code> or <code>~q</code>",id:"q-or-q",level:4},{value:"<code>~B</code> or <code>~b</code>",id:"b-or-b",level:4},{value:"<code>~D</code> or <code>~d</code>",id:"d-or-d",level:4},{value:"<code>~X</code> or <code>~x</code>",id:"x-or-x",level:4},{value:"<code>~F</code>",id:"f",level:4},{value:"<code>~f</code>",id:"f-1",level:4},{value:"<code>~R</code> or <code>~r</code>",id:"r-or-r",level:4},{value:"<code>~M</code> or <code>~m</code>",id:"m-or-m",level:4},{value:"<code>~E</code> or <code>~e</code>",id:"e-or-e",level:4},{value:"<code>~T</code> or <code>~t</code>",id:"t-or-t",level:4},{value:"Pass Through Codes",id:"pass-through-codes",level:4},{value:"Block Forms",id:"block-forms",level:2},{value:"<code>begin</code>",id:"begin",level:3},{value:"<code>block</code>",id:"block",level:3},{value:"<code>return-from</code>",id:"return-from",level:3},{value:"<code>return</code>",id:"return",level:3},{value:"<code>label</code>",id:"label",level:3},{value:"<code>goto</code>",id:"goto",level:3},{value:"<code>top-level</code>",id:"top-level",level:3},{value:"Control Flow Forms",id:"control-flow-forms",level:2},{value:"GOAL &quot;Two Element&quot; Conditions",id:"goal-two-element-conditions",level:3},{value:"<code>not</code>",id:"not",level:3},{value:"<code>when-goto</code>",id:"when-goto",level:3},{value:"<code>cond</code>",id:"cond",level:3},{value:"<code>if</code>",id:"if",level:3},{value:"<code>when</code>",id:"when",level:3},{value:"<code>unless</code>",id:"unless",level:3},{value:"Definition Forms",id:"definition-forms",level:2},{value:"<code>set!</code>",id:"set",level:3},{value:"<code>define</code>",id:"define",level:3},{value:"<code>define-extern</code>",id:"define-extern",level:3},{value:"<code>let</code>",id:"let",level:3},{value:"<code>let*</code>",id:"let-1",level:3},{value:"Functions",id:"functions",level:2},{value:"<code>defun</code>",id:"defun",level:3},{value:"<code>defmethod</code>",id:"defmethod",level:3},{value:"<code>inline</code>",id:"inline",level:3},{value:"<code>lambda</code>",id:"lambda",level:3},{value:"<code>declare</code>",id:"declare",level:3},{value:"<code>local-vars</code>",id:"local-vars",level:3},{value:"Macro Forms",id:"macro-forms",level:2},{value:"<code>#cond</code>",id:"cond-1",level:3},{value:"<code>quote</code> / <code>&#39;</code>",id:"quote--",level:3},{value:"<code>defglobalconstant</code>",id:"defglobalconstant",level:3},{value:"<code>mlet</code>",id:"mlet",level:3},{value:"Math Forms",id:"math-forms",level:2},{value:"<code>+</code>",id:"-2",level:3},{value:"<code>-</code>",id:"-",level:3},{value:"<code>*</code>",id:"-3",level:3},{value:"<code>/</code>",id:"-4",level:3},{value:"<code>mod</code>",id:"mod",level:3},{value:"<code>slhv</code>, <code>sarv</code>, <code>shrv</code>",id:"slhv-sarv-shrv",level:3},{value:"<code>logand</code>",id:"logand",level:3},{value:"<code>logior</code>",id:"logior",level:3},{value:"<code>logxor</code>",id:"logxor",level:3},{value:"<code>lognot</code>",id:"lognot",level:3},{value:"Type Forms",id:"type-forms",level:2},{value:"<code>defmethod</code>",id:"defmethod-1",level:3},{value:"<code>deftype</code>",id:"deftype",level:3},{value:"<code>method-of-object</code>",id:"method-of-object",level:3},{value:"<code>method-of-type</code>",id:"method-of-type",level:3},{value:"<code>car</code> and <code>cdr</code>",id:"car-and-cdr",level:3},{value:"<code>new</code>",id:"new",level:3},{value:"<code>print-type</code>",id:"print-type",level:3},{value:"<code>the</code>",id:"the",level:3},{value:"<code>the-as</code>",id:"the-as",level:3},{value:"<code>size-of</code>",id:"size-of",level:3},{value:"Pointer Math",id:"pointer-math",level:3},{value:"Inline Assembly Forms",id:"inline-assembly-forms",level:2},{value:"<code>rlet</code>",id:"rlet",level:3},{value:"<code>.sub</code>",id:"sub",level:3},{value:"<code>.add</code>",id:"add",level:3},{value:"<code>.jr</code>",id:"jr",level:3},{value:"<code>.load-sym</code>",id:"load-sym",level:3},{value:"<code>.push</code>",id:"push",level:3},{value:"<code>.pop</code>",id:"pop",level:3},{value:"<code>.ret</code>",id:"ret",level:3},{value:"<code>.mov</code>",id:"mov",level:3},{value:"<code>.nop.vf</code>",id:"nopvf",level:3},{value:"<code>.nop</code> or <code>(nop!)</code>",id:"nop-or-nop",level:3},{value:"<code>.wait.vf</code>",id:"waitvf",level:3},{value:"<code>.lvf</code>",id:"lvf",level:3},{value:"<code>.svf</code>",id:"svf",level:3},{value:"Three operand vector float operations.",id:"three-operand-vector-float-operations",level:3},{value:"Three operand vector float operations with the accumulator",id:"three-operand-vector-float-operations-with-the-accumulator",level:3},{value:"<code>.abs.vf</code>",id:"absvf",level:3},{value:"<code>.div.vf</code> and <code>.sqrt.vf</code>",id:"divvf-and-sqrtvf",level:3},{value:"<code>.outer.product.vf</code>",id:"outerproductvf",level:3},{value:"<code>.blend.vf</code>",id:"blendvf",level:3},{value:"<code>.itof.vf</code> and <code>.ftoi.vf</code>",id:"itofvf-and-ftoivf",level:3},{value:"<code>.pw.sra</code>, <code>.pw.srl</code>, and <code>pw.sll</code>",id:"pwsra-pwsrl-and-pwsll",level:3},{value:"<code>.pextlw</code>, <code>.pextuw</code>, <code>.pcpyud</code>, <code>.pcpyld</code>, <code>.pceqw</code>, <code>.ppach</code>",id:"pextlw-pextuw-pcpyud-pcpyld-pceqw-ppach",level:3},{value:"TODO",id:"todo",level:2},{value:"Things related to enums",id:"things-related-to-enums",level:3},{value:"<code>defmacro</code>",id:"defmacro",level:3},{value:"Loop forms",id:"loop-forms",level:3},{value:"<code>&amp;</code>",id:"-5",level:3},{value:"<code>-&gt;</code>",id:"--1",level:3},{value:"Type",id:"type",level:3},{value:"Compile-Time Size stuff",id:"compile-time-size-stuff",level:3},{value:"<code>object-new</code>",id:"object-new",level:3}],u={toc:m};function c(e){var t=e.components,n=(0,i.Z)(e,o);return(0,l.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"standard-library"},"Standard Library"),(0,l.kt)("h2",{id:"runtime-functions"},"Runtime Functions"),(0,l.kt)("h3",{id:"string-symbol"},(0,l.kt)("inlineCode",{parentName:"h3"},"string->symbol")),(0,l.kt)("h3",{id:"symbol-string"},(0,l.kt)("inlineCode",{parentName:"h3"},"symbol->string")),(0,l.kt)("h3",{id:"format"},(0,l.kt)("inlineCode",{parentName:"h3"},"format")),(0,l.kt)("p",null,"GOAL's ",(0,l.kt)("inlineCode",{parentName:"p"},"printf"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(format destination format-string args...)\n")),(0,l.kt)("p",null,"The following destinations are currently supported:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"#t")," - print to the listener. After the current game frame is over, this will be sent to the compiler and you can see it at the GOAL prompt."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"0")," - print to ",(0,l.kt)("inlineCode",{parentName:"li"},"stdout")," in the runtime immediately. This won't be visible from within the compiler - you must look at the runtime to see it. This is useful for debugging if the runtime crashes before flushing the normal print buffer."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"#f")," - print to a new string allocated on the global heap."),(0,l.kt)("li",{parentName:"ul"},"a GOAL ",(0,l.kt)("inlineCode",{parentName:"li"},"string")," object - append to an existing string"),(0,l.kt)("li",{parentName:"ul"},"a GOAL ",(0,l.kt)("inlineCode",{parentName:"li"},"file-stream")," object - currently unsupported but eventually may allow printing into a file somewhere")),(0,l.kt)("p",null,"The global variable ",(0,l.kt)("inlineCode",{parentName:"p"},"*print-column*")," can be used to automatically print at a certain indentation. The very first thing printed during a frame will not have the indentation applied."),(0,l.kt)("p",null,"The format string escape sequences all start with ",(0,l.kt)("inlineCode",{parentName:"p"},"~"),", then have arguments (possibly none), then have a single character code. The arguments look like:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"~A"),", the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," code with no arguments"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"~12A"),", the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," code with an integer argument of ",(0,l.kt)("inlineCode",{parentName:"li"},"12")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"~'zA"),", the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," code with a character argument of ",(0,l.kt)("inlineCode",{parentName:"li"},"z")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"}," ~`hello`A"),", the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," code with a string argument of ",(0,l.kt)("inlineCode",{parentName:"li"},'"hello"')),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"~12,'bA"),", the ",(0,l.kt)("inlineCode",{parentName:"li"},"A")," code with two arguments, integer ",(0,l.kt)("inlineCode",{parentName:"li"},"12")," and character ",(0,l.kt)("inlineCode",{parentName:"li"},"b"))),(0,l.kt)("p",null,"The escape codes are:"),(0,l.kt)("h4",{id:""},(0,l.kt)("inlineCode",{parentName:"h4"},"~%")),(0,l.kt)("p",null,"Replace with a newline character."),(0,l.kt)("h4",{id:"-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"~~")),(0,l.kt)("p",null,"Replace with a ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," character"),(0,l.kt)("h4",{id:"g-or-g"},(0,l.kt)("inlineCode",{parentName:"h4"},"~G")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~g")),(0,l.kt)("p",null,"Replace with a C-style string given in ",(0,l.kt)("inlineCode",{parentName:"p"},"args"),". Note that this will not work on a GOAL string."),(0,l.kt)("h4",{id:"a-or-a"},(0,l.kt)("inlineCode",{parentName:"h4"},"~A")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~a")),(0,l.kt)("p",null,"Print a boxed object given in ",(0,l.kt)("inlineCode",{parentName:"p"},"args"),". Uses the ",(0,l.kt)("inlineCode",{parentName:"p"},"print")," method. Can take optional arguments for length and padding character. If the ",(0,l.kt)("inlineCode",{parentName:"p"},"print")," method gives something shorter than the length argument, it will be padded on the left with the padding character (default is space). If the ",(0,l.kt)("inlineCode",{parentName:"p"},"print")," method gives something too long, it will be truncated on the right. The last character printed will be changed to ",(0,l.kt)("inlineCode",{parentName:"p"},"~")," to indicate it was truncated here."),(0,l.kt)("p",null,"There is an option to left justify instead but I don't think there's a way to turn it on."),(0,l.kt)("h4",{id:"s-or-s"},(0,l.kt)("inlineCode",{parentName:"h4"},"~S")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~s")),(0,l.kt)("p",null,"Very similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"~A"),", but a GOAL string will be printed without quotes around it."),(0,l.kt)("h4",{id:"c-or-c"},(0,l.kt)("inlineCode",{parentName:"h4"},"~C")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~c")),(0,l.kt)("p",null,"Print a single character (GOAL ",(0,l.kt)("inlineCode",{parentName:"p"},"uint8")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"int8")," type)"),(0,l.kt)("h4",{id:"p-or-p"},(0,l.kt)("inlineCode",{parentName:"h4"},"~P")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~p")),(0,l.kt)("p",null,"Print an object, similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"~A"),", but does not have optional arguments for length or padding. Instead, there is an optional argument to give a type name, then use that types ",(0,l.kt)("inlineCode",{parentName:"p"},"print")," method. This is useful for printing non-boxed objects. If no type name is given, behaves like ",(0,l.kt)("inlineCode",{parentName:"p"},"~A"),"."),(0,l.kt)("h4",{id:"i-or-i"},(0,l.kt)("inlineCode",{parentName:"h4"},"~I")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~i")),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"~P"),", but uses the inspect method instead."),(0,l.kt)("h4",{id:"q-or-q"},(0,l.kt)("inlineCode",{parentName:"h4"},"~Q")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~q")),(0,l.kt)("p",null,"Likely was supposed to be for printing 128-bit integers stored in registers, but will always prints ",(0,l.kt)("inlineCode",{parentName:"p"},"0"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"format")," function is written in C using varargs, which doesn't support 128-bit register values."),(0,l.kt)("h4",{id:"b-or-b"},(0,l.kt)("inlineCode",{parentName:"h4"},"~B")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~b")),(0,l.kt)("p",null,"Print integer as binary. Optional arguments for pad-length and pad-character (default is 0). Won't truncate."),(0,l.kt)("h4",{id:"d-or-d"},(0,l.kt)("inlineCode",{parentName:"h4"},"~D")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~d")),(0,l.kt)("p",null,"Print integer as decimal (signed). Optional arguments for pad-length and pad-character (default is space). Won't truncate."),(0,l.kt)("h4",{id:"x-or-x"},(0,l.kt)("inlineCode",{parentName:"h4"},"~X")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~x")),(0,l.kt)("p",null,"Print integer as hex. Optional arguments for pad-length and pad-character (default is 0). Won't truncate."),(0,l.kt)("h4",{id:"f"},(0,l.kt)("inlineCode",{parentName:"h4"},"~F")),(0,l.kt)("p",null,"Print floating point. Will print 4 digits after the decimal and pad with space to a width of 12 and does not accept any options."),(0,l.kt)("h4",{id:"f-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"~f")),(0,l.kt)("p",null,"Print floating point. Takes optional arguments for pad-length (default don't pad), pad-character (default space), and precision (default 4)."),(0,l.kt)("h4",{id:"r-or-r"},(0,l.kt)("inlineCode",{parentName:"h4"},"~R")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~r")),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"~f")," but scales in-game rotation units to degrees. The float ",(0,l.kt)("inlineCode",{parentName:"p"},"65536.0")," is 360 degrees."),(0,l.kt)("h4",{id:"m-or-m"},(0,l.kt)("inlineCode",{parentName:"h4"},"~M")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~m")),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"~f")," but scales in-game distance units to meters. The float ",(0,l.kt)("inlineCode",{parentName:"p"},"4096.0")," is 1 meter."),(0,l.kt)("h4",{id:"e-or-e"},(0,l.kt)("inlineCode",{parentName:"h4"},"~E")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~e")),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"~f")," for argument, but takes an integer time-code as an input and scales time-code units to seconds. There are 300 ticks / second, which is the smallest number which has an integer number of ticks per NTSC and PAL frame. Something very weird happens when the input is negative?"),(0,l.kt)("h4",{id:"t-or-t"},(0,l.kt)("inlineCode",{parentName:"h4"},"~T")," or ",(0,l.kt)("inlineCode",{parentName:"h4"},"~t")),(0,l.kt)("p",null,"Insert a tab character."),(0,l.kt)("h4",{id:"pass-through-codes"},"Pass Through Codes"),(0,l.kt)("p",null,"Some codes will be passed through automatically, along with any arguments. This will also pass through arguments of ",(0,l.kt)("inlineCode",{parentName:"p"},"+")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"-"),". I believe that these options could later be interpreted by the code for printing on-screen characters."),(0,l.kt)("p",null,"The pass through codes are ",(0,l.kt)("inlineCode",{parentName:"p"},"H,J,K,L,N,V,W,Y,Z,h,j,k,l,n,v,w,y,z"),"."),(0,l.kt)("p",null,"Any other codes will result in an error message being printed."),(0,l.kt)("h2",{id:"block-forms"},"Block Forms"),(0,l.kt)("h3",{id:"begin"},(0,l.kt)("inlineCode",{parentName:"h3"},"begin")),(0,l.kt)("p",null,"Execute forms in order."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(begin form...)\n")),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"begin")," form is just a list of other forms which are executed in order. A ",(0,l.kt)("inlineCode",{parentName:"p"},"begin")," form evaluates to the value of the last form."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(begin\n  (print "hello ")\n  (print "world!")\n  7\n  )\n')),(0,l.kt)("p",null,"will print ",(0,l.kt)("inlineCode",{parentName:"p"},"hello world!")," and the value of the entire form is ",(0,l.kt)("inlineCode",{parentName:"p"},"7"),"."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"begin")," form is used a lot in macros, but not that much in code. It's generally used when you want to execute multiple things, but fit it into a single form."),(0,l.kt)("h3",{id:"block"},(0,l.kt)("inlineCode",{parentName:"h3"},"block")),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"block")," form is pretty similar to a ",(0,l.kt)("inlineCode",{parentName:"p"},"begin"),", except the ",(0,l.kt)("inlineCode",{parentName:"p"},"block"),' has a name. You can then "return" from the block early with ',(0,l.kt)("inlineCode",{parentName:"p"},"return-from"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(block block-name form...)\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(block my-block\n  (print "hello ")\n  (return-from my-block 7)\n  (print "world")\n  "test"\n  )\n')),(0,l.kt)("p",null,"will print ",(0,l.kt)("inlineCode",{parentName:"p"},"hello ")," only and the value of the entire ",(0,l.kt)("inlineCode",{parentName:"p"},"block")," form is ",(0,l.kt)("inlineCode",{parentName:"p"},"7"),". The type of the ",(0,l.kt)("inlineCode",{parentName:"p"},"block")," is the most specific type that describes all of the possible return values from any ",(0,l.kt)("inlineCode",{parentName:"p"},"return-from")," or from reaching the end (even if its technically not possible to reach the end). In the case above, the possible return types are ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"string"),", so the return type of the whole block is ",(0,l.kt)("inlineCode",{parentName:"p"},"object"),", the lowest common ancestor type of ",(0,l.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,l.kt)("p",null,"Block is used rarely, and possibly almost never?"),(0,l.kt)("h3",{id:"return-from"},(0,l.kt)("inlineCode",{parentName:"h3"},"return-from")),(0,l.kt)("p",null,"Exit a ",(0,l.kt)("inlineCode",{parentName:"p"},"block")," or function early."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(return-from block-name value)\n")),(0,l.kt)("p",null,"Looks up the block and exits from it with the value. You can exit out nested blocks. If you are enclosed in multiple blocks with the same name, exits from the inner-most one with a matching name. Everything in a function is wrapped in a block named ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),", so you can use ",(0,l.kt)("inlineCode",{parentName:"p"},"(return-from #f x)")," to return early from a function with ",(0,l.kt)("inlineCode",{parentName:"p"},"x"),". When using this form, it may change the return type of the function or block. The return type will be the lowest common ancestor type of all written return paths. If there is an unreachable return path, it will still be considered."),(0,l.kt)("p",null,"Example"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if (is-a-match? x)\n  (return-from #f x)\n  )\n")),(0,l.kt)("p",null,"if ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is a match, returns ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," from the function (not shown) immediately."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"return-from")," form is very rarely used to return from a block, but sometimes used to return from a function."),(0,l.kt)("h3",{id:"return"},(0,l.kt)("inlineCode",{parentName:"h3"},"return")),(0,l.kt)("p",null,"Exit a function early."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(return value)\n")),(0,l.kt)("p",null,"Has the same behavior as ",(0,l.kt)("inlineCode",{parentName:"p"},"(return-from #f value)"),"."),(0,l.kt)("h3",{id:"label"},(0,l.kt)("inlineCode",{parentName:"h3"},"label")),(0,l.kt)("p",null,"Create a named label for ",(0,l.kt)("inlineCode",{parentName:"p"},"goto")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"goto-when"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(label label-name)\n")),(0,l.kt)("p",null,"The label spaces are per-function and not nested. You can't jump from function to function. You can't jump in or out of functions which end up getting inlined. You can't jump in or out of an anonymous lambda function. You can jump in and out of ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),"s."),(0,l.kt)("p",null,"See ",(0,l.kt)("inlineCode",{parentName:"p"},"goto")," for an example."),(0,l.kt)("p",null,"Labels are used extremely rarely. Usually only in inline assembly and part of macros for ",(0,l.kt)("inlineCode",{parentName:"p"},"while")," loops and similar."),(0,l.kt)("h3",{id:"goto"},(0,l.kt)("inlineCode",{parentName:"h3"},"goto")),(0,l.kt)("p",null,"Jump to a label."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(goto label-name)\n")),(0,l.kt)("p",null,"The label must be in the current label space. You can jump forward or backward."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if skip-code?\n  (goto end)\n  )\n\n;; code here runs only if skip-code is false.\n\n(label end)\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"goto")," form used very rarely outside of macros and inline assembly. Try to avoid using ",(0,l.kt)("inlineCode",{parentName:"p"},"goto"),"."),(0,l.kt)("h3",{id:"top-level"},(0,l.kt)("inlineCode",{parentName:"h3"},"top-level")),(0,l.kt)("p",null,"This form is reserved by the compiler. Internally all forms in a file are grouped under a ",(0,l.kt)("inlineCode",{parentName:"p"},"top-level")," form, so you may see this in error messages. Do not name anything ",(0,l.kt)("inlineCode",{parentName:"p"},"top-level"),"."),(0,l.kt)("h2",{id:"control-flow-forms"},"Control Flow Forms"),(0,l.kt)("h3",{id:"goal-two-element-conditions"},'GOAL "Two Element" Conditions'),(0,l.kt)("p",null,"These are ",(0,l.kt)("inlineCode",{parentName:"p"},"!="),", ",(0,l.kt)("inlineCode",{parentName:"p"},"eq?"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"neq?"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"="),", ",(0,l.kt)("inlineCode",{parentName:"p"},">"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,l.kt)("inlineCode",{parentName:"p"},">="),", ",(0,l.kt)("inlineCode",{parentName:"p"},"<="),". The default is to compare the two objects as unsigned 64-bit integers, unless a special case is hit. The special case is determined by the type of the ",(0,l.kt)("strong",{parentName:"p"},"first")," argument:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Floating point: if second argument is a number, convert to floating point. Use floating point comparisons"),(0,l.kt)("li",{parentName:"ul"},"Binteger: convert first argument to integer. If second argument is a number, convert to integer. Use signed integer comparisons"),(0,l.kt)("li",{parentName:"ul"},"Integer: If second argument is a number, convert to integer. Use signed integer comparison"),(0,l.kt)("li",{parentName:"ul"},"Unsigned Integer: If second argument is a number, convert to integer. Use unsigned integer comparison")),(0,l.kt)("p",null,"Note that comparing structures just checks if they refer to the same memory, not if the contents are the same."),(0,l.kt)("p",null,"Currently there is absolutely no type checking done on comparisons, which makes it quite easy to get things wrong."),(0,l.kt)("p",null,"When a two-element condition is used as a condition for an ",(0,l.kt)("inlineCode",{parentName:"p"},"if"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"while"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"goto-when"),", or any other branching condition, there is an optimization that avoids computing a GOAL boolean, then checking that GOAL boolean as a branch condition. Instead the comparison operation directly sets the x86-64 flags for a jump. Original GOAL has a similar optimization."),(0,l.kt)("p",null,"There are a lot of unknown details"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"What order are things evaluated / converted?"),(0,l.kt)("li",{parentName:"ul"},"How does the order work when there's a ",(0,l.kt)("inlineCode",{parentName:"li"},"not"),"?"),(0,l.kt)("li",{parentName:"ul"},"Type Checking is probably needed."),(0,l.kt)("li",{parentName:"ul"},"Currently ",(0,l.kt)("inlineCode",{parentName:"li"},"=")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"eq?")," are exactly the same. Likely ",(0,l.kt)("inlineCode",{parentName:"li"},"=")," should only work on numbers and ",(0,l.kt)("inlineCode",{parentName:"li"},"eq?")," should work on references?")),(0,l.kt)("h3",{id:"not"},(0,l.kt)("inlineCode",{parentName:"h3"},"not")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(not value)\n")),(0,l.kt)("p",null,"If value is ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),", return ",(0,l.kt)("inlineCode",{parentName:"p"},"#t"),". Otherwise return ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"."),(0,l.kt)("p",null,"Using ",(0,l.kt)("inlineCode",{parentName:"p"},"not"),' on a "two element condition" will be optimized to modifying that condition.'),(0,l.kt)("h3",{id:"when-goto"},(0,l.kt)("inlineCode",{parentName:"h3"},"when-goto")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(when-goto value-or-condition destination)\n")),(0,l.kt)("p",null,"Examples:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(when-goto (> x y) some-label)\n(when-goto (is-player-dead?) some-label)\n")),(0,l.kt)("p",null,"Jump to ",(0,l.kt)("inlineCode",{parentName:"p"},"destination")," if the condition is truthy (not ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"). This ends up generating much better code than ",(0,l.kt)("inlineCode",{parentName:"p"},"(if condition (goto x))"),"."),(0,l.kt)("p",null,"Like normal ",(0,l.kt)("inlineCode",{parentName:"p"},"goto"),", this isn't used much outside of macros."),(0,l.kt)("h3",{id:"cond"},(0,l.kt)("inlineCode",{parentName:"h3"},"cond")),(0,l.kt)("p",null,"A normal Lisp/Scheme ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(cond (test clause...)...)\n")),(0,l.kt)("p",null,"Evaluates ",(0,l.kt)("inlineCode",{parentName:"p"},"test"),"s until one is truthy. Then evaluates all ",(0,l.kt)("inlineCode",{parentName:"p"},"clause"),"s in that case and returns the value of the last one. Optionally there can be a case with ",(0,l.kt)("inlineCode",{parentName:"p"},"else")," as the test which runs if no other cases match. This must be the last case."),(0,l.kt)("p",null,"If there is no ",(0,l.kt)("inlineCode",{parentName:"p"},"else"),", and no cases match, return ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),". (is it always ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"?)"),(0,l.kt)("p",null,"The return type is the lowest common ancestor type of all cases. Note that for a ",(0,l.kt)("inlineCode",{parentName:"p"},"cond")," without ",(0,l.kt)("inlineCode",{parentName:"p"},"else"),", the possible return value of ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," is ",(0,l.kt)("strong",{parentName:"p"},"not")," considered when determining the return type. So:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(print-type\n  (cond (test1 "hi") (test2 "bye"))\n  )\n')),(0,l.kt)("p",null,"will print ",(0,l.kt)("inlineCode",{parentName:"p"},"[TYPE] string"),", even though ",(0,l.kt)("inlineCode",{parentName:"p"},"cond")," may return ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"."),(0,l.kt)("p",null,"This behavior seems correct if the return value is a ",(0,l.kt)("inlineCode",{parentName:"p"},"basic"),", but less clear if the return value is supposed to be a number."),(0,l.kt)("p",null,"Note that GOAL will load ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," into a register for an else case even if the value of the ",(0,l.kt)("inlineCode",{parentName:"p"},"cond")," is never used. Also, even if the value of the ",(0,l.kt)("inlineCode",{parentName:"p"},"cond")," is never used, all cases will store their result into a common ",(0,l.kt)("inlineCode",{parentName:"p"},"cond")," return-register. This is incredibly helpful for the decompiler!"),(0,l.kt)("h3",{id:"if"},(0,l.kt)("inlineCode",{parentName:"h3"},"if")),(0,l.kt)("p",null,"A normal Lisp/Scheme ",(0,l.kt)("inlineCode",{parentName:"p"},"if"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(if test true-case [false-case])\n")),(0,l.kt)("p",null,"The value of the entire statement is the value of the taken case. The false case can be left out. If the condition evaluates to false and the false case is left out, ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," is returned. The return type follows the same logic as ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),", as ",(0,l.kt)("inlineCode",{parentName:"p"},"if")," is a macro using ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),"."),(0,l.kt)("h3",{id:"when"},(0,l.kt)("inlineCode",{parentName:"h3"},"when")),(0,l.kt)("p",null,"A normal Lisp/Scheme ",(0,l.kt)("inlineCode",{parentName:"p"},"when"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(when test forms...)\n")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"test")," is truthy, evaluate all forms and return the value of the last one. If ",(0,l.kt)("inlineCode",{parentName:"p"},"test")," isn't true, return ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"."),(0,l.kt)("h3",{id:"unless"},(0,l.kt)("inlineCode",{parentName:"h3"},"unless")),(0,l.kt)("p",null,"A normal Lisp/Scheme ",(0,l.kt)("inlineCode",{parentName:"p"},"unless"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(unless test forms...)\n")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"test")," is false, evaluate all forms and return the value of the last one. If ",(0,l.kt)("inlineCode",{parentName:"p"},"test")," isn't false, return ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),"."),(0,l.kt)("h2",{id:"definition-forms"},"Definition Forms"),(0,l.kt)("h3",{id:"set"},(0,l.kt)("inlineCode",{parentName:"h3"},"set!")),(0,l.kt)("p",null,"Set a value!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(set! place value)\n")),(0,l.kt)("p",null,"Sets ",(0,l.kt)("inlineCode",{parentName:"p"},"place")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"place")," can be once of:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A lexical variable defined by ",(0,l.kt)("inlineCode",{parentName:"li"},"let"),", or an argument of a function"),(0,l.kt)("li",{parentName:"ul"},"A global symbol"),(0,l.kt)("li",{parentName:"ul"},"A ",(0,l.kt)("inlineCode",{parentName:"li"},"car")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"cdr")," of a pair"),(0,l.kt)("li",{parentName:"ul"},"A field of an object"),(0,l.kt)("li",{parentName:"ul"},"A dereferenced pointer"),(0,l.kt)("li",{parentName:"ul"},"An element in an array"),(0,l.kt)("li",{parentName:"ul"},"A bitfield within any of the above (not yet implemented)")),(0,l.kt)("h3",{id:"define"},(0,l.kt)("inlineCode",{parentName:"h3"},"define")),(0,l.kt)("p",null,"Define a global symbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(define symbol-name value)\n")),(0,l.kt)("p",null,"Kind of like ",(0,l.kt)("inlineCode",{parentName:"p"},"set!"),", but works exclusively on global symbols. Also sets the type of the global symbol. If the global symbol already has a type, and the ",(0,l.kt)("inlineCode",{parentName:"p"},"define")," tries to change it, there will be an error or warning. (to be determined)"),(0,l.kt)("h3",{id:"define-extern"},(0,l.kt)("inlineCode",{parentName:"h3"},"define-extern")),(0,l.kt)("p",null,"Inform the compiler about the type of a global symbol"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(define-extern symbol-name type)\n")),(0,l.kt)("p",null,"Useful to forward declare functions or to let the compiler know about things in the C Kernel. See ",(0,l.kt)("inlineCode",{parentName:"p"},"goal-externs.gc")," for where all the C Kernel stuff is declared."),(0,l.kt)("h3",{id:"let"},(0,l.kt)("inlineCode",{parentName:"h3"},"let")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((var-name value)...) body...)\n")),(0,l.kt)("p",null,"Define local variables. The variables are automatically assigned a type, like C++ ",(0,l.kt)("inlineCode",{parentName:"p"},"auto"),"."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(let ((count-1 (+ a b))   ;; count_1 = a + b\n      (count-2 (+ c d)))  ;; count_2 = c + d\n  (if (count > 10)\n    ;; print a message if count > 10.\n    (format #t "count = ~D, ~D~%" count-1 count-2)\n    )\n  )\n')),(0,l.kt)("p",null,"Note, if you define multiple variables in a ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),", you cannot refer to variables defined previously in the same ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),". In the example above, ",(0,l.kt)("inlineCode",{parentName:"p"},"count-2"),"'s value couldn't be defined in terms of ",(0,l.kt)("inlineCode",{parentName:"p"},"count-1")," for example. See ",(0,l.kt)("inlineCode",{parentName:"p"},"let*"),"."),(0,l.kt)("h3",{id:"let-1"},(0,l.kt)("inlineCode",{parentName:"h3"},"let*")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((var-name value)...) body...)\n")),(0,l.kt)("p",null,"Define local variables. If you define multiple in a single ",(0,l.kt)("inlineCode",{parentName:"p"},"let*"),", you can refer to previous variables."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(let* ((count-1 (+ a b))\n       (count-2 (+ count-1 d)))  ;; okay because we used let*\n  (if (count > 10)\n    ;; print a message if count > 10.\n    (format #t "count = ~D, ~D~%" count-1 count-2)\n    )\n  )\n')),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("h3",{id:"defun"},(0,l.kt)("inlineCode",{parentName:"h3"},"defun")),(0,l.kt)("p",null,"Define a new named global function!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(defun name arg-list ["doc-string"] body...)\narg-list = (arg...)\narg = (arg-name arg-type)|arg-name\n')),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(defun 1/ ((x float))\n  "Compute 1.0 / x"\n  (/ 1.0 x)\n  )\n')),(0,l.kt)("p",null,"Define a new function with the given name. Note that until the ",(0,l.kt)("inlineCode",{parentName:"p"},"defun")," itself executes, the function ",(0,l.kt)("strong",{parentName:"p"},"cannot be used!"),". So don't call functions before the ",(0,l.kt)("inlineCode",{parentName:"p"},"defun"),". This is unlike C, where you can forward declare a function and use it before the actual definition."),(0,l.kt)("p",null,"There is an optional docstring. Currently the docstring is just thrown away but in the future we could save them and and generate documentation or something."),(0,l.kt)("h3",{id:"defmethod"},(0,l.kt)("inlineCode",{parentName:"h3"},"defmethod")),(0,l.kt)("p",null,"Define a method!"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(defmethod method-name type-name arg-list ["doc-string"] body...)\n')),(0,l.kt)("p",null,"In many ways is similar to ",(0,l.kt)("inlineCode",{parentName:"p"},"defun"),". See section on methods for more details."),(0,l.kt)("p",null,"You can only ",(0,l.kt)("inlineCode",{parentName:"p"},"defmethod")," if one of these two is true:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"You are overriding a parent method"),(0,l.kt)("li",{parentName:"ul"},"You have declared this method in the type's ",(0,l.kt)("inlineCode",{parentName:"li"},"deftype"))),(0,l.kt)("p",null,"Like ",(0,l.kt)("inlineCode",{parentName:"p"},"defun"),", the method only exists after the ",(0,l.kt)("inlineCode",{parentName:"p"},"defmethod")," executes. Before that the method may be undefined or the parent's method."),(0,l.kt)("h3",{id:"inline"},(0,l.kt)("inlineCode",{parentName:"h3"},"inline")),(0,l.kt)("p",null,"Make this function call inlined."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(inline function-name)\n")),(0,l.kt)("p",null,"Example: inline call ",(0,l.kt)("inlineCode",{parentName:"p"},"my-function")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"((inline my-function) my-arg)\n")),(0,l.kt)("p",null,"Attempts to make the function call inline. If it is not possible, it will throw an error. You can't save the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"(inline my-function)"),", only use it immediately in a function call. You must provide a name of a global function as the function, not a function pointer."),(0,l.kt)("p",null,"Methods cannot be inlined. (Maybe new methods can be in original GOAL?)"),(0,l.kt)("h3",{id:"lambda"},(0,l.kt)("inlineCode",{parentName:"h3"},"lambda")),(0,l.kt)("p",null,"Create a GOAL Lambda."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lambda [:name name] [:inline-only #f|#t] [:segment main|debug] arg-list body-form..)\narg-list = (arg...)\narg = (arg-name arg-type)|arg-name\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},":name")," option is only used for debugging the compiler - it cannot be accessed or referenced outside of internal compiler debugging features. It should be ignored unless you are debugging the compiler."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},":inline-only")," flag defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),", but can be set to ",(0,l.kt)("inlineCode",{parentName:"p"},"#t")," to force the compiler to not generate x86-64 code for the function. In this case, the lambda cannot be used as a function pointer/GOAL ",(0,l.kt)("inlineCode",{parentName:"p"},"function")," object. This is used in the ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," macro and not really useful for general programming. If the flag is ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," (default value), it will generate and store an x86-64 function, regardless of if the function is ever called."),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},":segment")," option defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"main"),", unless the ",(0,l.kt)("inlineCode",{parentName:"p"},"lambda")," is defined in a function in the ",(0,l.kt)("inlineCode",{parentName:"p"},"debug")," segment, in which case it defaults to ",(0,l.kt)("inlineCode",{parentName:"p"},"debug"),". It can be overridden by this flag. This picks the segment of the object file where the function will be stored."),(0,l.kt)("p",null,"The arguments default to type of ",(0,l.kt)("inlineCode",{parentName:"p"},"object")," if no type is provided. In the case where a lambda is used immediately (a ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),") the compiler will propagate more specific types. This is why you don't have to give types when using ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),"."),(0,l.kt)("p",null,"A GOAL lambda has three purposes:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},'Generate a function as a "real" x86-64 function.'),(0,l.kt)("li",{parentName:"ol"},"Save the code so the function can later be inlined"),(0,l.kt)("li",{parentName:"ol"},"Immediately use the lambda in the head of a list as part of a ",(0,l.kt)("inlineCode",{parentName:"li"},"let")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"let*")," macro")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example of 1:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"(sort my-list (lambda ((x int) (y int) (< x y))))\n")),(0,l.kt)("p",null,"We create a real x86-64 function to pass to the ",(0,l.kt)("inlineCode",{parentName:"p"},"sort")," function. In this case you should specify types - the default of ",(0,l.kt)("inlineCode",{parentName:"p"},"object")," is not suitable."),(0,l.kt)("p",null,"The other two cases are handled by ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"defun")," macros, and shouldn't show up in other places, so they are left out."),(0,l.kt)("h3",{id:"declare"},(0,l.kt)("inlineCode",{parentName:"h3"},"declare")),(0,l.kt)("p",null,"Set options for a function or method"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(declare [(inline)] [(allow-inline)] [(disallow-inline)] [(asm-func return-typespec)] [(print-asm)])\n")),(0,l.kt)("p",null,"If used, this should be the first thing inside of a ",(0,l.kt)("inlineCode",{parentName:"p"},"defun"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"defmethod"),". Don't use it anywhere else.\nExample:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(defun my-function ()\n  (declare (inline))\n  ...\n  )\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"inline"),' means "inline whenever possible". See function inlining section for why inlining may be impossible in some cases.'),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allow-inline")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"disallow-inline"),". You can control if inlining is allowed, though it is not clear why I thought this would be useful. Currently the default is to allow always."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"print-asm")," if codegen runs on this function (",(0,l.kt)("inlineCode",{parentName:"li"},":color #t"),"), disassemble the result and print it. This is intended for compiler debugging."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"asm-func")," will disable the prologue and epilogue from being generated. You need to include your own ",(0,l.kt)("inlineCode",{parentName:"li"},"ret")," instruction or similar. The compiler will error if it needs to use the stack for a stack variable or a spilled register. The coloring system will not use callee saved registers and will error if you force it to use one. As a result, complicated GOAL expression may fail inside an ",(0,l.kt)("inlineCode",{parentName:"li"},"asm-func")," function. The intent is to use it for context switching routines inside in the kernel, where you may not be able to use the stack, or may not want to return with ",(0,l.kt)("inlineCode",{parentName:"li"},"ret"),". The return type of an ",(0,l.kt)("inlineCode",{parentName:"li"},"asm-func")," must manually be specified as the compiler doesn't automatically put the result in the return register and cannot do type analysis to figure out the real return type."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"allow-saved-regs")," allows an ",(0,l.kt)("inlineCode",{parentName:"li"},"asm-func"),"'s coloring to use saved registers without an error. Stacks spills are still an error. The compiler will not automatically put things in a saved register, you must do this yourself. The move eliminator may still be used on your variables which use saved registers, so you should be careful if you really care about where saved variables are used.")),(0,l.kt)("p",null,"This form will probably get more options in the future."),(0,l.kt)("h3",{id:"local-vars"},(0,l.kt)("inlineCode",{parentName:"h3"},"local-vars")),(0,l.kt)("p",null,"Declare variables local to a function, without an initial value. This will be used by the decompiler before ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," has been fully implemented."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(local-vars (name type-spec)...)\n")),(0,l.kt)("p",null,"The name can be any valid symbol. The scope of the variable is ",(0,l.kt)("em",{parentName:"p"},"always")," the function scope. Other scopes inside a function will always hide variables declared with ",(0,l.kt)("inlineCode",{parentName:"p"},"local-vars"),". The type can be any GOAL typespec. If you use ",(0,l.kt)("inlineCode",{parentName:"p"},"float"),", you get a floating point register, otherwise you get a normal GPR."),(0,l.kt)("p",null,"It's recommended to avoid using this form."),(0,l.kt)("h2",{id:"macro-forms"},"Macro Forms"),(0,l.kt)("h3",{id:"cond-1"},(0,l.kt)("inlineCode",{parentName:"h3"},"#cond")),(0,l.kt)("p",null,"This is like an ",(0,l.kt)("inlineCode",{parentName:"p"},"#ifdef"),", but the language for the conditions is GOOS and it's like a ",(0,l.kt)("inlineCode",{parentName:"p"},"cond"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(#cond (test clause...)...)\n")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"#cond")," is executed at compile time. The cases which don't match aren't compiled. There are ",(0,l.kt)("inlineCode",{parentName:"p"},"#when")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"#unless")," macros that work like you would expect."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(#when PRINT_DEBUG_INFO\n  (format #t "debug info~%")\n  )\n')),(0,l.kt)("h3",{id:"quote--"},(0,l.kt)("inlineCode",{parentName:"h3"},"quote")," / ",(0,l.kt)("inlineCode",{parentName:"h3"},"'")),(0,l.kt)("p",null,"The reader will expand ",(0,l.kt)("inlineCode",{parentName:"p"},"'thing")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"(quote thing)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(quote thing)\n")),(0,l.kt)("p",null,"Currently ",(0,l.kt)("inlineCode",{parentName:"p"},"quote")," supports:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"'a-symbol")," - will return the symbol ",(0,l.kt)("inlineCode",{parentName:"li"},"a-symbol")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"'()")," - will return the empty list.")),(0,l.kt)("p",null,"In the future, it should support quoted lists of static data."),(0,l.kt)("h3",{id:"defglobalconstant"},(0,l.kt)("inlineCode",{parentName:"h3"},"defglobalconstant")),(0,l.kt)("p",null,"Define a GOOS and GOAL constant."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(defconstant name value)\n")),(0,l.kt)("p",null,"The constant is available in both GOOS and GOAL. You can use it in ",(0,l.kt)("inlineCode",{parentName:"p"},"#cond")," expressions (GOOS) and in GOAL code. The constant inserts the ",(0,l.kt)("inlineCode",{parentName:"p"},"value")," as an s-expression in the code. This means it's a \"code\" constant, and doesn't have a type."),(0,l.kt)("p",null,"There are a few restrictions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Currently constants do not work in ",(0,l.kt)("inlineCode",{parentName:"li"},"deftype"),". (this should be fixed eventually)"),(0,l.kt)("li",{parentName:"ul"},"Constants may not work in places where the compiler is expecting a symbol which isn't actually compiled. So ",(0,l.kt)("inlineCode",{parentName:"li"},"(+ MY_CONSTANT 2)")," is fine, but ",(0,l.kt)("inlineCode",{parentName:"li"},"(defun MY_CONSTANT () ...)")," isn't. Don't use constants for type names, function names, or symbol names. It is fine to have a constant with a value of a symbol, but don't ",(0,l.kt)("inlineCode",{parentName:"li"},"(define MY_CONSTANT)")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"(set! MY_CONSTANT)")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"(new MY_CONSTANT)")," or things like that."),(0,l.kt)("li",{parentName:"ul"},"Don't use constants with ",(0,l.kt)("inlineCode",{parentName:"li"},"method")," form."),(0,l.kt)("li",{parentName:"ul"},"You can modify constants created with ",(0,l.kt)("inlineCode",{parentName:"li"},"defglobalconstant")," in GOOS (effect won't be seen in GOAL) with ",(0,l.kt)("inlineCode",{parentName:"li"},"(set!)")),(0,l.kt)("li",{parentName:"ul"},"There is no warning if one ",(0,l.kt)("inlineCode",{parentName:"li"},"defglobalconstant")," changes the value of an existing ",(0,l.kt)("inlineCode",{parentName:"li"},"defglobalconstant"))),(0,l.kt)("p",null,"In general constants should have ",(0,l.kt)("inlineCode",{parentName:"p"},"UPPERCASE")," names otherwise things get very confusing when there are name conflicts."),(0,l.kt)("p",null,"The recommendation is to use constants for things like numbers or expressions like ",(0,l.kt)("inlineCode",{parentName:"p"},"(* NUM_THINGS SIZE_OF_EACH_THING)"),"."),(0,l.kt)("h3",{id:"mlet"},(0,l.kt)("inlineCode",{parentName:"h3"},"mlet")),(0,l.kt)("p",null,"Scoped constants in GOAL. Syntax is like a ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),". This feature has all the restrictions of ",(0,l.kt)("inlineCode",{parentName:"p"},"defglobalconstant"),".\nAvoid using ",(0,l.kt)("inlineCode",{parentName:"p"},"mlet")," because it's confusing and not useful."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(mlet ((constant-name constant-value)...)\n  body...\n  )\n")),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(mlet ((NUM-THINGS 12)\n       (THING-NAME "test"))\n  ; in here, NUM-THING and THING-NAME are constants\n  )\n')),(0,l.kt)("h2",{id:"math-forms"},"Math Forms"),(0,l.kt)("p",null,'Math forms will look at the type of the first argument to determine the "mode". So if you have ',(0,l.kt)("inlineCode",{parentName:"p"},"(+ 1 1.2)"),", it will convert the ",(0,l.kt)("inlineCode",{parentName:"p"},"1.2")," to an integer, do the add, and return an integer."),(0,l.kt)("h3",{id:"-2"},(0,l.kt)("inlineCode",{parentName:"h3"},"+")),(0,l.kt)("p",null,"Addition. Can take 1 or more arguments. ",(0,l.kt)("inlineCode",{parentName:"p"},"(+ 1)")," will give you ",(0,l.kt)("inlineCode",{parentName:"p"},"1"),", like you'd expect."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(+ form...)\n")),(0,l.kt)("p",null,"Works on integers and floats. Integer add is 64-bit and wrapping."),(0,l.kt)("h3",{id:"-"},(0,l.kt)("inlineCode",{parentName:"h3"},"-")),(0,l.kt)("p",null,"Subtraction or negative. Can take 1 or more arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(- form...)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"(- 1)")," gives you ",(0,l.kt)("inlineCode",{parentName:"p"},"-1"),", but ",(0,l.kt)("inlineCode",{parentName:"p"},"(- 1 3)")," gives you ",(0,l.kt)("inlineCode",{parentName:"p"},"-2"),", which may be slightly confusing at first. Works on integers and floats. Integer subtract is 64-bit and wrapping."),(0,l.kt)("h3",{id:"-3"},(0,l.kt)("inlineCode",{parentName:"h3"},"*")),(0,l.kt)("p",null,"Multiplication. Can take 1 or more arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(* form...)\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"(* 7)")," will become ",(0,l.kt)("inlineCode",{parentName:"p"},"7"),", as you'd expect. Works on integers and floats. The exact behavior for integers needs to be explored more because the EE is weird. GOAL generates different code for multiplication of signed vs. unsigned integers."),(0,l.kt)("h3",{id:"-4"},(0,l.kt)("inlineCode",{parentName:"h3"},"/")),(0,l.kt)("p",null,"Division. Takes exactly two arguments"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(/ dividend divisor)\n")),(0,l.kt)("p",null,"Works on floats and integers. The exact behavior for integers needs to be explored more because the EE is weird. GOAL generates different code for division of signed vs. unsigned integers."),(0,l.kt)("h3",{id:"mod"},(0,l.kt)("inlineCode",{parentName:"h3"},"mod")),(0,l.kt)("p",null,"Modulo operation. Takes exactly two arguments."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(/ dividend divisor)\n")),(0,l.kt)("p",null,"Works on integers only. The exact behavior needs to be explored because the EE is weird. It is unknown if the same code is generate for signed/unsigned mod."),(0,l.kt)("h3",{id:"slhv-sarv-shrv"},(0,l.kt)("inlineCode",{parentName:"h3"},"slhv"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},"sarv"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},"shrv")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(shlv value shift-amount)\n")),(0,l.kt)("p",null,"The exact behavior of GOAL shifts isn't fully understood, so these are temporary wrappers around x86-64 variable shift instructions."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"shlv")," shift left variable"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sarv")," shift arithmetic right variable"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"shrv")," shift logical right variable\n64-bit operation.")),(0,l.kt)("h3",{id:"logand"},(0,l.kt)("inlineCode",{parentName:"h3"},"logand")),(0,l.kt)("p",null,"Bitwise And"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(logand a b)\n")),(0,l.kt)("p",null,"64-bit operation."),(0,l.kt)("h3",{id:"logior"},(0,l.kt)("inlineCode",{parentName:"h3"},"logior")),(0,l.kt)("p",null,"Bitwise Inclusive Or (normal Or)"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(logior a b)\n")),(0,l.kt)("p",null,"64-bit operation."),(0,l.kt)("h3",{id:"logxor"},(0,l.kt)("inlineCode",{parentName:"h3"},"logxor")),(0,l.kt)("p",null,"Bitwise Exclusive Or (Xor"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(logxor a b)\n")),(0,l.kt)("p",null,"64-bit operation."),(0,l.kt)("h3",{id:"lognot"},(0,l.kt)("inlineCode",{parentName:"h3"},"lognot")),(0,l.kt)("p",null,"Bitwise Not"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(lognot a)\n")),(0,l.kt)("p",null,"64-bit operation."),(0,l.kt)("h2",{id:"type-forms"},"Type Forms"),(0,l.kt)("h3",{id:"defmethod-1"},(0,l.kt)("inlineCode",{parentName:"h3"},"defmethod")),(0,l.kt)("h3",{id:"deftype"},(0,l.kt)("inlineCode",{parentName:"h3"},"deftype")),(0,l.kt)("h3",{id:"method-of-object"},(0,l.kt)("inlineCode",{parentName:"h3"},"method-of-object")),(0,l.kt)("p",null,"Get a method of an object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(method-of-object object method-name)\n")),(0,l.kt)("p",null,"This form takes an object and gets the method from it. If the object has runtime type information, will consult the method table at runtime to get a possibly more specific method than what is available at compile time. This uses the same lookup logic as method calling - see the section on method calls for more information."),(0,l.kt)("h3",{id:"method-of-type"},(0,l.kt)("inlineCode",{parentName:"h3"},"method-of-type")),(0,l.kt)("p",null,"Get a method of a type or an object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(method-of-type type method-name)\n")),(0,l.kt)("p",null,"The first form of this takes a type name and method name and returns a GOAL ",(0,l.kt)("inlineCode",{parentName:"p"},"function")," for this method. For example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(method string inspect)\n")),(0,l.kt)("p",null,"will return the ",(0,l.kt)("inlineCode",{parentName:"p"},"inspect")," method of ",(0,l.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,l.kt)("h3",{id:"car-and-cdr"},(0,l.kt)("inlineCode",{parentName:"h3"},"car")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},"cdr")),(0,l.kt)("p",null,"Get element from pair"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(car some-pair)\n(cdr some-pair)\n")),(0,l.kt)("p",null,"The type of the result is always ",(0,l.kt)("inlineCode",{parentName:"p"},"object"),", as pairs can hold any ",(0,l.kt)("inlineCode",{parentName:"p"},"object"),". The type-check for ",(0,l.kt)("inlineCode",{parentName:"p"},"car")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"cdr")," is relaxed - it allows it to be applied to any ",(0,l.kt)("inlineCode",{parentName:"p"},"pair")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"object"),". The reason for allowing ",(0,l.kt)("inlineCode",{parentName:"p"},"object")," is so you can write ",(0,l.kt)("inlineCode",{parentName:"p"},"(car (car x))")," instead of ",(0,l.kt)("inlineCode",{parentName:"p"},"(car (the pair (car x)))"),". However, if the argument to ",(0,l.kt)("inlineCode",{parentName:"p"},"car")," is not a ",(0,l.kt)("inlineCode",{parentName:"p"},"pair"),", you will get garbage or a crash."),(0,l.kt)("h3",{id:"new"},(0,l.kt)("inlineCode",{parentName:"h3"},"new")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(new [allocation] [new-type-specification] [args])\n")),(0,l.kt)("p",null,"See section on creating new GOAL objects."),(0,l.kt)("h3",{id:"print-type"},(0,l.kt)("inlineCode",{parentName:"h3"},"print-type")),(0,l.kt)("p",null,"Print the type of some GOAL expression at compile time."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(print-type form)\n")),(0,l.kt)("p",null,"This is mainly used to debug the compiler or figure out why some code is failing a type check. The thing inside is compiled fully and used as the result of ",(0,l.kt)("inlineCode",{parentName:"p"},"print-type"),". Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(print-type "apples")        ;; [TYPE] string\n(print-type (+ 12 1.2))      ;; [TYPE] int\n(print-type (the float 12))  ;; [TYPE] float\n')),(0,l.kt)("h3",{id:"the"},(0,l.kt)("inlineCode",{parentName:"h3"},"the")),(0,l.kt)("p",null,"Convert between types, doing the expected thing for number conversions."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(the type thing)\n")),(0,l.kt)("p",null,"If the ",(0,l.kt)("inlineCode",{parentName:"p"},"type")," and the ",(0,l.kt)("inlineCode",{parentName:"p"},"thing")," are both numbers, it will automatically convert between the different numeric types as needed. In all other cases, it does a dangerous ",(0,l.kt)("inlineCode",{parentName:"p"},"reinterpret_cast"),'. cppreference.com explains this idea clearly with "Converts between types by reinterpreting the underlying bit pattern."'),(0,l.kt)("p",null,"If the ",(0,l.kt)("inlineCode",{parentName:"p"},"thing")," is a number:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"If ",(0,l.kt)("inlineCode",{parentName:"li"},"type")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"binteger"),", convert the number to a ",(0,l.kt)("inlineCode",{parentName:"li"},"binteger")),(0,l.kt)("li",{parentName:"ul"},"If ",(0,l.kt)("inlineCode",{parentName:"li"},"type")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"int")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"uint")," (or some user-defined child type of these), convert the number to an integer."),(0,l.kt)("li",{parentName:"ul"},"If ",(0,l.kt)("inlineCode",{parentName:"li"},"type")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"float"),", convert the number to a ",(0,l.kt)("inlineCode",{parentName:"li"},"float"))),(0,l.kt)("p",null,"In all other cases, directly use the 64-bit value in the register as the value of the desired ",(0,l.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,l.kt)("p",null,"Example of number conversions:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(the binteger 12) ;; boxed integer for 12\n(the float 1)     ;; floating point 1.0\n(the int 1.234)   ;; signed integer 1\n")),(0,l.kt)("p",null,"Examples of common casts:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(the uint 1)             ;; unsigned integer, doesn't do any modification if input is already an int.\n(the (pointer uint8) x)  ;; like C (uint8_t*)x\n(the string (car x))     ;; if you know (car x) is a string, do this.\n")),(0,l.kt)("p",null,"Examples of dangerous things you can do but probably shouldn't:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(the string 1.234) ;; take the binary representation of 1.234 and treat it as a GOAL memory address to string data.\n(the float \'bean)  ;; take the GOAL memory address of the "bean" symbol and treat it as the binary representation of a float.\n')),(0,l.kt)("p",null,"There are some weird edge cases with ",(0,l.kt)("inlineCode",{parentName:"p"},"the")," that are worth mentioning, if you try to set the value of something you've used ",(0,l.kt)("inlineCode",{parentName:"p"},"the")," on. In the future the compiler should block you from doing something bad, but this is not yet implemented."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(set! (-> (the (pointer uint8) x)) 1)      ;; OK, not casting the actual value\n(set! (the int (-> obj x)) 1)              ;; NOT OK. Int is a value type\n;; Will actually work if x is already an int/uint, and with non-numeric values types like pointer. Avoid just to be safe.\n(set! (the string (-> obj x)) "test")      ;; OK, string is a basic, which is a reference type.\n')),(0,l.kt)("p",null,"This becomes more clear if we look at the C equivalent:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"*(uint8_t*)(a->x) = 1; // makes sense\n\n(int)(a->x) = 1; // doesn't make sense\n\n*(thing*)(a->x) = thing(); // makes sense\n")),(0,l.kt)("h3",{id:"the-as"},(0,l.kt)("inlineCode",{parentName:"h3"},"the-as")),(0,l.kt)("p",null,"Convert between types always using ",(0,l.kt)("inlineCode",{parentName:"p"},"reinterpret_cast")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(the-as type thing)\n")),(0,l.kt)("p",null,'cppreference.com explains this idea clearly with "Converts between types by reinterpreting the underlying bit pattern."'),(0,l.kt)("p",null,"The recommendation is to prefer ",(0,l.kt)("inlineCode",{parentName:"p"},"the")," in almost all cases, unless you want to set an exact bit pattern of a ",(0,l.kt)("inlineCode",{parentName:"p"},"float"),", or want to examine the bits in a ",(0,l.kt)("inlineCode",{parentName:"p"},"float"),"."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(the-as int 1.234) ;; result happens to be 1067316150\n")),(0,l.kt)("p",null,"None of the edge cases of ",(0,l.kt)("inlineCode",{parentName:"p"},"the")," apply to ",(0,l.kt)("inlineCode",{parentName:"p"},"the-as"),"."),(0,l.kt)("h3",{id:"size-of"},(0,l.kt)("inlineCode",{parentName:"h3"},"size-of")),(0,l.kt)("p",null,"Get the size of a type, in bytes."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(size-of <type-name>)\n")),(0,l.kt)("p",null,"Get the size of a type, by name. The type must be a plain name, like ",(0,l.kt)("inlineCode",{parentName:"p"},"pointer")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"dma-bucket"),". Compound types are not supported. It works on value and structure types and returns the size in memory. For dynamic types, it returns the size as if the dynamic part has 0 size. For weird types like ",(0,l.kt)("inlineCode",{parentName:"p"},"none")," it throws an error."),(0,l.kt)("p",null,"This value can be used in most places where the compiler is expecting a constant integer as well, such as the size of a stack array, which must be known at compile time."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(size-of dma-bucket)\n")),(0,l.kt)("p",null,"Returns the size of the ",(0,l.kt)("inlineCode",{parentName:"p"},"dma-bucket")," type which is 16 bytes."),(0,l.kt)("h3",{id:"pointer-math"},"Pointer Math"),(0,l.kt)("p",null,"Not implemented well yet."),(0,l.kt)("h2",{id:"inline-assembly-forms"},"Inline Assembly Forms"),(0,l.kt)("p",null,"In general, assembly forms have a name that begins with a ",(0,l.kt)("inlineCode",{parentName:"p"},"."),". They all evaluate to ",(0,l.kt)("inlineCode",{parentName:"p"},"none")," and copy the form of an x86-64 instruction. For example ",(0,l.kt)("inlineCode",{parentName:"p"},"(.sub dst src)"),". A destination must be a settable register (ok if it's spilled). So you can't do something like ",(0,l.kt)("inlineCode",{parentName:"p"},"(.sub (-> obj field) x)"),". Instead, do ",(0,l.kt)("inlineCode",{parentName:"p"},"(set! temp (-> obj field))"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"(.sub temp x)"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"(set! (-> obj field) temp)"),".  The sources can be any expression, or a register. This allows you to mix high-level code with assembly easily, like ",(0,l.kt)("inlineCode",{parentName:"p"},"(.mov rax (-> obj field))")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"(.push (+ 1 (-> obj field)))"),"."),(0,l.kt)("p",null,"By default, assembly forms work with the coloring system. This means that assembly and high level expression can be mixed together without clobbering each other. It also means use of callee-saved registers will cause them to be backed up/restored in the function prologue and epilogue. Use of weird registers like ",(0,l.kt)("inlineCode",{parentName:"p"},"r15"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"r14"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"rsp")," works as you would expect with the coloring system."),(0,l.kt)("p",null,"But you can also request to skip this with ",(0,l.kt)("inlineCode",{parentName:"p"},":color #f")," option, like ",(0,l.kt)("inlineCode",{parentName:"p"},"(.push my-reg-var :color #f)"),". Be very careful with this. The ",(0,l.kt)("inlineCode",{parentName:"p"},":color #f")," option will only work with register variables from ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet")," which have a manually specified register. It will entirely bypass the coloring system and use this register. Use of this near high level GOAL variables is extremely dangerous and should be done very carefully or avoided, as the GOAL compiler will not know that you could be modifying its registers. In a form with ",(0,l.kt)("inlineCode",{parentName:"p"},":color #f"),", you cannot use higher level code or variables - all variables must be defined in ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),"s. This is because higher level expressions and variables cannot be used without the coloring system."),(0,l.kt)("h3",{id:"rlet"},(0,l.kt)("inlineCode",{parentName:"h3"},"rlet")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(rlet ((var-name [:reg reg-name] [:class reg-class] [:type typespec] [:reset-here #t|#f])...)\n  body...\n  )\n")),(0,l.kt)("p",null,"Create register variables. You can optionally specify a register with the ",(0,l.kt)("inlineCode",{parentName:"p"},":reg")," option and a register name like ",(0,l.kt)("inlineCode",{parentName:"p"},"rax")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"xmm3"),". The initial value of the register is not set. If you don't specify a register, a GPR will be chosen for you by the coloring system and it will behave like a ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),". If you don't specify a register, you can specify a register class (",(0,l.kt)("inlineCode",{parentName:"p"},"gpr"),", a normal 64-bit integer register; ",(0,l.kt)("inlineCode",{parentName:"p"},"fpr"),", a 32-bit single precision float; or  ",(0,l.kt)("inlineCode",{parentName:"p"},"vf"),", and 128-bit floating point vector register) and the compiler will pick a GPR or XMM for you."),(0,l.kt)("p",null,"If you pick a callee-saved register and use it within the coloring system, the compiler will back it up for you in the prologue and restore it in the epilogue.\nIf you pick a special register like ",(0,l.kt)("inlineCode",{parentName:"p"},"rsp"),", it won't be backed up."),(0,l.kt)("p",null,"Inside the ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),", all uses of ",(0,l.kt)("inlineCode",{parentName:"p"},"var-name")," will always be in the given register. If the variable goes dead (or is never live), the compiler may reuse the register as it wants. The compiler may also spill the variable onto the stack. Of course, if you are in an ",(0,l.kt)("inlineCode",{parentName:"p"},"asm-func"),', the stack will never be used. Be extremely careful about using "normal" registers without the coloring system and with higher-level code as the compiler may use your "normal" register as a temporary. If you read the value of a register and use the coloring system, the variable will then be alive starting at the beginning of the function, and will make that register unavailable to the compiler and other ',(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),"s that occur before. This is useful to preserve the value of a temporary register if needed, but can also be undesirable in other cases. If you add the ",(0,l.kt)("inlineCode",{parentName:"p"},":reset-here #t")," flag, it will make the variable dead until the start of the ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),'. It "resets" the value of the register in the coloring system at the start of the ',(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),". The default value is false. It is recommended to keep the default value when accessing specific registers that are also normally used by the compiler. For special registers like ",(0,l.kt)("inlineCode",{parentName:"p"},"rsp"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"r15"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"r14"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"r13"),", if you plan to use them with the coloring system, it is recommended to set the ",(0,l.kt)("inlineCode",{parentName:"p"},"reset-here")," flag."),(0,l.kt)("p",null,"Here is an example of using an ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet")," to access registers:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},'(defun get-goal-rsp-2 ()\n  "Get the stack pointer as a GOAL pointer"\n  (rlet ((rsp :reg rsp :type uint)\n         (off :reg r15 :type uint))\n        (the pointer (- rsp off))\n        )\n  )\n')),(0,l.kt)("h3",{id:"sub"},(0,l.kt)("inlineCode",{parentName:"h3"},".sub")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.sub dest src [:color #t|#f])\n")),(0,l.kt)("p",null,"x86-64 subtraction (64-bit). If coloring is on (the default), the ",(0,l.kt)("inlineCode",{parentName:"p"},"dest")," must be a settable register (",(0,l.kt)("inlineCode",{parentName:"p"},"rlet")," var, ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," var, function argument, ...). It can't be a place like a symbol, field, stack variable, etc. If coloring is off, both ",(0,l.kt)("inlineCode",{parentName:"p"},"src")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"dest")," must be registers defined and constrained in an enclosing ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),"."),(0,l.kt)("p",null,"Example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(defun get-goal-rsp ()\n  (declare (asm-func uint))\n  (rlet ((rsp :reg rsp :type uint)\n         (off :reg r15 :type uint)\n         (ret :reg rax :type uint)\n         )\n\n        ;; mov rax, rsp\n        (set! ret rsp)\n        ;; sub rax, r15\n        (.sub ret off)\n        ;; ret\n        (.ret)\n        )\n  )\n")),(0,l.kt)("h3",{id:"add"},(0,l.kt)("inlineCode",{parentName:"h3"},".add")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.add dest src [:color #t|#f])\n")),(0,l.kt)("p",null,"Addition (64-bit). Similar to subtraction."),(0,l.kt)("h3",{id:"jr"},(0,l.kt)("inlineCode",{parentName:"h3"},".jr")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.jr addres-reg [:color #t|#f])\n")),(0,l.kt)("p",null,"Jump-register. Jumps to the address given. The address is treated as a 64-bit pointer, not a GOAL pointer."),(0,l.kt)("h3",{id:"load-sym"},(0,l.kt)("inlineCode",{parentName:"h3"},".load-sym")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.load-sym dest symbol-name [:sext #t|#f] [:color #t|#f])\n")),(0,l.kt)("p",null,"Load the value of a symbol into a register. By default, it will look at the type of the symbol to determine if it should be sign extended or not. You can override this with the ",(0,l.kt)("inlineCode",{parentName:"p"},":sext")," option if needed. The symbol must be known to the type system."),(0,l.kt)("h3",{id:"push"},(0,l.kt)("inlineCode",{parentName:"h3"},".push")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.push src [:color #t|#f])\n")),(0,l.kt)("p",null,"The x86-64 push instruction. Does a 64-bit GPR. The ",(0,l.kt)("inlineCode",{parentName:"p"},"src")," can be any expression that can be put in a gpr if color is on. Otherwise it must be a register defined and constrained in an enclosing ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),"."),(0,l.kt)("h3",{id:"pop"},(0,l.kt)("inlineCode",{parentName:"h3"},".pop")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.pop dst [:color #t|#f])\n")),(0,l.kt)("p",null,"The x86-64 pop instruction. Does a 64-bit GPR. The ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")," can be any expression which evaluates to a settable register if color is on. Otherwise it must be a register defined and constrained in an enclosing ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet"),"."),(0,l.kt)("h3",{id:"ret"},(0,l.kt)("inlineCode",{parentName:"h3"},".ret")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.ret [:color #t|#f])\n")),(0,l.kt)("p",null,"The x86-64 ret instruction. The color option does nothing. This is not recognized as a control flow instruction by the coloring system. It does not touch the return register ",(0,l.kt)("inlineCode",{parentName:"p"},"rax"),"."),(0,l.kt)("h3",{id:"mov"},(0,l.kt)("inlineCode",{parentName:"h3"},".mov")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.mov dst src [:color #t|#f])\n")),(0,l.kt)("p",null,"Move between two registers. The ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")," should be a register (either ",(0,l.kt)("inlineCode",{parentName:"p"},"rlet")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"let")," variable), and the ",(0,l.kt)("inlineCode",{parentName:"p"},"src")," can be a register or any expression. The following moves are supported:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"gpr")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"gpr")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fpr")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"fpr")," (only moves lower 32-bits of the xmms, uses ",(0,l.kt)("inlineCode",{parentName:"li"},"movss"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"vf")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"vf")," (moves all 128-bits of the xmms, uses ",(0,l.kt)("inlineCode",{parentName:"li"},"vmovaps"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"gpr")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"fpr")," (only moves 32-bits, uses ",(0,l.kt)("inlineCode",{parentName:"li"},"movd"),")"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"fpr")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"gpr")," (only moves 32-bits, upper 32-bits are zero, uses ",(0,l.kt)("inlineCode",{parentName:"li"},"movd"),")\nThis code generation is identical to using a ",(0,l.kt)("inlineCode",{parentName:"li"},"(set! dst src)")," form.")),(0,l.kt)("h3",{id:"nopvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".nop.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.nop.vf)\n")),(0,l.kt)("p",null,"Inserts a ",(0,l.kt)("inlineCode",{parentName:"p"},"FNOP")," assembly instruction, which is fundamentally the same as a ",(0,l.kt)("inlineCode",{parentName:"p"},"NOP"),". It is a 2-byte instruction."),(0,l.kt)("h3",{id:"nop-or-nop"},(0,l.kt)("inlineCode",{parentName:"h3"},".nop")," or ",(0,l.kt)("inlineCode",{parentName:"h3"},"(nop!)")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.nop)\n;; or\n(nop!)\n")),(0,l.kt)("p",null,"Inserts a single-byte ",(0,l.kt)("inlineCode",{parentName:"p"},"nop"),"."),(0,l.kt)("h3",{id:"waitvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".wait.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.wait.vf)\n")),(0,l.kt)("p",null,"Inserts a ",(0,l.kt)("inlineCode",{parentName:"p"},"FWAIT")," assembly instruction, x86 does not require as much synchronization as the PS2's VU registers did, but it has a purpose in rare cases. It is a 2-byte instruction."),(0,l.kt)("h3",{id:"lvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".lvf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.lvf dst-reg src-loc [:color #t|#f] [:offset <int>])\n")),(0,l.kt)("p",null,"Load a vector float register from ",(0,l.kt)("inlineCode",{parentName:"p"},"src-loc"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"dst-reg")," must be a vector float register. The ",(0,l.kt)("inlineCode",{parentName:"p"},"src-loc")," can be a gpr containing a GOAL pointer or expression which gives a GOAL pointer. There is no type checking on the ",(0,l.kt)("inlineCode",{parentName:"p"},"src-loc")," so be careful. The load uses ",(0,l.kt)("inlineCode",{parentName:"p"},"vmovaps"),", so the source must be 16-byte aligned."),(0,l.kt)("p",null,"If the source is in the form ",(0,l.kt)("inlineCode",{parentName:"p"},"base-reg + constant-offset"),", like from a ",(0,l.kt)("inlineCode",{parentName:"p"},"(&-> my-object my-inline-vector-field)"),", the constant offset will be folded into the load instruction like ",(0,l.kt)("inlineCode",{parentName:"p"},"vmovaps xmm1, [r15 + rax + 12]"),". An explicit offset can be provided via the ",(0,l.kt)("inlineCode",{parentName:"p"},":offset")," keyword, and will be used if applicable."),(0,l.kt)("p",null,"If the source is an immediate ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'static ...)")," form that results in a statically allocated variable, it will use ",(0,l.kt)("inlineCode",{parentName:"p"},"RIP")," relative addressing (32-bit immediate) form. This means that the code:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.lvf vf1 (new 'static 'vector :x 1.2 :y 2.3 :z 3.4 :w 5.6))\n")),(0,l.kt)("p",null,"will be just a single instruction to do a ",(0,l.kt)("inlineCode",{parentName:"p"},"vmovaps xmm1, [rip + XXX]"),"."),(0,l.kt)("h3",{id:"svf"},(0,l.kt)("inlineCode",{parentName:"h3"},".svf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.svf dst-loc src-reg [:color #t|#f] [:offset <int>])\n")),(0,l.kt)("p",null,"Store a vector float. Works similarly to the ",(0,l.kt)("inlineCode",{parentName:"p"},"lvf")," form, but there is no optimized case for storing into a static because this isn't allowed in GOAL."),(0,l.kt)("h3",{id:"three-operand-vector-float-operations"},"Three operand vector float operations."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.<op-name>[.<broadcast-element>].vf dst src0 src1 [:color #t|#f] [:mask #b<0-15>])\n")),(0,l.kt)("p",null,"All the three operand forms work similarly. You can do something like ",(0,l.kt)("inlineCode",{parentName:"p"},"(.add.vf vf1 vf2 vf3)"),". All operations use the similarly named ",(0,l.kt)("inlineCode",{parentName:"p"},"v<op-name>ps")," instruction, xmm128 VEX encoding. We support the following ",(0,l.kt)("inlineCode",{parentName:"p"},"op-name"),"s:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"xor")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"add")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sub")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"mul")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"min")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"max"))),(0,l.kt)("p",null,"An optional ",(0,l.kt)("inlineCode",{parentName:"p"},":mask")," value can be provided as a binary number between 0-15 (inclusive). This determines ",(0,l.kt)("em",{parentName:"p"},"which")," of the resulting elements will be committed to the destination vector. For example, ",(0,l.kt)("inlineCode",{parentName:"p"},":mask #b1011")," means that the ",(0,l.kt)("inlineCode",{parentName:"p"},"w"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," results will be committed. Note that the components are defined left-to-right which may be a little counter-intuitive -- ",(0,l.kt)("inlineCode",{parentName:"p"},"w")," is the left-most, ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is the right-most. This aligns with the PS2's VU implementation."),(0,l.kt)("p",null,"Additionally, all of these operations support defining a single ",(0,l.kt)("inlineCode",{parentName:"p"},"broadcast-element"),". This can be one of the 4 vector components ",(0,l.kt)("inlineCode",{parentName:"p"},"x|y|z|w"),". Take the following for an example: ",(0,l.kt)("inlineCode",{parentName:"p"},"(.add.x.xyzw vf10, vf20, vf30)"),", translates into:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"vf10[x] = vf20[x] + vf30[x]\nvf10[y] = vf20[y] + vf30[x]\nvf10[z] = vf20[z] + vf30[x]\nvf10[w] = vf20[w] + vf30[x]\n")),(0,l.kt)("h3",{id:"three-operand-vector-float-operations-with-the-accumulator"},"Three operand vector float operations with the accumulator"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.<op-name>[.<broadcast-element>].vf dst src0 src1 acc [:color #t|#f] [:mask #b<0-15>])\n")),(0,l.kt)("p",null,"There are a few functions that will perform multiple operations involving the accumulator. We support the following ",(0,l.kt)("inlineCode",{parentName:"p"},"op-name"),"s:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"add.mul")," - Calculate the product of ",(0,l.kt)("inlineCode",{parentName:"li"},"src0")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"src1")," and add it to the value of ",(0,l.kt)("inlineCode",{parentName:"li"},"acc")," => ",(0,l.kt)("inlineCode",{parentName:"li"},"acc + (src0 * src1)")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"sub.mul")," - Calculate the product of ",(0,l.kt)("inlineCode",{parentName:"li"},"src0")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"src1")," and subtract it from the value of ",(0,l.kt)("inlineCode",{parentName:"li"},"acc")," => ",(0,l.kt)("inlineCode",{parentName:"li"},"acc - (src0 * src1)"))),(0,l.kt)("p",null,"An optional ",(0,l.kt)("inlineCode",{parentName:"p"},":mask")," value can be provided as a binary number between 0-15 (inclusive). This determines ",(0,l.kt)("em",{parentName:"p"},"which")," of the resulting elements will be committed to the destination vector. For example, ",(0,l.kt)("inlineCode",{parentName:"p"},":mask #b1011")," means that the ",(0,l.kt)("inlineCode",{parentName:"p"},"w"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"y")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," results will be committed. Note that the components are defined left-to-right which may be a little counter-intuitive -- ",(0,l.kt)("inlineCode",{parentName:"p"},"w")," is the left-most, ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," is the right-most. This aligns with the PS2's VU implementation."),(0,l.kt)("p",null,"Additionally, all of these operations support defining a single ",(0,l.kt)("inlineCode",{parentName:"p"},"broadcast-element"),". This can be one of the 4 vector components ",(0,l.kt)("inlineCode",{parentName:"p"},"x|y|z|w"),"."),(0,l.kt)("h3",{id:"absvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".abs.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.abs.vf dst src [:color #t|#f] [:mask #b<0-15>])\n")),(0,l.kt)("p",null,"Calculates the absolute value of the ",(0,l.kt)("inlineCode",{parentName:"p"},"src")," vector, and stores in the ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")," vector."),(0,l.kt)("h3",{id:"divvf-and-sqrtvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".div.vf")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},".sqrt.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.div.vf dst src1 src2 :ftf #b<0-3> :fsf #b<0-3> [:color #t|#f])\n")),(0,l.kt)("p",null,"Calculates the quotient of ",(0,l.kt)("em",{parentName:"p"},"one")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"src1"),"'s components specified by ",(0,l.kt)("inlineCode",{parentName:"p"},"fsf")," ",(0,l.kt)("em",{parentName:"p"},"one")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"src2"),"'s components specified by ",(0,l.kt)("inlineCode",{parentName:"p"},"ftf")," and stores in every component of ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.sqrt.vf dst src :ftf #b<0-3> [:color #t|#f])\n")),(0,l.kt)("p",null,"Calculates the square-root of ",(0,l.kt)("em",{parentName:"p"},"one")," of ",(0,l.kt)("inlineCode",{parentName:"p"},"src"),"'s components specified by ",(0,l.kt)("inlineCode",{parentName:"p"},"ftf")," and stores in every component of ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")),(0,l.kt)("p",null,"These instructions are interesting as they behave differently than the other math operations. In the original VU, results were stored in a seperate ",(0,l.kt)("inlineCode",{parentName:"p"},"Q")," register, which was ",(0,l.kt)("em",{parentName:"p"},"NOT")," 128-bit. Instead it was a 32-bit register, meaning you have to pick which component from ",(0,l.kt)("inlineCode",{parentName:"p"},"src")," you want to use. ",(0,l.kt)("inlineCode",{parentName:"p"},":fsf")," and ",(0,l.kt)("inlineCode",{parentName:"p"},":ftf")," are used to accomplish this, as usual, this is through bit flags -- ",(0,l.kt)("inlineCode",{parentName:"p"},"00")," will select ",(0,l.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"11")," will select ",(0,l.kt)("inlineCode",{parentName:"p"},"w"),"."),(0,l.kt)("p",null,"As ",(0,l.kt)("inlineCode",{parentName:"p"},"dst")," is just yet another vector / xmm register in x86, things are kept simple and the quotient is copied to ",(0,l.kt)("em",{parentName:"p"},"all")," packed single-float positions. This allows:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Selecting any of the resulting vector slots will be equal to the quotient."),(0,l.kt)("li",{parentName:"ul"},"Since the low-floating-point (X) is defined, the xmm register should function as expected for normal math operations")),(0,l.kt)("h3",{id:"outerproductvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".outer.product.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.outer.product.vf dst src1 src2 [:color #t|#f])\n")),(0,l.kt)("p",null,"Calculates the outer-product of ",(0,l.kt)("inlineCode",{parentName:"p"},"src1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"src2")," and stores the result in ",(0,l.kt)("inlineCode",{parentName:"p"},"dst"),". ",(0,l.kt)("em",{parentName:"p"},"ONLY")," the x,y,z components are considered, and ",(0,l.kt)("inlineCode",{parentName:"p"},"dst"),"'s ",(0,l.kt)("inlineCode",{parentName:"p"},"w")," component will be untouched. The following example illustrates what the outer-product is:"),(0,l.kt)("p",null,"Given 2 vectors ",(0,l.kt)("inlineCode",{parentName:"p"},"V1 = <1,2,3,4>")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"V2 = <5,6,7,8>")," and assume ",(0,l.kt)("inlineCode",{parentName:"p"},"VDEST = <0, 0, 0, 999>"),"\nThe outer product is computed like so (only x,y,z components are operated on):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"x = (V1y * V2z) - (V2y * V1z) => (2 * 7) - (6 * 3) => -4\ny = (V1z * V2x) - (V2z * V1x) => (3 * 5) - (7 * 1) =>  8\nz = (V1x * V2y) - (V2x * V1y) => (1 * 6) - (5 * 2) => -4\nw = N/A, left alone                                => 999\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},(0,l.kt)("inlineCode",{parentName:"p"},"VDEST = <-4, 8, -4, 999>"))),(0,l.kt)("p",null,"This is equivalent to the following on the PS2:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-mips"},"vopmula.xyz acc src1 src2\nvopmsub.xyz dst src2 src1\n")),(0,l.kt)("h3",{id:"blendvf"},(0,l.kt)("inlineCode",{parentName:"h3"},".blend.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.blend.vf dst src0 src1 mask [:color #t|#f])\n")),(0,l.kt)("p",null,"Wrapper around ",(0,l.kt)("inlineCode",{parentName:"p"},"vblendps")," (VEX xmm128 version) instruction. The ",(0,l.kt)("inlineCode",{parentName:"p"},"mask")," must evaluate to a constant integer at compile time. The integer must be in the range of 0-15."),(0,l.kt)("h3",{id:"itofvf-and-ftoivf"},(0,l.kt)("inlineCode",{parentName:"h3"},".itof.vf")," and ",(0,l.kt)("inlineCode",{parentName:"h3"},".ftoi.vf")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.itof.vf dst src [:mask mask-val] [:color #t|#f])\n(.ftoi.vf dst src [:mask mask-val] [:color #t|#f])\n")),(0,l.kt)("p",null,"Wrapper around ",(0,l.kt)("inlineCode",{parentName:"p"},"vcvtdq2ps")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"vcvtps2dq")," to convert packed 32-bit signed integers to packed 32-bit floats and back. The ",(0,l.kt)("inlineCode",{parentName:"p"},"mask")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"color")," arguments behave like other assembly operations."),(0,l.kt)("h3",{id:"pwsra-pwsrl-and-pwsll"},(0,l.kt)("inlineCode",{parentName:"h3"},".pw.sra"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".pw.srl"),", and ",(0,l.kt)("inlineCode",{parentName:"h3"},"pw.sll")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.pw.sra dst src shift-amount [:mask mask-val] [:color #t|#f])\n(.pw.srl dst src shift-amount [:mask mask-val] [:color #t|#f])\n(.pw.sll dst src shift-amount [:mask mask-val] [:color #t|#f])\n")),(0,l.kt)("p",null,"Wrapper around ",(0,l.kt)("inlineCode",{parentName:"p"},"vpsrld"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"vpsrad"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"vpslld"),". Does shifts on each of the 4 32-bit integers in the register."),(0,l.kt)("h3",{id:"pextlw-pextuw-pcpyud-pcpyld-pceqw-ppach"},(0,l.kt)("inlineCode",{parentName:"h3"},".pextlw"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".pextuw"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".pcpyud"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".pcpyld"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".pceqw"),", ",(0,l.kt)("inlineCode",{parentName:"h3"},".ppach")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-lisp"},"(.pextlw dst src0 src1 [:color #t|#f])\n(.pextuw dst src0 src1 [:color #t|#f])\n(.pcpyud dst src0 src1 [:color #t|#f])\n(.pcpyld dst src0 src1 [:color #t|#f])\n(.pceqw dst src0 src1 [:color #t|#f])\n(.ppach dest src0 src1)\n")),(0,l.kt)("p",null,"Equivalents of the EE's MMI instructions with the same name. These can only be used on 128-bit variables. Most map to single x86 instructions:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pextlw")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"VPUNPCKLDQ")," (sources swapped)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pextuw")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"VPUNPCKHDQ")," (sources swapped)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pcpyld")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"VPUNPCKLQDQ")," (sources swapped)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pcpyud")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"VPUNPCKHQDQ")," (sources ",(0,l.kt)("em",{parentName:"li"},"not")," swapped)"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"pceqw")," is ",(0,l.kt)("inlineCode",{parentName:"li"},"VPCMPEQD"))),(0,l.kt)("p",null,"Some map to multiple instructions. These must use the coloring system."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ppach")," is a sequence of 7 instructions (",(0,l.kt)("inlineCode",{parentName:"li"},"VPSHUFLW"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"VPSHUFHW"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"VPSRLDQ"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"VPUNPCKLQDQ"),").")),(0,l.kt)("h2",{id:"todo"},"TODO"),(0,l.kt)("h3",{id:"things-related-to-enums"},"Things related to enums"),(0,l.kt)("p",null,"Not yet implemented"),(0,l.kt)("h3",{id:"defmacro"},(0,l.kt)("inlineCode",{parentName:"h3"},"defmacro")),(0,l.kt)("h3",{id:"loop-forms"},"Loop forms"),(0,l.kt)("h3",{id:"-5"},(0,l.kt)("inlineCode",{parentName:"h3"},"&")),(0,l.kt)("h3",{id:"--1"},(0,l.kt)("inlineCode",{parentName:"h3"},"->")),(0,l.kt)("h3",{id:"type"},"Type"),(0,l.kt)("h3",{id:"compile-time-size-stuff"},"Compile-Time Size stuff"),(0,l.kt)("h3",{id:"object-new"},(0,l.kt)("inlineCode",{parentName:"h3"},"object-new")))}c.isMDXComponent=!0}}]);