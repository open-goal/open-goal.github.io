"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[794],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return c}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,k=u["".concat(s,".").concat(c)]||u[c]||d[c]||i;return n?a.createElement(k,l(l({ref:t},m),{},{components:n})):a.createElement(k,l({ref:t},m))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8369:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return d}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),l=["components"],o={sidebar_position:4},s="Registers",p={unversionedId:"developing/registers",id:"developing/registers",title:"Registers",description:"Although modern computers are much faster than the PS2, and we could probably get away with a really inefficient register allocation scheme, I think it's worth it to get this right.",source:"@site/documentation/developing/registers.md",sourceDirName:"developing",slug:"/developing/registers",permalink:"/docs/developing/registers",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/developing/registers.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"docsSidebar",previous:{title:"Porting to x86",permalink:"/docs/developing/porting_to_x86"},next:{title:"PC Port Info",permalink:"/docs/category/pc-port-info"}},m={},d=[{value:"Register differences between MIPS and x86-64",id:"register-differences-between-mips-and-x86-64",level:2},{value:"Plan for Memory Access",id:"plan-for-memory-access",level:3},{value:"Plan for Function Call and Arguments",id:"plan-for-function-call-and-arguments",level:3},{value:"Plan for Static Data",id:"plan-for-static-data",level:3},{value:"Plan for Memory",id:"plan-for-memory",level:3}],u={toc:d};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"registers"},"Registers"),(0,i.kt)("p",null,"Although modern computers are much faster than the PS2, and we could probably get away with a really inefficient register allocation scheme, I think it's worth it to get this right."),(0,i.kt)("h2",{id:"register-differences-between-mips-and-x86-64"},"Register differences between MIPS and x86-64"),(0,i.kt)("p",null,"The PS2's MIPS processor has these categories of register:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"General Purpose. They are 128-bit, but usually only lower 64 bits are used. 32 registers, each 128-bits."),(0,i.kt)("li",{parentName:"ul"},"Floating point registers. 32 registers, each for a 32-bit float."),(0,i.kt)("li",{parentName:"ul"},"Vector float registers. 32 registers, each for 4x 32-bit floats. Used only in inline assembly"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"vi")," registers. 16 registers, each a 16-bit integer. Used very rarely in inline assembly")),(0,i.kt)("p",null,"There are also some control/special registers too (",(0,i.kt)("inlineCode",{parentName:"p"},"Q"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"R"),"...), but code using these will be manually ported."),(0,i.kt)("p",null,"In comparison, x86-64 has much fewer registers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"16 General Purpose. Each 64-bits"),(0,i.kt)("li",{parentName:"ul"},"16 ",(0,i.kt)("inlineCode",{parentName:"li"},"xmm")," registers. 128-bits, and can store either 128-bit integers or 4x 32-bit floats")),(0,i.kt)("p",null,"Here is the mapping:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"MIPS GPR (lower 64 bits only) - x86-64 GPR"),(0,i.kt)("li",{parentName:"ul"},"MIPS GPR (128-bits, only special cases) - x64-64 ",(0,i.kt)("inlineCode",{parentName:"li"},"xmm")),(0,i.kt)("li",{parentName:"ul"},"MIPS floating point - x64-64 ",(0,i.kt)("inlineCode",{parentName:"li"},"xmm")," (lower 32-bits)"),(0,i.kt)("li",{parentName:"ul"},"MIPS vector float - x64-64 ",(0,i.kt)("inlineCode",{parentName:"li"},"xmm")," (packed single)"),(0,i.kt)("li",{parentName:"ul"},"MIPS ",(0,i.kt)("inlineCode",{parentName:"li"},"vi")," - manually handled??")),(0,i.kt)("p",null,"Here is the MIPS GPR map"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r0")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"zero")," : always zero"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r1")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"at"),": assembler temporary, not saved, not used by compiler"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r2")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"v0"),": return value, not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r3")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"v1"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r4")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"a0"),": not saved, argument 0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r5")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"a1"),": not saved, argument 1"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r6")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"a2"),": not saved, argument 2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r7")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"a3"),": not saved, argument 3"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r8")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t0"),": not saved, argument 4"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r9")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t1"),": not saved, argument 5"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r10")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t2"),": not saved, argument 6"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r11")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t3"),": not saved, argument 7"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r12")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t4"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r13")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t5"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r14")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t6"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r15")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t7"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r16")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s0"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r17")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s1"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r18")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s2"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r19")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s3"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r20")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s4"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r21")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s5"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r22")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s6"),": saved, process pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r23")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"s7"),": saved, symbol pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r24")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t8"),": not saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r25")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"t9"),": function call pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r26")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"k0"),": kernel reserved (unused)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r27")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"k1"),": kernel reserved (unused)"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r28")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"gp"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r29")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"sp"),": stack pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r30")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"fp"),": current function pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r31")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"ra"),": return address pointer")),(0,i.kt)("p",null,"And the x86-64 GPR map"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rax"),": return value"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rcx"),": argument 3"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rdx"),": argument 2"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rbx"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rsp"),": stack pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rbp"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rsi"),": argument 1"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"rdi"),": argument 0"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r8"),": argument 4"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r9"),": argument 5"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r10"),": argument 6, saved if not argument"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r11"),": argument 7, saved if not argument"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r12"),": saved"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r13"),": process pointer"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r14"),": symbol table"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"r15"),": offset pointer")),(0,i.kt)("h3",{id:"plan-for-memory-access"},"Plan for Memory Access"),(0,i.kt)("p",null,"The PS2 uses 32-bit pointers, and changing the pointer size is likely to introduce bugs, so we will keep using 32-bit pointers.  Also, GOAL has some hardcoded checks on the value for pointers, so we need to make sure the memory appears to the program at the correct address."),(0,i.kt)("p",null,'To do this, we have separate "GOAL Pointers" and "real pointers".  The "real pointers" are just normal x86-64 pointers, and the "GOAL Pointer" is an offset into a main memory array.  A "real pointer" to the main memory array is stored in ',(0,i.kt)("inlineCode",{parentName:"p"},"r15")," (offset pointer) when GOAL code is executing, and the GOAL compiler will automatically add this to all memory accesses."),(0,i.kt)("p",null,"The overhead from doing this is not as bad as you might expect - x86 has nice addressing modes (Scale Index Base) which are quite fast, and don't require the use of temporary registers. If this does turn out to be much slower than I expect, we can introduce the concept of real pointers in GOAL code, and use them in places where we are limited in accessing memory."),(0,i.kt)("p",null,"The main RAM is mapped at ",(0,i.kt)("inlineCode",{parentName:"p"},"0x0")," on the PS2, with the first 1 MB reserved for the kernel.  We should make sure that the first 1 MB of GOAL main memory will cause a segfault if read/written/executed, to catch null pointer bugs."),(0,i.kt)("p",null,"In the C Kernel code, the ",(0,i.kt)("inlineCode",{parentName:"p"},"r15")," pointer doesn't exist. Instead, ",(0,i.kt)("inlineCode",{parentName:"p"},"g_ee_main_memory")," is a global which points to the beginning of GOAL main memory.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"Ptr<T>")," template class takes care of converting GOAL and C++ pointers in a convenient way, and catches null pointer access."),(0,i.kt)("p",null,"The GOAL stack pointer should likely be a real pointer, for performance reasons.  This makes pushing/popping/calling/returning/accessing stack variables much faster (can use actual ",(0,i.kt)("inlineCode",{parentName:"p"},"push"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"pop"),"), with the only cost being getting a GOAL stack pointer requiring some extra work. The stack pointer's value is read/written extremely rarely (only in kernel code that will be rewritten anyway), so this seems like a good tradeoff."),(0,i.kt)("p",null,"The other registers are less clear.  The process pointer can probably be a real pointer.  But the symbol table could go a few ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Make it a real pointer.  Symbol value access is fast, but comparison against false requires two extra operations."),(0,i.kt)("li",{parentName:"ol"},"Make it a GOAL pointer. Symbol value access requires more complicated addressing modes to be one instruction, but comparison against false is fast.")),(0,i.kt)("p",null,"Right now I'm leaning toward 2, but it shouldn't be a huge amount of work to change if I'm wrong."),(0,i.kt)("h3",{id:"plan-for-function-call-and-arguments"},"Plan for Function Call and Arguments"),(0,i.kt)("p",null,"In GOAL for MIPS, function calls are weird.  Functions are always called by register using ",(0,i.kt)("inlineCode",{parentName:"p"},"t9"),". There seems to be a different register allocator for function pointers, as nested function calls have really wacky register allocation.  In GOAL-x86-64, this restriction will be removed, and a function can be called from any register. (see next section for why we can do this)"),(0,i.kt)("p",null,"Unfortunately, GOAL's 128-bit function arguments present a big challenge.  When calling a function, we can't know if the function we're calling is expecting an integer, float, or 128-bit integer. In fact, the caller may not even know if it has an integer, float, or 128-bit integer. The easy and foolproof way to get this right is to use 128-bit ",(0,i.kt)("inlineCode",{parentName:"p"},"xmm")," registers for all arguments and return values, but this will cause a massive performance hit and increase code size, as we'll have to move values between register types constantly. The current plan is this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Floats go in GPRs for arguments/return values. GOAL does this too, and takes the hit of converting between registers as well. Probably the impact on a modern CPU is even worse, but we can live with it."),(0,i.kt)("li",{parentName:"ul"},"We'll compromise for 128-bit function calls. When the compiler can figure out that the function being called expects or returns a 128-bit value, it will use the 128-bit calling convention.  In all other cases, it will use 64-bit. There aren't many places where 128-bit integer are used outside of inline assembly, so I suspect this will just work. If there are more complicated instances (call a function pointer and get either a 64 or 128-bit result), we will need to special case them.")),(0,i.kt)("h3",{id:"plan-for-static-data"},"Plan for Static Data"),(0,i.kt)("p",null,"The original GOAL implementation always called functions by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"t9")," register. So, on entry to a function, the ",(0,i.kt)("inlineCode",{parentName:"p"},"t9")," register contains the address of the function. If the function needs to access static data, it will move this ",(0,i.kt)("inlineCode",{parentName:"p"},"fp"),", then do ",(0,i.kt)("inlineCode",{parentName:"p"},"fp")," relative addressing to load data. Example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-nasm"},"function-start:\n    daddiu sp, sp, -16  ;; allocate space on stack\n    sd fp, 8(sp)        ;; back up old fp on stack\n    or fp, t9, r0       ;; set fp to address of function\n    lwc1 f0, L345(fp)   ;; load relative to function start\n")),(0,i.kt)("p",null,"To copy this exactly on x86 would require reserving two registers equivalent to ",(0,i.kt)("inlineCode",{parentName:"p"},"t9")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"gp"),'.  A better approach for x86-64 is to use "RIP relative addressing". This can be used to load memory relative to the current instruction pointer.  This addressing mode can be used with "load effective address" (',(0,i.kt)("inlineCode",{parentName:"p"},"lea"),") to create pointers to static data as well."),(0,i.kt)("h3",{id:"plan-for-memory"},"Plan for Memory"),(0,i.kt)("p",null,"Access memory by GOAL pointer in ",(0,i.kt)("inlineCode",{parentName:"p"},"rx")," with constant offset (optionally zero):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-nasm"},"mov rdest, [roff + rx + offset]\n")))}c.isMDXComponent=!0}}]);