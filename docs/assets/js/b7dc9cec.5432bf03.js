"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[667],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(n),u=i,k=c["".concat(s,".").concat(u)]||c[u]||m[u]||l;return n?a.createElement(k,r(r({ref:t},d),{},{components:n})):a.createElement(k,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},7719:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return m}});var a=n(7462),i=n(3366),l=(n(7294),n(3905)),r=["components"],o={sidebar_position:3},s="OpenGOAL Syntax & Examples",p={unversionedId:"reference/syntax",id:"reference/syntax",title:"OpenGOAL Syntax & Examples",description:"The Basics",source:"@site/documentation/reference/syntax.md",sourceDirName:"reference",slug:"/reference/syntax",permalink:"/docs/reference/syntax",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/reference/syntax.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"OpenGOAL's Method System",permalink:"/docs/reference/method_system"},next:{title:"Standard Library",permalink:"/docs/reference/lib"}},d={},m=[{value:"The Basics",id:"the-basics",level:2},{value:"Atoms",id:"atoms",level:3},{value:"Integers",id:"integers",level:3},{value:"Side Note",id:"side-note",level:4},{value:"String",id:"string",level:3},{value:"Float",id:"float",level:3},{value:"Symbol",id:"symbol",level:3},{value:"Comments",id:"comments",level:3},{value:"Compiling a list",id:"compiling-a-list",level:2},{value:"Compiling an integer",id:"compiling-an-integer",level:2},{value:"Compiling a string",id:"compiling-a-string",level:2},{value:"Compiling a float",id:"compiling-a-float",level:2},{value:"Compiling a symbol",id:"compiling-a-symbol",level:2},{value:"The Special <code>none</code> type",id:"the-special-none-type",level:2},{value:"GOAL Structs vs. C Structs",id:"goal-structs-vs-c-structs",level:2},{value:"Pointers",id:"pointers",level:2},{value:"Inline Arrays",id:"inline-arrays",level:2},{value:"Fields in Structs",id:"fields-in-structs",level:2},{value:"Dynamic Structs",id:"dynamic-structs",level:2},{value:"Unknown",id:"unknown",level:3},{value:"How To Create GOAL Objects - <code>new</code>",id:"how-to-create-goal-objects---new",level:2},{value:"Heap Allocated Objects",id:"heap-allocated-objects",level:3},{value:"Heap Allocated Arrays",id:"heap-allocated-arrays",level:3},{value:"Static Objects",id:"static-objects",level:3},{value:"Stack Allocated Arrays",id:"stack-allocated-arrays",level:3},{value:"Stack Allocated Structures",id:"stack-allocated-structures",level:3},{value:"Defining a <code>new</code> Method",id:"defining-a-new-method",level:3},{value:"Array Spacing",id:"array-spacing",level:2},{value:"Truth",id:"truth",level:2},{value:"Empty Pair",id:"empty-pair",level:2}],c={toc:m};function u(e){var t=e.components,n=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"opengoal-syntax--examples"},"OpenGOAL Syntax & Examples"),(0,l.kt)("h2",{id:"the-basics"},"The Basics"),(0,l.kt)("h3",{id:"atoms"},"Atoms"),(0,l.kt)("p",null,'An "atom" in Lisp is a form that can\'t be broken down into smaller forms. For example ',(0,l.kt)("inlineCode",{parentName:"p"},"1234")," is an atom, but ",(0,l.kt)("inlineCode",{parentName:"p"},"(1234 5678)")," is not.  OpenGOAL supports the following atoms:"),(0,l.kt)("h3",{id:"integers"},"Integers"),(0,l.kt)("p",null,"All integers are by default ",(0,l.kt)("inlineCode",{parentName:"p"},"int"),", a signed 64-bit integer. You can use:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"decimal: Like ",(0,l.kt)("inlineCode",{parentName:"li"},"123")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"-232"),". The allowable range is ",(0,l.kt)("inlineCode",{parentName:"li"},"INT64_MIN")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"INT64_MAX"),"."),(0,l.kt)("li",{parentName:"ul"},"hex: Like ",(0,l.kt)("inlineCode",{parentName:"li"},"#x123"),". The allowable range is ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"UINT64_MAX"),". Values over ",(0,l.kt)("inlineCode",{parentName:"li"},"INT64_MAX")," will wrap around."),(0,l.kt)("li",{parentName:"ul"},"binary: Like ",(0,l.kt)("inlineCode",{parentName:"li"},"#b10101010"),". The range is the same as hex."),(0,l.kt)("li",{parentName:"ul"},"character:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Most can be written like ",(0,l.kt)("inlineCode",{parentName:"li"},"#\\c")," for the character ",(0,l.kt)("inlineCode",{parentName:"li"},"c"),"."),(0,l.kt)("li",{parentName:"ul"},"Space is ",(0,l.kt)("inlineCode",{parentName:"li"},"#\\\\s")),(0,l.kt)("li",{parentName:"ul"},"New Line is ",(0,l.kt)("inlineCode",{parentName:"li"},"#\\\\n")),(0,l.kt)("li",{parentName:"ul"},"Tab is ",(0,l.kt)("inlineCode",{parentName:"li"},"#\\\\t"))))),(0,l.kt)("p",null,"GOAL has some weird behavior when it comes to integers. It may seem complicated to describe, but it really makes the implementation simpler - the integer types are designed around the available MIPS instructions."),(0,l.kt)("p",null,"Integers that are used as local variables (defined with ",(0,l.kt)("inlineCode",{parentName:"p"},"let"),'), function arguments, function return values, and intermediate values when combining these are called "register integers", as the values will be stored in CPU registers.'),(0,l.kt)("p",null,"Integers that are stored in memory as a field of a ",(0,l.kt)("inlineCode",{parentName:"p"},"structure"),"/",(0,l.kt)("inlineCode",{parentName:"p"},"basic"),", an element in an array, or accessed through a ",(0,l.kt)("inlineCode",{parentName:"p"},"pointer"),' are "memory integers", as the values will need to be loaded/stored from memory to access them.'),(0,l.kt)("p",null,'The "register integer" types are ',(0,l.kt)("inlineCode",{parentName:"p"},"int")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"uint"),". They are 64-bit and mostly work exactly like you'd expect. Multiplication, division, and mod, are a little weird and are documented separately."),(0,l.kt)("p",null,'The "memory integer" types are ',(0,l.kt)("inlineCode",{parentName:"p"},"int8"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"int16"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"int32"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"int64"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"uint8"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"uint16"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"uint32"),", and ",(0,l.kt)("inlineCode",{parentName:"p"},"uint64"),"."),(0,l.kt)("p",null,'Conversions between these types are completely automatic - as soon as you access a "memory integer", it will be converted to a "register integer", and trying to store a "register integer" will automatically convert it to the appropriate "memory integer". It (should be) impossible to accidentally get this wrong.'),(0,l.kt)("h4",{id:"side-note"},"Side Note"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"It's not clear what types ",(0,l.kt)("inlineCode",{parentName:"li"},"(new 'static 'integer)")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"(new 'stack 'integer)")," are, though I would assume both are memory."),(0,l.kt)("li",{parentName:"ul"},'If there aren\'t enough hardware registers, "register integers" can be spilled to stack, but keep their "register integer" types. This process should be impossible to notice, so you don\'t have to worry about it.')),(0,l.kt)("h3",{id:"string"},"String"),(0,l.kt)("p",null,'A string generates a static string constant. Currently the "const" of this string "constant" isn\'t enforced. Creating two identical string constants creates two different string objects, which is different from GOAL and should be fixed at some point.'),(0,l.kt)("p",null,"The string data is in quotes, like in C. The following escapes are supported:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Newline: ",(0,l.kt)("inlineCode",{parentName:"li"},"\\n")),(0,l.kt)("li",{parentName:"ul"},"Tab: ",(0,l.kt)("inlineCode",{parentName:"li"},"\\t")),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},"\\")," character: ",(0,l.kt)("inlineCode",{parentName:"li"},"\\\\")),(0,l.kt)("li",{parentName:"ul"},"The ",(0,l.kt)("inlineCode",{parentName:"li"},'"')," character: ",(0,l.kt)("inlineCode",{parentName:"li"},'\\"')),(0,l.kt)("li",{parentName:"ul"},"Any character: ",(0,l.kt)("inlineCode",{parentName:"li"},"\\cXX")," where ",(0,l.kt)("inlineCode",{parentName:"li"},"XX")," is the hex number for the character.")),(0,l.kt)("h3",{id:"float"},"Float"),(0,l.kt)("p",null,"Any number constant with a decimal in it. The trailing and leading zeros and negative sign is flexible, so you can do any of these:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"1."),", ",(0,l.kt)("inlineCode",{parentName:"li"},"1.0"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"01."),", ",(0,l.kt)("inlineCode",{parentName:"li"},"01.0")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},".1"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"0.1"),", ",(0,l.kt)("inlineCode",{parentName:"li"},".10"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"0.10")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"-.1"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"-0.1"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"-.10"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"-0.10"))),(0,l.kt)("p",null,"Like string, it creates a static floating point constant. In later games the float was inlined instead of being a static constant."),(0,l.kt)("h3",{id:"symbol"},"Symbol"),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},"symbol-name")," to get the value of a symbol and ",(0,l.kt)("inlineCode",{parentName:"p"},"'symbol-name")," to get the symbol object."),(0,l.kt)("h3",{id:"comments"},"Comments"),(0,l.kt)("p",null,"Use ",(0,l.kt)("inlineCode",{parentName:"p"},";")," for line comments and ",(0,l.kt)("inlineCode",{parentName:"p"},"#|")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"|#")," for block comments."),(0,l.kt)("h2",{id:"compiling-a-list"},"Compiling a list"),(0,l.kt)("p",null,"When the compiler encounters a list like ",(0,l.kt)("inlineCode",{parentName:"p"},"(a b c)")," it attempts to parse in multiple ways in this order:"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"A compiler form"),(0,l.kt)("li",{parentName:"ol"},"A GOOS macro"),(0,l.kt)("li",{parentName:"ol"},"An enum (not yet implemented)"),(0,l.kt)("li",{parentName:"ol"},"A function or method call")),(0,l.kt)("h2",{id:"compiling-an-integer"},"Compiling an integer"),(0,l.kt)("p",null,"Integers can be specified as"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"decimal: ",(0,l.kt)("inlineCode",{parentName:"li"},"1")," or ",(0,l.kt)("inlineCode",{parentName:"li"},"-1234")," (range of ",(0,l.kt)("inlineCode",{parentName:"li"},"INT64_MIN")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"INT64_MAX"),")"),(0,l.kt)("li",{parentName:"ul"},"hex: ",(0,l.kt)("inlineCode",{parentName:"li"},"#x123"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"#xbeef")," (range of ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"UINT64_MAX"),")"),(0,l.kt)("li",{parentName:"ul"},"binary: ",(0,l.kt)("inlineCode",{parentName:"li"},"#b101010")," (range of ",(0,l.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,l.kt)("inlineCode",{parentName:"li"},"UINT64_MAX"),")")),(0,l.kt)("p",null,'All integers are converted to the signed "integer in variable" type called ',(0,l.kt)("inlineCode",{parentName:"p"},"int"),', regardless of how they are specified.\nInteger "constant"s are not stored in memory but instead are generated by code, so there\'s no way to modify them.'),(0,l.kt)("h2",{id:"compiling-a-string"},"Compiling a string"),(0,l.kt)("p",null,"A string constant can be specified by just putting it in quotes. Like ",(0,l.kt)("inlineCode",{parentName:"p"},'"this is a string constant"'),".\nThere is an escape code ",(0,l.kt)("inlineCode",{parentName:"p"},"\\")," for string:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\\n")," newline"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\\t")," tab character"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\\\\")," the ",(0,l.kt)("inlineCode",{parentName:"li"},"\\")," character"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},'\\"')," the ",(0,l.kt)("inlineCode",{parentName:"li"},'"')," character"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"\\cXX")," where ",(0,l.kt)("inlineCode",{parentName:"li"},"XX")," is a two character hex number: insert this character."),(0,l.kt)("li",{parentName:"ul"},"Any other character following a ",(0,l.kt)("inlineCode",{parentName:"li"},"\\")," is an error.")),(0,l.kt)("p",null,"OpenGOAL stores strings in the same segment of the function which uses the string. I believe GOAL does the same."),(0,l.kt)("p",null,'In GOAL, string constants are pooled per object file (or perhaps per segment)- if the same string appears twice, it is only included once. OpenGOAL currently does not pool strings. If any code is found that modifies a string "constant", or if repeated strings take up too much memory, string pooling will be added.'),(0,l.kt)("p",null,"For now I will assume that string constants are never modified."),(0,l.kt)("h2",{id:"compiling-a-float"},"Compiling a float"),(0,l.kt)("p",null,"A floating point constant is distinguished from an integer by a decimal point. Leading/trailing zeros are optional. Examples of floats: ",(0,l.kt)("inlineCode",{parentName:"p"},"1.0, 1., .1, -.1, -0.2"),".  Floats are stored in memory, so it may be possible to modify a float constant. For now I will assume that float constants are never modified. It is unknown if they are pooled like strings."),(0,l.kt)("p",null,"Trivia: Jak 2 realized that it's faster to store floats inline in the code."),(0,l.kt)("h2",{id:"compiling-a-symbol"},"Compiling a symbol"),(0,l.kt)("p",null,"A ",(0,l.kt)("inlineCode",{parentName:"p"},"symbol")," appearing in code is compiled by trying each of these in the following order"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Is it ",(0,l.kt)("inlineCode",{parentName:"li"},"none"),"? (see section on ",(0,l.kt)("inlineCode",{parentName:"li"},"none"),")"),(0,l.kt)("li",{parentName:"ol"},"Try ",(0,l.kt)("inlineCode",{parentName:"li"},"mlet")," symbols"),(0,l.kt)("li",{parentName:"ol"},'Try "lexical" variables (defined in ',(0,l.kt)("inlineCode",{parentName:"li"},"let"),")"),(0,l.kt)("li",{parentName:"ol"},"Try global constants"),(0,l.kt)("li",{parentName:"ol"},"Try global variables (includes named functions and all types)")),(0,l.kt)("h2",{id:"the-special-none-type"},"The Special ",(0,l.kt)("inlineCode",{parentName:"h2"},"none")," type"),(0,l.kt)("p",null,"Anything which doesn't return anything has a return type of ",(0,l.kt)("inlineCode",{parentName:"p"},"none"),", indicating the return value can't be used.  This is similar to C's ",(0,l.kt)("inlineCode",{parentName:"p"},"void"),"."),(0,l.kt)("h2",{id:"goal-structs-vs-c-structs"},"GOAL Structs vs. C Structs"),(0,l.kt)("p",null,"There is one significant difference between C and GOAL when it comes to structs/classes - GOAL variables can only be references to structs."),(0,l.kt)("p",null,"As an example, consider a GOAL type ",(0,l.kt)("inlineCode",{parentName:"p"},"my-type")," and a C type ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type"),".  In C/C++, a variable of type ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type")," represents an entire copy of a ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type")," object, and a ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type*")," is like a reference to an existing ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type")," object.  In GOAL, an object of ",(0,l.kt)("inlineCode",{parentName:"p"},"my-type")," is a reference to an existing ",(0,l.kt)("inlineCode",{parentName:"p"},"my-type")," object, like a C ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type*"),".  There is no equivalent to a C/C++ ",(0,l.kt)("inlineCode",{parentName:"p"},"my_type"),"."),(0,l.kt)("p",null,"As a result you cannot pass or return a structure by value."),(0,l.kt)("p",null,"Another way to explain this is that GOAL structures (including ",(0,l.kt)("inlineCode",{parentName:"p"},"pair"),") always have reference semantics.  All other GOAL types have value semantics."),(0,l.kt)("h2",{id:"pointers"},"Pointers"),(0,l.kt)("p",null,"GOAL pointers work a lot like C/C++ pointers, but have some slight differences:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A C ",(0,l.kt)("inlineCode",{parentName:"li"},"int32_t*")," is a GOAL ",(0,l.kt)("inlineCode",{parentName:"li"},"(pointer int32)")),(0,l.kt)("li",{parentName:"ul"},"A C ",(0,l.kt)("inlineCode",{parentName:"li"},"void*")," is a GOAL ",(0,l.kt)("inlineCode",{parentName:"li"},"pointer")),(0,l.kt)("li",{parentName:"ul"},"In C, if ",(0,l.kt)("inlineCode",{parentName:"li"},"x")," is a ",(0,l.kt)("inlineCode",{parentName:"li"},"int32_t*"),", ",(0,l.kt)("inlineCode",{parentName:"li"},"x + 1")," is equivalent to ",(0,l.kt)("inlineCode",{parentName:"li"},"uintptr_t(x) + sizeof(int32_t)"),".  In GOAL, all pointer math is done in units of bytes."),(0,l.kt)("li",{parentName:"ul"},"In C, you can't do pointer math on a ",(0,l.kt)("inlineCode",{parentName:"li"},"void*"),". In GOAL you can, and all math is done in units of bytes.")),(0,l.kt)("p",null,"In both C and GOAL, there is a connection between arrays and pointers.  A GOAL array field will have a pointer-to-element type, and a pointer can be accessed as an array."),(0,l.kt)("p",null,"One confusing thing is that a ",(0,l.kt)("inlineCode",{parentName:"p"},"(pointer int32)")," is a C ",(0,l.kt)("inlineCode",{parentName:"p"},"int32_t*"),", but a ",(0,l.kt)("inlineCode",{parentName:"p"},"(pointer my-structure-type)")," is a C ",(0,l.kt)("inlineCode",{parentName:"p"},"my_structure_type**"),", because a GOAL ",(0,l.kt)("inlineCode",{parentName:"p"},"my-structure-type")," is like a C ",(0,l.kt)("inlineCode",{parentName:"p"},"my_structure_type*"),"."),(0,l.kt)("h2",{id:"inline-arrays"},"Inline Arrays"),(0,l.kt)("p",null,"One limitation of the system above is that an array of ",(0,l.kt)("inlineCode",{parentName:"p"},"my_structure_type")," is actually an array of references to structures (C ",(0,l.kt)("inlineCode",{parentName:"p"},"object*[]"),").  It would be more efficient if instead we had an array of structures, laid out together in memory (C ",(0,l.kt)("inlineCode",{parentName:"p"},"object[]"),")."),(0,l.kt)("p",null,'GOAL has a "inline array" to represent this.  A GOAL ',(0,l.kt)("inlineCode",{parentName:"p"},"(inline-array thing)")," is like a C ",(0,l.kt)("inlineCode",{parentName:"p"},"thing[]"),". The inline-array can only be used on structure types, as these are the only reference types."),(0,l.kt)("h2",{id:"fields-in-structs"},"Fields in Structs"),(0,l.kt)("p",null,"For a field with a reference type (structure/basic)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data thing)")," is like C ",(0,l.kt)("inlineCode",{parentName:"li"},"Thing* data;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data thing :inline #t)")," is like C ",(0,l.kt)("inlineCode",{parentName:"li"},"Thing data;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data thing 12)")," is like C ",(0,l.kt)("inlineCode",{parentName:"li"},"Thing* data[12];"),". The field has ",(0,l.kt)("inlineCode",{parentName:"li"},"(pointer thing)")," type."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data thing 12 :inline #t)")," is like ",(0,l.kt)("inlineCode",{parentName:"li"},"Thing data[12];"),". The field has ",(0,l.kt)("inlineCode",{parentName:"li"},"(inline-array thing)")," type")),(0,l.kt)("p",null,"For a field with a value type (integer, etc)"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data int32)")," is like C ",(0,l.kt)("inlineCode",{parentName:"li"},"int32_t data;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"(data int32 12)")," is like ",(0,l.kt)("inlineCode",{parentName:"li"},"int32_t data[12];"),". The field has ",(0,l.kt)("inlineCode",{parentName:"li"},"(array int32)")," type.")),(0,l.kt)("p",null,"Using the ",(0,l.kt)("inlineCode",{parentName:"p"},":inline #t")," option on a value type is not allowed."),(0,l.kt)("h2",{id:"dynamic-structs"},"Dynamic Structs"),(0,l.kt)("p",null,"GOAL structure can be dynamically sized, which means their size isn't determined at compile time. Instead the user should implement ",(0,l.kt)("inlineCode",{parentName:"p"},"asize-of")," to return the actual size."),(0,l.kt)("p",null,"This works by having the structure end in an array of unknown size at compile time. In a dynamic structure definition, the last field of the struct should be an array with an unspecified size. To create this, add a ",(0,l.kt)("inlineCode",{parentName:"p"},":dynamic #t")," option to the field and do not specify an array size.  This can be an array of value types, an array of reference types, or an inline-array of reference types."),(0,l.kt)("h3",{id:"unknown"},"Unknown"),(0,l.kt)("p",null,"Is the ",(0,l.kt)("inlineCode",{parentName:"p"},"size")," of a dynamic struct:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"size assuming the dynamic array has 0 elements (I think it's this)"),(0,l.kt)("li",{parentName:"ul"},"size assuming the dynamic array doesn't")),(0,l.kt)("p",null,"These can differ by padding for alignment."),(0,l.kt)("h2",{id:"how-to-create-goal-objects---new"},"How To Create GOAL Objects - ",(0,l.kt)("inlineCode",{parentName:"h2"},"new")),(0,l.kt)("p",null,"GOAL has several different ways to create objects, all using the ",(0,l.kt)("inlineCode",{parentName:"p"},"new")," form."),(0,l.kt)("h3",{id:"heap-allocated-objects"},"Heap Allocated Objects"),(0,l.kt)("p",null,"A new object can be allocated on a heap with ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'global 'obj-type [new-method-arguments])"),".\nThis simply calls the ",(0,l.kt)("inlineCode",{parentName:"p"},"new")," method of the given type. You can also replace ",(0,l.kt)("inlineCode",{parentName:"p"},"'global")," with ",(0,l.kt)("inlineCode",{parentName:"p"},"'debug"),' to allocate on the debug heap.\nCurrently these are the only two heaps supported, in the future you will be able to call the new method with other arguments\nto allow you to do an "in place new" or allocate on a different heap.'),(0,l.kt)("p",null,"This will only work on structures and basics. If you want a heap allocated float/integer/pointer, create an array of size 1.\nThis will work on dynamically sized items."),(0,l.kt)("h3",{id:"heap-allocated-arrays"},"Heap Allocated Arrays"),(0,l.kt)("p",null,"You can construct a heap array with ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'global 'inline-array 'obj-type count)")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'global 'array 'obj-type count)"),".\nThese objects are not initialized. Note that the ",(0,l.kt)("inlineCode",{parentName:"p"},"array")," version creates a ",(0,l.kt)("inlineCode",{parentName:"p"},"(pointer obj-type)")," plain array,\n",(0,l.kt)("strong",{parentName:"p"},"not")," a GOAL ",(0,l.kt)("inlineCode",{parentName:"p"},"array")," type fancy array.  In the future this may change because it is confusing."),(0,l.kt)("p",null,"Because these objects are uninitialized, you cannot provide constructor arguments.\nYou cannot use this on dynamically sized member types. However, the array size can be determined at runtime."),(0,l.kt)("h3",{id:"static-objects"},"Static Objects"),(0,l.kt)("p",null,"You can create a static object with ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'static 'obj-type [field-def]...)"),". It can be a structure, basic, bitfield, array, boxed array, or inline array.\nEach field def looks like ",(0,l.kt)("inlineCode",{parentName:"p"},":field-name field-value"),". The ",(0,l.kt)("inlineCode",{parentName:"p"},"field-value")," is evaluated at compile time. Fields\ncan be integers, floats, symbols, pairs, strings, or other statics. These field values may come from macros or GOAL constants."),(0,l.kt)("p",null,"For bitfields, there is an exception, and fields can be set to expression that are not known at compile time.  The compiler will generate the appropriate code to combine the values known at compile time and run time. This exception does not apply to a bitfield inside of another ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'static ...)"),"."),(0,l.kt)("p",null,"Fields which aren't explicitly initialized are zeroed, except for the type field of basics, which is properly initialized to the correct type."),(0,l.kt)("p",null,"This does not work on dynamically sized structures."),(0,l.kt)("h3",{id:"stack-allocated-arrays"},"Stack Allocated Arrays"),(0,l.kt)("p",null,"Currently only arrays of integers, floats, or pointers can be stack allocated.\nFor example, use ",(0,l.kt)("inlineCode",{parentName:"p"},"(new 'stack ''array 'int32 1)")," to get a ",(0,l.kt)("inlineCode",{parentName:"p"},"(pointer int32)"),". Unlike heap allocated arrays, these stack arrays\nmust have a size that can be determined at compile time.  The objects are uninitialized."),(0,l.kt)("h3",{id:"stack-allocated-structures"},"Stack Allocated Structures"),(0,l.kt)("p",null,'Works like heap allocated, the objects are initialized with the constructor. The constructor must support "stack mode". Using ',(0,l.kt)("inlineCode",{parentName:"p"},"object-new")," supports stack mode so usually you don't have to worry about this.  The structure's memory will be memset to 0 with ",(0,l.kt)("inlineCode",{parentName:"p"},"object-new")," automatically."),(0,l.kt)("h3",{id:"defining-a-new-method"},"Defining a ",(0,l.kt)("inlineCode",{parentName:"h3"},"new")," Method"),(0,l.kt)("p",null,"TODO"),(0,l.kt)("h2",{id:"array-spacing"},"Array Spacing"),(0,l.kt)("p",null,"In general, all GOAL objects are 16-byte aligned and the boxing system requires this.  All heap memory allocations are 16-byte aligned too, so this is usually not an issue."),(0,l.kt)("h2",{id:"truth"},"Truth"),(0,l.kt)("p",null,"Everything is true except for ",(0,l.kt)("inlineCode",{parentName:"p"},"#f"),". This means ",(0,l.kt)("inlineCode",{parentName:"p"},"0")," is true, and ",(0,l.kt)("inlineCode",{parentName:"p"},"'()")," is true.\nThe value of ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," can be used like ",(0,l.kt)("inlineCode",{parentName:"p"},"nullptr"),", at least for any ",(0,l.kt)("inlineCode",{parentName:"p"},"basic")," object.  It's unclear if ",(0,l.kt)("inlineCode",{parentName:"p"},"#f")," can/should be used as a null for other types, including ",(0,l.kt)("inlineCode",{parentName:"p"},"structure"),"s or numbers or pointers."),(0,l.kt)("p",null,"Technical note: the hex number ",(0,l.kt)("inlineCode",{parentName:"p"},"0x147d24")," is considered false in Jak 1 NTSC due to where the symbol table happened to be allocated.  However, checking numbers for true/false shouldn't be done, you should use ",(0,l.kt)("inlineCode",{parentName:"p"},"(zero? x)")," instead."),(0,l.kt)("h2",{id:"empty-pair"},"Empty Pair"),(0,l.kt)("p",null,"TODO"))}u.isMDXComponent=!0}}]);