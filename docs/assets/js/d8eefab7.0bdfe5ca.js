"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[373],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return f}});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),p=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(r),f=n,h=m["".concat(s,".").concat(f)]||m[f]||d[f]||i;return r?a.createElement(h,o(o({ref:t},u),{},{components:r})):a.createElement(h,o({ref:t},u))}));function f(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var p=2;p<i;p++)o[p]=r[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},2215:function(e,t,r){r.r(t),r.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var a=r(7462),n=r(3366),i=(r(7294),r(3905)),o=["components"],l={sidebar_position:3},s="Basic Process for Drawing",p={unversionedId:"porting-info/tfrag",id:"porting-info/tfrag",title:"Basic Process for Drawing",description:'The first main part just gets the "drawable trees" added to the list.',source:"@site/documentation/porting-info/tfrag.md",sourceDirName:"porting-info",slug:"/porting-info/tfrag",permalink:"/docs/porting-info/tfrag",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/porting-info/tfrag.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"drawable_and_tfrag",permalink:"/docs/porting-info/drawable_and_tfrag"},next:{title:"Porting Tfrag",permalink:"/docs/porting-info/porting_tfrag"}},u={},d=[],m={toc:d};function f(e){var t=e.components,r=(0,n.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"basic-process-for-drawing"},"Basic Process for Drawing"),(0,i.kt)("p",null,'The first main part just gets the "drawable trees" added to the list.\nWhen the level loads, it gets added to the background engine in ',(0,i.kt)("inlineCode",{parentName:"p"},"level-status-set!"),".  When the background system runs, it executes this engine, which calls ",(0,i.kt)("inlineCode",{parentName:"p"},"draw")," on the ",(0,i.kt)("inlineCode",{parentName:"p"},"bsp-header"),".  Eventually ",(0,i.kt)("inlineCode",{parentName:"p"},"draw")," is called on the tfrag tree, and it gets added to the ",(0,i.kt)("inlineCode",{parentName:"p"},"*background-work*")," list."),(0,i.kt)("p",null,"The second main part builds DMA.\nThis happens from ",(0,i.kt)("inlineCode",{parentName:"p"},"finish-background"),", called from ",(0,i.kt)("inlineCode",{parentName:"p"},"real-main-draw-hook"),", called from the display loop in ",(0,i.kt)("inlineCode",{parentName:"p"},"main.gc"),".\nFor each tree, it uplaods vis data, interpolates time-of-day colors, and runs ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-drawable-tree-tfrag"),".  This sets up DMA buffers and eventually calls ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-inline-array-tfrag"),", a crazy asm function that builds the DMA lists and likely makes decisions about which LOD to draw.  Within ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-drawable-tree-tfrag"),", there's also a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-inline-array-tfrag-near")," that sets up DMA for the separate ",(0,i.kt)("inlineCode",{parentName:"p"},"near")," renderer. "),(0,i.kt)("p",null,"The third main part runs on VU1 and actually draws.\nThe DMA chain is a bunch of UNPACKs, which load data to VU memory, with some MSCALs that start VU1 programs. There are a number of different routines."),(0,i.kt)("h1",{id:"visibility"},"Visibility"),(0,i.kt)("p",null,"The visibility information is not computed yet, but I believe this is properly handled in ",(0,i.kt)("inlineCode",{parentName:"p"},"draw-inline-array-tfrag"),".  By modifying ",(0,i.kt)("inlineCode",{parentName:"p"},"upload-vis-bits")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"background.gc"),', I can change what is drawn.  There is one mystery that the tfrag "stats" change, but have totally wrong numbers.  It almost seems like it is the correct stats for what is ',(0,i.kt)("em",{parentName:"p"},"behind")," the camera."),(0,i.kt)("p",null,"As far as I can tell there are 2 or 3 types of culling:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"precomputed visibility from this VIS files. I believe this uses the bsp to figure out which string to load.  This is done as part of the camera update and modifies the visibility strings.  The vis strings aren't loaded, the bsp update isn't running, and the camera update doesn't run, so this doesn't work at all."),(0,i.kt)("li",{parentName:"ul"},"frustum culling in ",(0,i.kt)("inlineCode",{parentName:"li"},"draw-node-cull"),". The camera update sets the view frustum planes, and draw-node-cull iterates through the draw node tree (up to 8 at a time, using the fancy MMI instructions).  The camera update doesn't run, so those planes aren't set. Also, the draw-node-cull function isn't ported yet."),(0,i.kt)("li",{parentName:"ul"},"possibly additional culling in the ",(0,i.kt)("inlineCode",{parentName:"li"},"draw-inline-array-tfrag")," function that builds dma list.  It at least looks at the bspheres."),(0,i.kt)("li",{parentName:"ul"},"clipping in the VU1 program. This ",(0,i.kt)("em",{parentName:"li"},"appears")," to work correctly in my port, but doesn't fully work in the PS2 version - if you turn on \"fix frustum\", you get garbage.  But this might be a part of tfrag I don't have yet.")),(0,i.kt)("h1",{id:"time-of-day"},"Time of Day"),(0,i.kt)("p",null,"There's a function ",(0,i.kt)("inlineCode",{parentName:"p"},"time-of-day-interp-colors-scratch")," that computes the time-of-day lighting coloring. The 8 w components of times are the multiplier for the 8 precomputed lighting maps."),(0,i.kt)("h1",{id:"different-tfrag-renderers-not-really"},"Different TFrag Renderers? Not really"),(0,i.kt)("p",null,"There are different types of drawable trees that are all tfrag:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-trans-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-dirt-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-ice-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-lowres-tfrag")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-lowres-trans-tfrag"),"\nAs far as I can tell, they are all drawn in almost exactly the same way.  The different trees are just used:"),(0,i.kt)("li",{parentName:"ul"},"to give you an ordering. For example, everything in ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-tfrag")," is drawn before  ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-ice-tfrag"),".  This probably matters for transparent things."),(0,i.kt)("li",{parentName:"ul"},"to have slightly different settings passed to the GS. As far as I can see the only differences are with ztest and alpha GS registers."),(0,i.kt)("li",{parentName:"ul"},"to have different textures in VRAM. The ",(0,i.kt)("inlineCode",{parentName:"li"},"alpha")," textures are uploaded after  ",(0,i.kt)("inlineCode",{parentName:"li"},"drawable-tree-tfrag"),".")),(0,i.kt)("h1",{id:"near-vs-far"},"Near vs Far"),(0,i.kt)("p",null,"There are two separate tfrag renderers: near and far. They are separate VU1 programs.  The tfragments themselves are not specialized per renderer, but the DMA lists might be."),(0,i.kt)("p",null,'I am not sure, but I believe that both near and far versions are capable of rendering the full-detail mesh, and the main purpose of "near" is to perform scissoring on the VUs. I believe it can detect triangles that intersect the edge of the screen and divide them into multiple triangles, throwing away the parts that are off screen.  The "far" version can\'t do this.'),(0,i.kt)("h1",{id:"different-vu1-subroutines"},"Different VU1 subroutines"),(0,i.kt)("p",null,'The "far" render has many subroutines.  Currently I have only ported "program 6" and with a modification to remove about half the code. Internally, on VU1, tfrag double buffers GIF data.  One packed will be getting "XGKICK"ed while another is being built. They have a pretty complicated system for switching this buffer (it\'s not synced to the XTOP UNPACK double buffering stuff, like it was on sprite), but I removed this feature and could get of half the packet building code, which is mostly a duplicate.'),(0,i.kt)("p",null,'This "program 6" is not capable of interpolating the mesh and just draws at one level of detail.  But it is capable of drawing at ',(0,i.kt)("em",{parentName:"p"},"different")," levels of detail (at least 2).  I suspect there are other programs for interpolating the mesh and doing color computations."),(0,i.kt)("p",null,"Annoyingly, even tfragments that are at a single LOD, but border tfragments of a different LOD must have a special interpolation applied to them."),(0,i.kt)("p",null,'There is at least one other "drawing" program. I tried using program 6 when the game wanted other programs, and surprisingly it drew more stuff. But every now and then, things go wrong and it generates garbage data when running like this.'),(0,i.kt)("p",null,"Example sequence (from start of frame): ",(0,i.kt)("inlineCode",{parentName:"p"},"[8, 10, 10, 10, 6, 6, 6...]"),"."),(0,i.kt)("p",null,"Program list:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Program 0: init globals (TFrag.cpp handles this)"),(0,i.kt)("li",{parentName:"ul"},"Program 2: reset the value of VF04 (nothing uses this?), but only 1 instruction long."),(0,i.kt)("li",{parentName:"ul"},"Program 4: unported drawing program (L112 transform, L79 kick) (unused?)"),(0,i.kt)("li",{parentName:"ul"},"Program 6: ported drawing program (L127 transform, L122 kick) (most common)"),(0,i.kt)("li",{parentName:"ul"},"Program 8: runs sub L12, L26, L48, L102 (2nd most common)"),(0,i.kt)("li",{parentName:"ul"},"Program 10: runs sub L12, L18, L102"),(0,i.kt)("li",{parentName:"ul"},"Program 12: same as program 6 (ported)"),(0,i.kt)("li",{parentName:"ul"},"Program 14: runs sub L12, L18, L25, L47, L102"),(0,i.kt)("li",{parentName:"ul"},"Program 16: runs sub L13, L17, L102"),(0,i.kt)("li",{parentName:"ul"},"Program 18: runs sub L13, L17, L84"),(0,i.kt)("li",{parentName:"ul"},"Program 20: same as program 6 (ported)"),(0,i.kt)("li",{parentName:"ul"},"Program 22: same as program 2 (unused?)"),(0,i.kt)("li",{parentName:"ul"},"Program 24: same as program 2 (unused?)")),(0,i.kt)("p",null,"Sub List:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"L12/L13 (jal)",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"very short, no drawing. looks like transformation + int to float.  Has the camera matrix.")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L17/L18 (jal)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"also transformations with cam matrix. Looks at the subdivide. Likely part of mesh interp. Has two versions for buffer (2nd starts at L22)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L25/L26 (jal)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"also transformations. L37 is 2nd buffer version"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L47")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L48")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L84")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"L102"))))}f.isMDXComponent=!0}}]);