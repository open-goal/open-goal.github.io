"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[749],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return u}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,h=d["".concat(s,".").concat(u)]||d[u]||c[u]||r;return n?a.createElement(h,o(o({ref:t},m),{},{components:n})):a.createElement(h,o({ref:t},m))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},518:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),o=["components"],l={sidebar_position:1},s="Compiler Example",p={unversionedId:"developing/compiler_example",id:"developing/compiler_example",title:"Compiler Example",description:"This describes how the compiler works using the following code snippet, saved in a file named example_goal.gc.",source:"@site/documentation/developing/compiler_example.md",sourceDirName:"developing",slug:"/developing/compiler_example",permalink:"/docs/developing/compiler_example",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/developing/compiler_example.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",previous:{title:"Developing",permalink:"/docs/category/developing"},next:{title:"Assembly Emitter",permalink:"/docs/developing/asm_emitter"}},m={},c=[{value:"Overview",id:"overview",level:2},{value:"Reader",id:"reader",level:2},{value:"IR Pass",id:"ir-pass",level:2},{value:"IR Pass Implementation",id:"ir-pass-implementation",level:3},{value:"Following the Code",id:"following-the-code",level:3},{value:"Register Allocation",id:"register-allocation",level:2},{value:"Code Generation",id:"code-generation",level:2},{value:"Object File Generation",id:"object-file-generation",level:2},{value:"Sending and Receiving",id:"sending-and-receiving",level:2}],d={toc:c};function u(e){var t=e.components,n=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"compiler-example"},"Compiler Example"),(0,r.kt)("p",null,"This describes how the compiler works using the following code snippet, saved in a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"example_goal.gc"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},'(defun factorial-iterative ((x integer))\n  (let ((result 1))\n    (while (!= x 1)\n       (set! result (* result x))\n       (set! x (- x 1))\n       )\n    result\n    )\n  )\n\n;; until we load KERNEL.CGO automatically, we have to do this to\n;; make format work correctly.\n(define-extern _format function)\n(define format _format)\n\n(let ((x 10))\n  (format #t "The value of ~D factorial is ~D~%" x (factorial-iterative x))\n  )\n')),(0,r.kt)("p",null,"To run this yourself, start the compiler and runtime, then run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},'(lt)\n(asm-file "doc/example_goal.gc" :color :load)\n')),(0,r.kt)("p",null,"And you should see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"The value of 10 factorial is 3628800\n")),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The code to read from the GOAL REPL is in ",(0,r.kt)("inlineCode",{parentName:"p"},"Compiler.cpp"),", in ",(0,r.kt)("inlineCode",{parentName:"p"},"Compiler::execute_repl"),". Compiling an ",(0,r.kt)("inlineCode",{parentName:"p"},"asm-file")," form will call ",(0,r.kt)("inlineCode",{parentName:"p"},"Compiler::compile_asm_file")," in ",(0,r.kt)("inlineCode",{parentName:"p"},"CompilerControl.cpp"),", which is where we'll start."),(0,r.kt)("p",null,"I've divided the process into these steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Read"),": Convert from text to a representation of Lisp syntax."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"IR-Pass"),": Convert the S-Expressions to an intermediate representation (IR)."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Register Allocation"),": Map variables in the IR (",(0,r.kt)("inlineCode",{parentName:"li"},"IRegister"),"s) to real hardware registers"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Code Generation"),": Generate x86-64 instructions from the IR"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Object File Generation"),": Put the instructions and static data in an object file and generate linking data"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Sending"),": Send the code to the runtime"),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Linking"),": The runtime links the code so it can be run, and runs it."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Result"),": The code prints the message which is sent back to the REPL.")),(0,r.kt)("h2",{id:"reader"},"Reader"),(0,r.kt)("p",null,"The reader converts GOAL/GOOS source into a ",(0,r.kt)("inlineCode",{parentName:"p"},"goos::Object"),'. One of the core ideas of lisp is that "code is data", so GOAL code is represented as GOOS data.  This makes it easy for GOOS macros to operate on GOAL code.  A GOOS object can represent a number, string, pair, etc. This strips out comments/whitespace.'),(0,r.kt)("p",null,"The reader is run with this code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto code = m_goos.reader.read_from_file({filename});\n")),(0,r.kt)("p",null,"If you were to ",(0,r.kt)("inlineCode",{parentName:"p"},"code.print()"),", you would get:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},'(top-level (defun factorial-iterative ((x integer)) (let ((result 1)) (while (!= x 1) (set! result (* result x)) (set! x (- x 1))) result)) (define-extern _format function) (define format _format) (let ((x 10)) (format #t "The value of ~D factorial is ~D~%" x (factorial-iterative x))))\n')),(0,r.kt)("p",null,"There are a few details worth mentioning about this process:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The reader will expand ",(0,r.kt)("inlineCode",{parentName:"li"},"'my-symbol")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"(quote my-symbol)")),(0,r.kt)("li",{parentName:"ul"},"The reader will throw errors on syntax errors (mismatched parentheses, bad strings/numbers, etc.)"),(0,r.kt)("li",{parentName:"ul"},"Using ",(0,r.kt)("inlineCode",{parentName:"li"},"read_from_file")," adds information about where each thing came from to a map stored in the reader.  This map is used to determine the source file/line for compiler errors.")),(0,r.kt)("h2",{id:"ir-pass"},"IR Pass"),(0,r.kt)("p",null,"This pass converts code (represented as a ",(0,r.kt)("inlineCode",{parentName:"p"},"goos::Object"),") into intermediate representation.  This is stored in an ",(0,r.kt)("inlineCode",{parentName:"p"},"Env*"),", a tree structure.  At the top is a ",(0,r.kt)("inlineCode",{parentName:"p"},"GlobalEnv*"),", then an ",(0,r.kt)("inlineCode",{parentName:"p"},"FileEnv")," for each file compiled, then a ",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionEnv")," for each function in the file.  There are environments within ",(0,r.kt)("inlineCode",{parentName:"p"},"FunctionEnv")," that are used for lexical scoping and the other types of GOAL scopes. The Intermediate Representation (IR) is a list per function that's built up in order as the compiler goes through the function. Note that the IR is a list of instructions and doesn't have a tree or more complicated structure.  Here's an example of the IR for the example function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-nasm"},"Function: function-factorial-iterative\n  mov-ic igpr-2, 1\n  mov igpr-3, igpr-2\n  goto label-10\n  mov igpr-4, igpr-3\n  imul igpr-4, igpr-0\n  mov igpr-3, igpr-4\n  mov igpr-5, igpr-0\n  mov-ic igpr-6, 1\n  subi igpr-5, igpr-6\n  mov igpr-0, igpr-5\n  mov-ic igpr-7, 1\n  j(igpr-0 != igpr-7) label-3\n  ret igpr-1 igpr-3\n\nFunction: function-top-level\n  mov-fa igpr-0, function-factorial-iterative\n  mov 'factorial-iterative, igpr-0\n  mov igpr-1, '_format\n  mov 'format, igpr-1\n  mov-ic igpr-2, 10\n  mov igpr-3, igpr-2\n  mov igpr-4, '#t\n  mov-sva igpr-5, static-string \"The value of ~D factorial is ~D~%\"\n  mov igpr-6, 'factorial-iterative\n  mov igpr-8, igpr-3\n  call igpr-6 (ret igpr-7) (args igpr-8)\n  mov igpr-9, igpr-7\n  mov igpr-10, 'format\n  mov igpr-12, igpr-4\n  mov igpr-13, igpr-5\n  mov igpr-14, igpr-3\n  mov igpr-15, igpr-9\n  call igpr-10 (ret igpr-11) (args igpr-12 igpr-13 igpr-14 igpr-15)\n  mov igpr-16, igpr-11\n  ret igpr-17 igpr-16\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"function-top-level"),' is the "top level" function, which is everything not in a function. In the example, this is just defining the function, defining ',(0,r.kt)("inlineCode",{parentName:"p"},"format"),", and calling ",(0,r.kt)("inlineCode",{parentName:"p"},"format"),"."),(0,r.kt)("p",null,"You'll notice that there are a ton of ",(0,r.kt)("inlineCode",{parentName:"p"},"mov"),"s between ",(0,r.kt)("inlineCode",{parentName:"p"},"igpr"),". The compiler inserts tons of moves. Because this is all done in a single pass, there's a lot of cases where the compiler can't know if a move is needed or not. But the register allocator can figure it out and will remove most unneeded moves.  Adding moves can also prevent stack spills. For example, consider the case where you want to get the return value of function ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", then call function ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),", then call function ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," with the return value of function ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),". If there are a lot of moves, the register allocator can figure out a way to temporarily stash the value in a saved register instead of spilling to the stack."),(0,r.kt)("p",null,"Another thing to notice is that GOAL nested function calls suck. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},'(format #t "The value of ~D factorial is ~D~%" x (factorial-iterative x))\n')),(0,r.kt)("p",null,"requires loading ",(0,r.kt)("inlineCode",{parentName:"p"},"format"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#t"),", the string, and ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," into registers, then calling ",(0,r.kt)("inlineCode",{parentName:"p"},"(factorial-iterative x)"),", then calling ",(0,r.kt)("inlineCode",{parentName:"p"},"format"),". This has to be done this way, just in case the ",(0,r.kt)("inlineCode",{parentName:"p"},"factorial-iterative")," call modifies the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"format"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#t"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,r.kt)("h3",{id:"ir-pass-implementation"},"IR Pass Implementation"),(0,r.kt)("p",null,"An important type in the compiler is ",(0,r.kt)("inlineCode",{parentName:"p"},"Val"),", which is a specification on how to get a value.  A ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," has an associated GOAL type (",(0,r.kt)("inlineCode",{parentName:"p"},"TypeSpec"),") and the IR Pass should take care of all type checking.  A ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," can represent a constant, a memory location (relative to pointer, or static data, etc), a spot in an array, a register etc.  A ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," representing a register is a ",(0,r.kt)("inlineCode",{parentName:"p"},"RegVal"),", which contains an ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),". An ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister")," is a register that's not yet mapped to the hardware, and instead has a unique integer to identify itself. The IR assumes there are infinitely many ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s, and a later stage maps ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s to real hardware registers."),(0,r.kt)("p",null,"The general process starts with a ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," function, which dispatches other ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_<thing>")," functions as needed.  These generally take in ",(0,r.kt)("inlineCode",{parentName:"p"},"goos::Object")," as a code input, emit IR into an ",(0,r.kt)("inlineCode",{parentName:"p"},"Env"),"/or modify things in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Env"),", and return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Val*")," describing the result."),(0,r.kt)("p",null,"In general, GOAL is very greedy and ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," functions emit IR to do things, then put the result in a register, and return a ",(0,r.kt)("inlineCode",{parentName:"p"},"RegVal"),"."),(0,r.kt)("p",null,"However, there is an exception for memory related things.  Consider"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(-> my-object my-field) ;  my_object->my_field in C\n")),(0,r.kt)("p",null,"This shouldn't return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," for a register containing the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"my_object->my_field"),', but should instead return something that represents "the memory location of my_field in my_object". This way you can do'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(set! (-> my-object my-field) val)\n;; or\n(& (-> my-object my-field)) ;; &my_object->my_field\n")),(0,r.kt)("p",null,"and the compiler will have enough information to figure out the memory address."),(0,r.kt)("p",null,"If the compiler actually needs the value of something, and wants to be sure its a value in a register, it will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"Val"),". This will emit IR into the current function to get the value in a register, then return a ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," that represents this register.  Example ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg")," implementation for integer constants:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"RegVal* IntegerConstantVal::to_reg(Env* fe) {\n  auto rv = fe->make_gpr(m_ts);\n  fe->emit(std::make_unique<IR_LoadConstant64>(rv, m_value));\n  return rv;\n}\n")),(0,r.kt)("p",null,"Note that ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg")," can emit code like reading from memory, where the order of operations really matters, so you have to be very careful."),(0,r.kt)("p",null,"It's extremely dangerous to let a memory reference ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," propagate too far. Consider this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(let ((x (-> my-object my-field)))\n  (set! (-> my-object my-field) 12)\n  x\n  )\n")),(0,r.kt)("p",null,"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," should be the old value of ",(0,r.kt)("inlineCode",{parentName:"p"},"my-field"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"x")," needs to be ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg"),"ed ",(0,r.kt)("em",{parentName:"p"},"before")," getting inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),". There's also some potential confusion around the order that you compile and ",(0,r.kt)("inlineCode",{parentName:"p"},"to_gpr")," things.  In a case where you need a bunch of values in gprs, you should do the ",(0,r.kt)("inlineCode",{parentName:"p"},"to_gpr")," immediately after compiling to match the exact behavior of the original GOAL. For example"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},"(+ (-> my-array (* x y)) (some-function))\n;; like c++ my_array[x*y] + some_function()\n")),(0,r.kt)("p",null,"When we ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"(-> my-array (* x y))"),", it will emit code to calculate the ",(0,r.kt)("inlineCode",{parentName:"p"},"(*x y)"),", but won't actually do the memory access until we call ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg")," on the result.  This memory access should happen ",(0,r.kt)("strong",{parentName:"p"},"before")," ",(0,r.kt)("inlineCode",{parentName:"p"},"some-function")," is called."),(0,r.kt)("p",null,"In general, each time you ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," something, you should immediately ",(0,r.kt)("inlineCode",{parentName:"p"},"to_gpr")," it, ",(0,r.kt)("em",{parentName:"p"},"before")," ",(0,r.kt)("inlineCode",{parentName:"p"},"compile"),"ing the next thing.  Many places will only accept a ",(0,r.kt)("inlineCode",{parentName:"p"},"RegVal")," as an input to help with this.  Also, the result for almost all compilation functions should be ",(0,r.kt)("inlineCode",{parentName:"p"},"to_reg"),"ed. The only exceptions are forms which deal with memory references (address of operator, dereference operator) or math."),(0,r.kt)("p",null,"Another important thing is that compilation functions should ",(0,r.kt)("em",{parentName:"p"},"never")," modify any existing ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s or ",(0,r.kt)("inlineCode",{parentName:"p"},"Val"),"s, unless that function is ",(0,r.kt)("inlineCode",{parentName:"p"},"set!"),", which handles the situation correctly. Instead, create new ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s and move into those. I am planning to implement a ",(0,r.kt)("inlineCode",{parentName:"p"},"settable")," flag to help reduce errors."),(0,r.kt)("p",null,"For example:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegVal")," storing a local variable: is ",(0,r.kt)("inlineCode",{parentName:"li"},"settable"),", you can modify local variables by writing to the register they use."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegVal")," storing the result of a memory dereference: not ",(0,r.kt)("inlineCode",{parentName:"li"},"settable"),", you should set the memory instead."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegVal")," containing the result of converting a ",(0,r.kt)("inlineCode",{parentName:"li"},"xmm")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"gpr"),": not settable, you need to set the original ",(0,r.kt)("inlineCode",{parentName:"li"},"xmm")," instead")),(0,r.kt)("p",null,"The only settable ",(0,r.kt)("inlineCode",{parentName:"p"},"RegVal")," is one corresponding to a local variable."),(0,r.kt)("h3",{id:"following-the-code"},"Following the Code"),(0,r.kt)("p",null,"This pass runs from here:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto obj_file = compile_object_file(obj_file_name, code, !no_code);\n")),(0,r.kt)("p",null,"That function sets up a ",(0,r.kt)("inlineCode",{parentName:"p"},"FileEnv*"),", then runs"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'  file_env->add_top_level_function(\n      compile_top_level_function("top-level", std::move(code), compilation_env));\n')),(0,r.kt)("p",null,"which compiles the body of the function with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto result = compile_error_guard(code, fe.get());\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_error_guard")," function takes in code (as a ",(0,r.kt)("inlineCode",{parentName:"p"},"goos::Object"),") and a ",(0,r.kt)("inlineCode",{parentName:"p"},"Env*"),", and returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"Val")," representing the return value of the code. It calls the ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," function, but wraps it in a ",(0,r.kt)("inlineCode",{parentName:"p"},"try catch")," block to catch any compilation errors and print an error message.  In the case where there's no error, it just does:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"return compile(code, env);\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"compile")," function is pretty simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'/*!\n * Highest level compile function\n */\nVal* Compiler::compile(const goos::Object& code, Env* env) {\n  switch (code.type) {\n    case goos::ObjectType::PAIR:\n      return compile_pair(code, env);\n    case goos::ObjectType::INTEGER:\n      return compile_integer(code, env);\n    case goos::ObjectType::SYMBOL:\n      return compile_symbol(code, env);\n    case goos::ObjectType::STRING:\n      return compile_string(code, env);\n    case goos::ObjectType::FLOAT:\n      return compile_float(code, env);\n    default:\n      ice("Don\'t know how to compile " + code.print());\n  }\n  return get_none();\n}\n')),(0,r.kt)("p",null,"In our case, the code starts with ",(0,r.kt)("inlineCode",{parentName:"p"},"(defun.."),", which is actually a GOOS macro. It throws away the docstring, creates a lambda, then stores the function in a symbol:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lisp"},";; Define a new function\n(defmacro defun (name bindings &rest body)\n  (if (and\n        (> (length body) 1)      ;; more than one thing in function\n        (string? (first body))   ;; first thing is a string\n        )\n    ;; then it's a docstring and we ignore it.\n    `(define ,name (lambda :name ,name ,bindings ,@(cdr body)))\n    ;; otherwise don't ignore it.\n    `(define ,name (lambda :name ,name ,bindings ,@body))\n    )\n  )\n")),(0,r.kt)("p",null,"The compiler notices this is a macro in ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_pair"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"  if (head.is_symbol()) {\n    // ...\n\n    goos::Object macro_obj;\n    if (try_getting_macro_from_goos(head, &macro_obj)) {\n      return compile_goos_macro(code, macro_obj, rest, env);\n    }\n\n    // ...\n  }\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_goos_macro")," function sets up a GOOS environment and interprets the GOOS macro to generate more GOAL code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"Val* Compiler::compile_goos_macro(const goos::Object& o,\n                                  const goos::Object& macro_obj,\n                                  const goos::Object& rest,\n                                  Env* env) {\n  auto macro = macro_obj.as_macro();\n  Arguments args = m_goos.get_args(o, rest, macro->args);\n  auto mac_env_obj = EnvironmentObject::make_new(); // GOOS environment\n  auto mac_env = mac_env_obj.as_env();\n  mac_env->parent_env = m_goos.global_environment.as_env();\n  m_goos.set_args_in_env(o, args, macro->args, mac_env);\n  auto goos_result = m_goos.eval_list_return_last(macro->body, macro->body, mac_env); // evaluate GOOS macro\n  return compile_error_guard(goos_result, env); // compile resulting GOAL code\n}\n")),(0,r.kt)("p",null,"and the last line of that function compiles the result of macro expansion in GOAL."),(0,r.kt)("p",null,"As an example, I'm going to look at ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_add"),", which handles the ",(0,r.kt)("inlineCode",{parentName:"p"},"+")," form, and is representative of typical compiler code for this part.  We start by checking that the arguments look valid:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'Val* Compiler::compile_add(const goos::Object& form, const goos::Object& rest, Env* env) {\n  auto args = get_va(form, rest); // get arguments to + in a list\n  if (!args.named.empty() || args.unnamed.empty()) {\n    throw_compile_error(form, "Invalid + form");\n  }\n')),(0,r.kt)("p",null,"Then we compile the first thing in the ",(0,r.kt)("inlineCode",{parentName:"p"},"(+ ...")," form, get its type, and pick a math mode (int, float):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto first_val = compile_error_guard(args.unnamed.at(0), env);\nauto first_type = first_val->type();\nauto math_type = get_math_mode(first_type);\n")),(0,r.kt)("p",null,"In the integer case, we first create a new variable in the IR called an ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister")," that must be in a GPR (as opposed to an XMM floating point register), and then emit an IR instruction that sets this result register to the first argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto result = env->make_gpr(first_type);\nenv->emit(std::make_unique<IR_RegSet>(result, first_val->to_gpr(env)));\n")),(0,r.kt)("p",null,"Then, for each of the remaining arguments, we do:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"      for (size_t i = 1; i < args.unnamed.size(); i++) {\n        env->emit(std::make_unique<IR_IntegerMath>(\n            IntegerMathKind::ADD_64, result,\n            to_math_type(compile_error_guard(args.unnamed.at(i), env), math_type, env)\n                ->to_gpr(env)));\n      }\n")),(0,r.kt)("p",null,"which emits an IR to add the value to the sum.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"to_math_type")," will emit any code needed to convert this to the correct numeric type (returns either a numeric constant or a ",(0,r.kt)("inlineCode",{parentName:"p"},"RegVal")," containing the value)."),(0,r.kt)("p",null,"An important detail is that we create a new register which will hold the result. This may seem inefficient in cases, but a later compile pass will try to make this new register be the same register as ",(0,r.kt)("inlineCode",{parentName:"p"},"first_val")," if possible, and will eliminate the ",(0,r.kt)("inlineCode",{parentName:"p"},"IR_RegSet"),"."),(0,r.kt)("h2",{id:"register-allocation"},"Register Allocation"),(0,r.kt)("p",null,"This step figures out how to match up ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s to real hardware registers. In the case where there aren't enough hardware registers, it figures out how to \"spill\" variables onto the stack. The current implementation is a very greedy one, so it doesn't always succeed at doing things perfectly. The stack spilling is also not handled very efficiently, but the hope is that most functions won't require stack spilling."),(0,r.kt)("p",null,"This step is run from ",(0,r.kt)("inlineCode",{parentName:"p"},"compile_asm_function")," on the line:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"color_object_file(obj_file);\n\nvoid Compiler::color_object_file(FileEnv* env) {\n  for (auto& f : env->functions()) {\n    AllocationInput input;\n    for (auto& i : f->code()) {\n      input.instructions.push_back(i->to_rai());\n      input.debug_instruction_names.push_back(i->print());\n    }\n    input.max_vars = f->max_vars();\n    input.constraints = f->constraints();\n\n    // debug prints removed\n\n    f->set_allocations(allocate_registers(input));\n  }\n}\n")),(0,r.kt)("p",null,"The actual algorithm is too complicated to describe here, but it figures out a mapping from ",(0,r.kt)("inlineCode",{parentName:"p"},"IRegister"),"s to hardware registers. It also figures out how much space on the stack is needed for any stack spills, which saved registers will be used, and deals with aligning the stack."),(0,r.kt)("h2",{id:"code-generation"},"Code Generation"),(0,r.kt)("p",null,"This part actually generates the static data and x86 instructions and stores them in an ",(0,r.kt)("inlineCode",{parentName:"p"},"ObjectGenerator"),". See ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeGenerator::do_function"),". It emits the function prologue and epilogue, as well as any extra loads/stores from the stack that the register allocator added.  Each ",(0,r.kt)("inlineCode",{parentName:"p"},"IR")," gets to emit instructions with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"ir->do_codegen(&m_gen, allocs, i_rec);\n")),(0,r.kt)("p",null,"Each IR has its own ",(0,r.kt)("inlineCode",{parentName:"p"},"do_codegen")," that emits the right instruction, and also any linking data that's needed. For example, instructions that access the symbol table are patched by the runtime to directly access the correct slot of the hash table, so the ",(0,r.kt)("inlineCode",{parentName:"p"},"do_codegen")," also lets the ",(0,r.kt)("inlineCode",{parentName:"p"},"ObjectGenerator")," know about this link:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// IR_GetSymbolValue::do_codegen\n\n// look at register allocation result to determine hw register\nauto dst_reg = get_reg(m_dest, allocs, irec);\n\n// add an instruction\nauto instr = gen->add_instr(IGen::load32u_gpr64_gpr64_plus_gpr64_plus_s32(\n                             dst_reg, gRegInfo.get_st_reg(), gRegInfo.get_offset_reg(), 0x0badbeef), irec);\n\n// add link info\ngen->link_instruction_symbol_mem(instr, m_src->name());\n")),(0,r.kt)("p",null,"here ",(0,r.kt)("inlineCode",{parentName:"p"},"0xbadbeef")," is used as a placeholder offset - the runtime should patch this to the actual offset of the symbol."),(0,r.kt)("p",null,"There's a ton of book-keeping to figure out the correct offsets for ",(0,r.kt)("inlineCode",{parentName:"p"},"rip"),"-relative addressing, or how to deal with jumps to/from IR which become multiple (or zero!) x86-64 instructions.  It should all be handled by ",(0,r.kt)("inlineCode",{parentName:"p"},"ObjectFileGenerator"),", and not in ",(0,r.kt)("inlineCode",{parentName:"p"},"do_codegen")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeGenerator"),"."),(0,r.kt)("h2",{id:"object-file-generation"},"Object File Generation"),(0,r.kt)("p",null,"Once the ",(0,r.kt)("inlineCode",{parentName:"p"},"CodeGenerator")," is done going through all functions and static data, it runs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"return m_gen.generate_data_v3().to_vector();\n")),(0,r.kt)("p",null,"This actually lays out everything in memory. It takes a few passes because x86 instructions are variable length (may even change based on which registers are used!), so it's a little bit tricky to figure out offsets between different instructions or instructions and data. Finally it generates link data tables, which efficiently pack together links to the same symbols into a single entry, to avoid duplicated symbol names.  The link table also contains information about linking references in between different segments, as different parts of the object file may be loaded into different spots in memory, and will need to reference each other."),(0,r.kt)("p",null,"This is the final result for top-level function (stored in top-level segment)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-nasm"},";; prologue\npush   rbx\npush   rbp\npush   r10\npush   r11\npush   rbx\n\n;; load address of factorial-iterative function\nlea    rax,[rip+0x0]\n;; convert to GOAL pointer\nsub    rax,r15\n;; store in symbol table\nmov    DWORD PTR [r15+r14*1+0xbadbeef],eax\n\n;; load _format value\nmov    eax,DWORD PTR [r15+r14*1+0xbadbeef]\n;; store in format\nmov    DWORD PTR [r15+r14*1+0xbadbeef],eax\n\n;; load constant 10 (the greedy regalloc does poorly here)\nmov    eax,0xa\nmov    rbx,rax\n\n;; load format from symbol table\nmov    ebp,DWORD PTR [r15+r14*1+0xbadbeef]\n\n;; load #t from symbol table\nmov    r10d,DWORD PTR [r15+r14*1+0xbadbeef]\n\n;; get address of string\nlea    r11,[rip+0x0]\n;; convert to GOAL pointer\nsub    r11,r15\n\n;; get factorial-iterative from symbol table\nmov    ecx,DWORD PTR [r15+r14*1+0xbadbeef]\n;; move 10 into argument register\nmov    rdi,rbx\n;; convert factorial-iterative to a real pointer\nadd    rcx,r15\n;; call factorial\ncall   rcx\n\n;; move args into argument registers\nmov    rdi,r10\nmov    rsi,r11\nmov    rdx,rbx\nmov    rcx,rax\n\n;; call format\nadd    rbp,r15\ncall   rbp\n\n;; epilogue\npop    rbx\npop    r11\npop    r10\npop    rbp\npop    rbx\nret\n")),(0,r.kt)("p",null,"and the factorial function (stored in main segment)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-nasm"},"mov    eax,0x1\njmp    0x18\nmul    eax,edi\nmovsxd rax,eax\nmov    ecx,0x1\nsub    rdi,rcx\nmov    ecx,0x1\ncmp    rdi,rcx\njne    0xa\nret\n")),(0,r.kt)("h2",{id:"sending-and-receiving"},"Sending and Receiving"),(0,r.kt)("p",null,"The result of ",(0,r.kt)("inlineCode",{parentName:"p"},"codegen_object_file")," is sent with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"m_listener.send_code(data);\n")),(0,r.kt)("p",null,"which adds a message header then just sends the code over the socket."),(0,r.kt)("p",null,"The receive process is complicated, so this is just a quick summary"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Deci2Server")," receives it"),(0,r.kt)("li",{parentName:"ul"},"calls ",(0,r.kt)("inlineCode",{parentName:"li"},"GoalProtoHandler")," in chunks, which stores it in a buffer (",(0,r.kt)("inlineCode",{parentName:"li"},"MessBuffArea"),")"),(0,r.kt)("li",{parentName:"ul"},"Once fully received, ",(0,r.kt)("inlineCode",{parentName:"li"},"WaitForMessageAndAck")," will return a pointer to the message. The name of this function is totally wrong, it doesn't wait for a message, and it doesn't ack the message."),(0,r.kt)("li",{parentName:"ul"},"The main loop in ",(0,r.kt)("inlineCode",{parentName:"li"},"KernelCheckAndDispatch")," will see this message and run ",(0,r.kt)("inlineCode",{parentName:"li"},"ProcessListenerMessage")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ProcessListenerMessage")," sees that it has code, copies the message to the debug heap, and links it.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'auto buffer = kmalloc(kdebugheap, MessCount, 0, "listener-link-block");\nmemcpy(buffer.c(), msg.c(), MessCount);\nListenerLinkBlock->value = buffer.offset + 4;\nListenerFunction->value = link_and_exec(buffer, "*listener*", 0, kdebugheap, LINK_FLAG_FORCE_DEBUG).offset;\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"link_and_exec")," function doesn't actually execute anything because it doesn't have the ",(0,r.kt)("inlineCode",{parentName:"li"},"LINK_FLAG_EXECUTE")," set, it just links things. It moves the top level function and linking data to the top of the heap (temporary storage for the kernel) and keep both the main segment and debug segment of the code on the debug heap.  It'll move them together and eliminate gaps before linking.  After linking, the ",(0,r.kt)("inlineCode",{parentName:"li"},"ListenerFunction->value")," will contain a pointer to the top level function, which is stored in the top temp area of the heap.  This ",(0,r.kt)("inlineCode",{parentName:"li"},"ListenerFunction")," is the GOAL ",(0,r.kt)("inlineCode",{parentName:"li"},"*listener-function*")," symbol."),(0,r.kt)("li",{parentName:"ul"},"The next time the GOAL kernel runs, it will notice that ",(0,r.kt)("inlineCode",{parentName:"li"},"*listener-function*")," is set, then call this function, then set it to ",(0,r.kt)("inlineCode",{parentName:"li"},"#f")," to indicate it called the function."),(0,r.kt)("li",{parentName:"ul"},"After this, ",(0,r.kt)("inlineCode",{parentName:"li"},"ClearPending()")," is called, which sends all of the ",(0,r.kt)("inlineCode",{parentName:"li"},"print")," messages with the ",(0,r.kt)("inlineCode",{parentName:"li"},"Deci2Server")," back to the compiler."),(0,r.kt)("li",{parentName:"ul"},"Because the GOAL kernel changed ",(0,r.kt)("inlineCode",{parentName:"li"},"ListenerFunction")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"#f"),", it does a ",(0,r.kt)("inlineCode",{parentName:"li"},"SendAck()")," to send a special ",(0,r.kt)("inlineCode",{parentName:"li"},"ACK")," message to the compiler, saying \"I got the function, ran it, and didn't crash. Now I'm ready for more messages.\"")))}u.isMDXComponent=!0}}]);