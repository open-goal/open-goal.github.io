"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","label":"An Overview","href":"/docs/intro","docId":"intro"},{"type":"category","label":"Language Reference","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"OpenGOAL\'s Type System","href":"/docs/reference/type_system","docId":"reference/type_system"},{"type":"link","label":"OpenGOAL\'s Method System","href":"/docs/reference/method_system","docId":"reference/method_system"},{"type":"link","label":"OpenGOAL Syntax & Examples","href":"/docs/reference/syntax","docId":"reference/syntax"},{"type":"link","label":"Standard Library","href":"/docs/reference/lib","docId":"reference/lib"},{"type":"link","label":"Reader","href":"/docs/reference/reader","docId":"reference/reader"},{"type":"link","label":"GOOS","href":"/docs/reference/goos","docId":"reference/goos"},{"type":"link","label":"Object File Formats","href":"/docs/reference/object_file_formats","docId":"reference/object_file_formats"},{"type":"link","label":"Process and State","href":"/docs/reference/process_and_state","docId":"reference/process_and_state"},{"type":"link","label":"States in the Decompiler","href":"/docs/reference/decompiler_states","docId":"reference/decompiler_states"}],"href":"/docs/category/language-reference"},{"type":"category","label":"Usage","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Compiler REPL","href":"/docs/usage/repl","docId":"usage/repl"},{"type":"link","label":"OpenGOAL Debugger","href":"/docs/usage/debugging","docId":"usage/debugging"},{"type":"link","label":"Editor Configuration","href":"/docs/usage/editor_setup","docId":"usage/editor_setup"}],"href":"/docs/category/usage"},{"type":"category","label":"Developing","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Compiler Example","href":"/docs/developing/compiler_example","docId":"developing/compiler_example"},{"type":"link","label":"Assembly Emitter","href":"/docs/developing/asm_emitter","docId":"developing/asm_emitter"},{"type":"link","label":"Porting to x86","href":"/docs/developing/porting_to_x86","docId":"developing/porting_to_x86"},{"type":"link","label":"Registers","href":"/docs/developing/registers","docId":"developing/registers"}],"href":"/docs/category/developing"},{"type":"category","label":"PC Port Info","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Graphics","href":"/docs/port-info/graphics","docId":"port-info/graphics"},{"type":"link","label":"drawable_and_tfrag","href":"/docs/port-info/drawable_and_tfrag","docId":"port-info/drawable_and_tfrag"},{"type":"link","label":"Basic Process for Drawing","href":"/docs/port-info/tfrag","docId":"port-info/tfrag"},{"type":"link","label":"Porting Tfrag","href":"/docs/port-info/porting_tfrag","docId":"port-info/porting_tfrag"}],"href":"/docs/category/pc-port-info"}]},"docs":{"developing/asm_emitter":{"id":"developing/asm_emitter","title":"Assembly Emitter","description":"x86-64 has a lot of instructions.  They are described in Volume 2 of the 5 Volume \\"Intel\xae 64 and IA-32 Architectures Software Developer\u2019s Manual\\". Just this volume alone is over 2000 pages, which would take forever to fully implement.  As a result, we will use only a subset of these instructions.  This the rough plan:","sidebar":"docsSidebar"},"developing/compiler_example":{"id":"developing/compiler_example","title":"Compiler Example","description":"This describes how the compiler works using the following code snippet, saved in a file named example_goal.gc.","sidebar":"docsSidebar"},"developing/porting_to_x86":{"id":"developing/porting_to_x86","title":"Porting to x86","description":"This document will keep track of stuff that needs to be ported or modified significantly for x86. Anything that uses PS2-specific hardware or relies on stuff in the C Kernel will need to be ported.","sidebar":"docsSidebar"},"developing/registers":{"id":"developing/registers","title":"Registers","description":"Although modern computers are much faster than the PS2, and we could probably get away with a really inefficient register allocation scheme, I think it\'s worth it to get this right.","sidebar":"docsSidebar"},"intro":{"id":"intro","title":"An Overview","description":"This is the main documentation for the OpenGOAL language. It\'s designed to be read in order to learn OpenGOAL. It does not explain the OpenGOAL kernel or state system.","sidebar":"docsSidebar"},"port-info/drawable_and_tfrag":{"id":"port-info/drawable_and_tfrag","title":"drawable_and_tfrag","description":"Drawable Trees","sidebar":"docsSidebar"},"port-info/graphics":{"id":"port-info/graphics","title":"Graphics","description":"There are three frames in flight at a time:","sidebar":"docsSidebar"},"port-info/porting_tfrag":{"id":"port-info/porting_tfrag","title":"Porting Tfrag","description":"Tfrag is the renderer for non-instanced background geometry. It\'s typically used for the floor and unique walls/level geometry. It has a level of detail system, and time of day lighting, optionaly transparancy and that\'s it. No other features.","sidebar":"docsSidebar"},"port-info/tfrag":{"id":"port-info/tfrag","title":"Basic Process for Drawing","description":"The first main part just gets the \\"drawable trees\\" added to the list.","sidebar":"docsSidebar"},"reference/decompiler_states":{"id":"reference/decompiler_states","title":"States in the Decompiler","description":"How can I tell if a file has states?","sidebar":"docsSidebar"},"reference/goos":{"id":"reference/goos","title":"GOOS","description":"GOOS is a macro language for GOAL. It is a separate language.  Files written in GOAL end in .gc and files written in GOOS end in .gs.  The REPL will display a goos> prompt for GOOS and gc > for GOAL.","sidebar":"docsSidebar"},"reference/lib":{"id":"reference/lib","title":"Standard Library","description":"Runtime Functions","sidebar":"docsSidebar"},"reference/method_system":{"id":"reference/method_system","title":"OpenGOAL\'s Method System","description":"OpenGOAL has a virtual method system. This means that child types can override parent methods.  The first argument to a method is always the object the method is being called on, except for new.","sidebar":"docsSidebar"},"reference/object_file_formats":{"id":"reference/object_file_formats","title":"Object File Formats","description":"CGO/DGO Files","sidebar":"docsSidebar"},"reference/process_and_state":{"id":"reference/process_and_state","title":"Process and State","description":"What is a process?","sidebar":"docsSidebar"},"reference/reader":{"id":"reference/reader","title":"Reader","description":"GOOS and GOAL both use the same reader, which converts text files to S-Expressions and allows these s-expressions to be mapped back to a line in a source file for error messages.  This document explains the syntax of the reader.  Note that these rules do not explain the syntax of the language (for instance, GOAL has a much more complicated system of integers and many more restrictions), but rather the rules of how your program source must look.","sidebar":"docsSidebar"},"reference/syntax":{"id":"reference/syntax","title":"OpenGOAL Syntax & Examples","description":"The Basics","sidebar":"docsSidebar"},"reference/type_system":{"id":"reference/type_system","title":"OpenGOAL\'s Type System","description":"This document explains the GOAL type system.  The GOAL type system supports runtime typing, single inheritance, virtual methods, and dynamically sized structures.","sidebar":"docsSidebar"},"usage/debugging":{"id":"usage/debugging","title":"OpenGOAL Debugger","description":"The debugger works on Windows and Linux. All the platform specific code is in xdbg.cpp. When attached to a target, things like exceptions from invalid memory access or divides by zero break into the debugger for inspection on the code or values that caused the break. The technical implementation of the debugger across multiple platforms means there will be a few differences in how it handles or displays certain things. For example, the debugger on Linux will break if the GOAL (EE) thread runs into a breakpoint, but on Windows this can be caused by any thread on the target as the thread that (:break) breaks is unspecified.","sidebar":"docsSidebar"},"usage/editor_setup":{"id":"usage/editor_setup","title":"Editor Configuration","description":"EMacs","sidebar":"docsSidebar"},"usage/repl":{"id":"usage/repl","title":"Compiler REPL","description":"When you start the OpenGOAL compiler, you\'ll see a prompt like this:","sidebar":"docsSidebar"}}}')}}]);