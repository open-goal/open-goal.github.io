"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[991],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return n?r.createElement(h,l(l({ref:t},d),{},{components:n})):r.createElement(h,l({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},78593:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return u}});var r=n(87462),a=n(63366),i=(n(67294),n(3905)),l=["components"],o={sidebar_position:5},s="Reader",p={unversionedId:"reference/reader",id:"reference/reader",title:"Reader",description:"GOOS and GOAL both use the same reader, which converts text files to S-Expressions and allows these s-expressions to be mapped back to a line in a source file for error messages.  This document explains the syntax of the reader.  Note that these rules do not explain the syntax of the language (for instance, GOAL has a much more complicated system of integers and many more restrictions), but rather the rules of how your program source must look.",source:"@site/documentation/reference/reader.md",sourceDirName:"reference",slug:"/reference/reader",permalink:"/docs/reference/reader",draft:!1,editUrl:"https://github.com/open-goal/open-goal.github.io/tree/master/documentation/reference/reader.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"docsSidebar",previous:{title:"Standard Library",permalink:"/docs/reference/lib"},next:{title:"GOOS",permalink:"/docs/reference/goos"}},d={},u=[{value:"Integer Input",id:"integer-input",level:2},{value:"Floating Point Input",id:"floating-point-input",level:2},{value:"Character Input",id:"character-input",level:2},{value:"Strings",id:"strings",level:2},{value:"Comments",id:"comments",level:2},{value:"Array",id:"array",level:2},{value:"Pair",id:"pair",level:2},{value:"List",id:"list",level:2},{value:"Symbol",id:"symbol",level:2},{value:"Reader Macros",id:"reader-macros",level:2}],c={toc:u};function m(e){var t=e.components,n=(0,a.Z)(e,l);return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"reader"},"Reader"),(0,i.kt)("p",null,"GOOS and GOAL both use the same reader, which converts text files to S-Expressions and allows these s-expressions to be mapped back to a line in a source file for error messages.  This document explains the syntax of the reader.  Note that these rules do not explain the syntax of the language (for instance, GOAL has a much more complicated system of integers and many more restrictions), but rather the rules of how your program source must look."),(0,i.kt)("h2",{id:"integer-input"},"Integer Input"),(0,i.kt)("p",null,"Integers handled by the reader are 64-bits. Any overflow is considered an error.  An integer can be specified as a decimal, like ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"-12345"),"; in hex, like ",(0,i.kt)("inlineCode",{parentName:"p"},"#xbeef"),"; or in binary, like ",(0,i.kt)("inlineCode",{parentName:"p"},"#b101001"),". All three representations can be used anywhere an integer is used. Hex numbers do not care about the case of the characters. Decimal numbers are signed, and wrapping from a large positive number to a negative number will generate an error.  The valid input range for decimals is ",(0,i.kt)("inlineCode",{parentName:"p"},"INT64_MIN")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"INT64_MAX"),".  Hex and binary are unsigned and do not support negative signs, but allow large positive numbers to wrap to negative.  Their input range is ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"UINT64_MAX"),".  For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," can be entered as ",(0,i.kt)("inlineCode",{parentName:"p"},"-1")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"#xffffffffffffffff"),", but not as ",(0,i.kt)("inlineCode",{parentName:"p"},"UINT64_MAX")," in decimal. "),(0,i.kt)("h2",{id:"floating-point-input"},"Floating Point Input"),(0,i.kt)("p",null,"Floating point values handled by the reader are implemented with ",(0,i.kt)("inlineCode",{parentName:"p"},"double"),". Weird numbers (denormals, NaN, infinity) are invalid and not handled by the reader directly.  A number ",(0,i.kt)("em",{parentName:"p"},"must")," have a decimal point to be interpreted as floating point. Otherwise, it will be an integer.  Leading/trailing zeros are optional."),(0,i.kt)("h2",{id:"character-input"},"Character Input"),(0,i.kt)("p",null,"Characters are used to represent characters that are part of text.  The character ",(0,i.kt)("inlineCode",{parentName:"p"},"c")," is represented by ",(0,i.kt)("inlineCode",{parentName:"p"},"#\\c"),".  This representation is used for all ASCII characters between ",(0,i.kt)("inlineCode",{parentName:"p"},"!")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"~"),".  There are three special characters which have a non-standard representation:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Space : ",(0,i.kt)("inlineCode",{parentName:"li"},"#\\\\s")),(0,i.kt)("li",{parentName:"ul"},"New Line: ",(0,i.kt)("inlineCode",{parentName:"li"},"#\\\\n")),(0,i.kt)("li",{parentName:"ul"},"Tab: ",(0,i.kt)("inlineCode",{parentName:"li"},"#\\\\t"))),(0,i.kt)("p",null,"All other characters are invalid."),(0,i.kt)("h2",{id:"strings"},"Strings"),(0,i.kt)("p",null,"A string is a sequence of characters, surrounding by double quotes.  The ASCII characters from ",(0,i.kt)("inlineCode",{parentName:"p"}," ")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"~")," excluding ",(0,i.kt)("inlineCode",{parentName:"p"},'"')," can be entered directly.  Strings have the following escape codes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\\\")," : insert a backslash"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\n")," : insert a new line"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"\\t")," : insert a tab"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'\\"')," : insert a double quote")),(0,i.kt)("h2",{id:"comments"},"Comments"),(0,i.kt)("p",null,"The reader supports line comments with ",(0,i.kt)("inlineCode",{parentName:"p"},";")," and multi-line comments with ",(0,i.kt)("inlineCode",{parentName:"p"},"#| |#"),". For example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},'(print "hi") ; prints hi\n\n#|\nthis is a multi-line comment!\n(print "hi") <- this is commented out.\n|#\n')),(0,i.kt)("h2",{id:"array"},"Array"),(0,i.kt)("p",null,"The reader supports arrays with the following syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"; array of 1, 2, 3, 4\n#(1 2 3 4)\n")),(0,i.kt)("p",null,"Arrays can be nested with lists, pairs, and other arrays."),(0,i.kt)("h2",{id:"pair"},"Pair"),(0,i.kt)("p",null,"The reader supports pairs with the following syntax:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},"; pair of a, b\n(a . b)\n")),(0,i.kt)("p",null,"Pairs can be nested with lists, pairs, and arrays."),(0,i.kt)("h2",{id:"list"},"List"),(0,i.kt)("p",null,"The reader supports lists. Lists are just an easier way of constructing a linked list of pairs, terminated with the empty list.  The empty list is a special list written like ",(0,i.kt)("inlineCode",{parentName:"p"},"()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},"; list of 1, 2, 3\n(1 2 3)\n; actually the same as\n(1 . (2 . (3 . ())))\n")),(0,i.kt)("h2",{id:"symbol"},"Symbol"),(0,i.kt)("p",null,"A symbol is a sequence of characters containing no whitespace, and not matching any other data type. (Note: this is not a very good definition). Typically symbols are lower case, and words are separated by a ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),". Examples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lisp"},"this-is-a-symbol\n; you can have weird symbols too:\n#f\n#t\n-\n*\n+\n__WEIRDLY-NamedSymbol ; this is weird, but OK.\n")),(0,i.kt)("h2",{id:"reader-macros"},"Reader Macros"),(0,i.kt)("p",null,"The reader has some default macros which are common in Scheme/LISP:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"'x")," will be replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"(quote x)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"}," `x")," will be replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"(quasiquote x)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},",x")," will be replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"(unquote x)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},",@")," will be replaced with ",(0,i.kt)("inlineCode",{parentName:"li"},"(unquote-splicing x)"))))}m.isMDXComponent=!0}}]);